So far, the examples that we saw only had a single generic type parameter. However, functions can have multiple parameters, and we might want to type them using multiple generic type parameters.

For example - 

    const returnBothOfWhatIPassIn = (a: unknown, b: unknown) => {
        return { a, b };
    }

Here, we have a function that takes in two parameters 'a' and 'b', both of type 'unknown', and returns an object containing both parameters.

We can call this function as -

    const result = returnBothOfWhatIPassIn(42, "Hello");
    // result is of type { a: unknown; b: unknown; }

Here, the issue is that even though we passed in a number and a string, the return type is still { a: unknown; b: unknown; }, which means we lose the information about the types of 'a' and 'b'.

We want TypeScript to infer that 'a' is a number and 'b' is a string in this case.

Can we pass multiple generic type parameters to achieve this? Yes, we can!

All we have to do is define our function with two generic type parameters, say T and U, and use them to type the parameters 'a' and 'b' respectively -

    const returnBothOfWhatIPassIn = <T, U>(a: T, b: U) => {
        return { a, b };
    }

Here, we are defining our function with two generic type parameters T and U. The parameter 'a' is of type T, and 'b' is of type U.

And now, when we call this function as before -

    const result = returnBothOfWhatIPassIn(42, "Hello");
    // result is of type { a: number; b: string; }

So, TypeScript correctly infers that 'a' is of type number and 'b' is of type string, and the return type is { a: number; b: string; }.

And we are not restricted to only 1 or 2 generic type parameters - we can have as many as we need!