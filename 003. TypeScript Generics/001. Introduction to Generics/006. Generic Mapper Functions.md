Here is a really good use case of Generics in real-world applications - Mapper Functions.

We know that in functions like 'map', the  argument is a function that takes an element of the array and returns a new element. The type of the returned element can be different from the type of the input element.

This argument to this function is a perfect candidate for using Generics.

Let's say we want to map over an array of users (where each user is an object with 'firstName' and 'lastName' properties and some other properties which are not mandatory) and returns an array where each user also gets a new entry 'fullName' which is a combination of 'firstName' and 'lastName'.

That is, if we have -

    const users = [
        { firstName: 'John', lastName: 'Doe' },
        { firstName: 'Jane', lastName: 'Smith' },
        { firstName: 'Alice', lastName: 'Johnson' },
    ];

We want to map over this array and get -

    const mappedUsers = [
        { firstName: 'John', lastName: 'Doe', fullName: 'John Doe' },
        { firstName: 'Jane', lastName: 'Smith', fullName: 'Jane Smith' },
        { firstName: 'Alice', lastName: 'Johnson', fullName: 'Alice Johnson' },
    ];

The simplest approach is to do -

    users.map(user => ({
        ...user,
        fullName: `${user.firstName} ${user.lastName}`,
    }));

But a lot of times, we create a reusable mapper function because we might be using this logic in multiple places.

So, we might do -

    const concatenateFirstNameAndLastName = (user: unknown)  => {
        return {
            ...user,
            fullName: `${user.firstName} ${user.lastName}`
        }
    }

    const mappedUsers = users.map(concatenateFirstNameAndLastName);

Now, at runtime, this will work just fine. But TypeScript will throw an error because it doesn't know the type of 'user' inside the 'concatenateFirstNameAndLastName' function.

That's because we have typed 'user' as 'unknown', and TypeScript cannot guarantee that 'user' has 'firstName' and 'lastName' properties.

We want to make sure that whatever 'user' object gets passed to this function has 'firstName' and 'lastName' properties of type 'string'. It can have any other properties but these two properties must be there.

Well, this sounds like a perfect use case for constraints in Generics.

So, we can do -

        const concatenateFirstNameAndLastName = <T extends {firstName: string, lastName: string}>(user: T)  => {
        return {
            ...user,
            fullName: `${user.firstName} ${user.lastName}`
        }
    }

Here, we have defined a Generic type 'T' which extends an object type that has 'firstName' and 'lastName' properties of type 'string'. THhis means, whatever type 'T' is, it must have these two properties.

And now, when we use this function in 'map', TypeScript will ensure that the objects in the 'users' array have 'firstName' and 'lastName' properties.

Moreover, when we do -

    const mappedUsers = users.map(concatenateFirstNameAndLastName);

The type of 'mappedUsers' will be inferred correctly by TypeScript as -

    ({
        firstName: string;
        lastName: string;
    } & {
        fullName: string;
    })[]

So, the type here is an array of objects that have 'firstName', 'lastName', and 'fullName' properties, exactly what we want!

This is a good example of how Generics can be used to create flexible and reusable functions while still maintaining strong type safety in TypeScript.