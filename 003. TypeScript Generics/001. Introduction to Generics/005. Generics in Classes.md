So, we have so far used Generic Types in our normal Types and also in Functions. But Generics can also be used in Classes.

Let's say we have a class -

    export class Component {
        private props: unknown;

        constructor(props: unknown) {
            this.props = props;
        }

        getProps() {
            return this.props;
        }
    }

This is a simple class named 'Component' which has a private property 'props' of type 'unknown'. The constructor takes an argument of type 'unknown' and assigns it to the 'props' property. The class also has a method 'getProps' that returns the value of 'props'.

What if we do -

    const component = new Component({ a: 1, b: 2, c: 3 });
    const result = component.getProps();

Right now, since we have typed 'props' as 'unknown', the type of 'result' will also be 'unknown'. This means we won't have any type information about the properties of the object we passed to the constructor.

Moreover, we cannot just say that the type of the props will be 'an object' with 'a', 'b' and 'c' because it can be any shape of object with different properties.

This is a problem we can fix using a generic type parameter.

Just like functions and types, we can define a generic type parameter for classes as well. Here's how we can modify the 'Component' class to use generics:

    export class Component<T> {
        private props: T;

        constructor(props: T) {
            this.props = props;
        }

        getProps() {
            return this.props;
        }
    }

Here, we have added a generic type parameter 'T' to the 'Component' class. The 'props' property is now of type 'T', and the constructor takes an argument of type 'T'. The 'getProps' method still returns the value of 'props', which is now of type 'T'.

So all of this means that whenever we create a new instance of this class, TypeScript will infer the type of 'T' based on the argument we pass to the constructor.

So, if we do -

    const component = new Component({ a: 1, b: 2, c: 3 });
    const result = component.getProps();

Now, the type of 'result' will be -

    {
        a: number;
        b: number;
        c: number;
    }

And now, we can pass any shape of object to the constructor, and TypeScript will correctly infer the type of 'props' and 'result' based on the argument we provide.

    const component1 = new Component({ x: 'hello', y: 'world' });
    const result1 = component1.getProps();

Here, the type of 'result1' will be -

    {
        x: string;
        y: string;
    }

So, this shows how we can use generics in classes to create flexible and reusable components while still maintaining strong type safety.