So far, we have seen how to use generics with functions that take primitive types as parameters. However, generics are equally powerful when working with object parameters. By using generics with objects, we can create flexible and reusable functions that can handle a variety of object shapes while maintaining type safety.

Let's say we have -

    const returnBothOfWhatIPassIn = (params: { a: unknown; b: unknown }) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

    const result = returnBothOfWhatIPassIn({
        a: 42,
        b: "Hello, Generics!",
    });

    Here, the result will be of type '{ first: unknown; second: unknown; }'.

Here, our function takes an object with properties 'a' and 'b', both of type 'unknown'. While this works, it doesn't provide much type safety or flexibility. We can improve this by using generics.

# APPROACH 1 - Not that flexible

So, how we do that? From what we have learned so far, we can do maybe -

    const returnBothOfWhatIPassIn = <T>(params: T) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

Well, the problem is that while we have made the function generic, we haven't constrained the type 'T' to ensure it has the properties 'a' and 'b'. And we see an error above because we try to access properties 'a' and 'b' on a type that could be anything.

So, how do we tell TypeScript that 'T" must be an object with properties 'a' and 'b'?

Well, this points towards using 'extends' keyword with generics.

    const returnBothOfWhatIPassIn = <T extends { a: number, b: string}>(params: T) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

And now, when we call the function -

    const result = returnBothOfWhatIPassIn({
        a: 42,
        b: "Hello, Generics!",
    });

We will see that the type of 'result' is now '{ first: number; second: string; }', which is exactly what we want.

So here, we have defined a generic type 'T' that extends an object type with properties 'a' of type 'number' and 'b' of type 'string'. This way, we ensure that any object passed to the function must have these properties, while still allowing for additional properties if needed.

This is important. With 'extends' we only define the minimum structure that the object must have, but it can have more properties as well. This is not the same as adding a type annotation directly to the parameter, which would restrict the object to only those properties.

That is, if we had -

    const returnBothOfWhatIPassIn = (params: { a: number; b: string }) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

We cannot call this function with an object that has additional properties, like -

    const result = returnBothOfWhatIPassIn({
        a: 42,
        b: "Hello, Generics!",
        c: true, // Error: Object literal may only specify known properties, and 'c' does not exist in type '{ a: number; b: string; }'.
    });

But, when we use generics with 'extends', we can do that -

    const returnBothOfWhatIPassIn = <T extends { a: number, b: string}>(params: T) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

    const result = returnBothOfWhatIPassIn({
        a: 42,
        b: "Hello, Generics!",
        c: true, // No error
    });

So, remember that using generics with 'extends' allows us to create flexible functions that can work with objects of varying shapes while still enforcing the presence of certain properties. This makes our code more reusable and type-safe.

There is a problem with this approach. What if we want to have more flexibility in the types of 'a' and 'b'? What if we want 'a' to be of any type and 'b' to be of any type, not just 'number' and 'string'? And we want to keep the type safety? That's where we can use multiple generic types.

# APPROACH 2

We can use multiple generic types to type the object parameters more flexibly - 

    const returnBothOfWhatIPassIn = <A, B>(params: { a: A; b: B }) => {
        return {
            first: params.a,
            second: params.b,
        };
    }

Here, instead of defining a single generic type 'T' that extends an object type, we define two separate generic types 'A' and 'B'. The parameter 'params' is then typed as an object with properties 'a' of type 'A' and 'b' of type 'B'.

So, we are now going deep in the passed object and just defining the types of the properties we care about.

When we call the function -

    const result = returnBothOfWhatIPassIn({
        a: 42,
        b: "Hello, Generics!",
    });

The type of 'result' will again be '{ first: number; second: string; }', just like in the previous approach.

The benefit is that we do not have to type the first parameter strictly as a 'number' and the second as a 'string'. They can be of any type, and TypeScript will infer the types based on the arguments we pass.

We can even combine this with a Type Helper like -

    type Params<A, B> = {
        a: A;
        b: B;
    };

    const returnBothOfWhatIPassIn = <A, B>(params: Params<A, B>) => {
        return {
            first: params.a,
            second: params.b,
        };
    }