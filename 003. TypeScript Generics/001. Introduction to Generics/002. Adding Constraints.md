In the last section, we learned about generics in TypeScript. We saw how generics allow us to create reusable components that can work with a variety of types while still maintaining type safety.

Let's take the same example of a generic function that returns the value passed to it -

    const returnWhatIPassIn = <T>(t: T) => {
        return t;
    }

What if we want to ensure that the thing that we pass as the argument 't' is a string? In other words, we want to add a constraint to our generic type parameter 'T' so that it can only be of type 'string'.

We can do that using the 'extends' keyword in TypeScript. Here's how we can modify our function to add this constraint -

    const returnWhatIPassIn = <T extends string>(t: T) => {
        return t;
    }

Here, we have added 'extends string' to our generic type parameter 'T'. This means that 'T' can only be a type that is assignable to 'string'. And since number or boolean or other types are not assignable to string, TypeScript will throw an error if we try to pass those types to the function -

    const numberValue = returnWhatIPassIn(42); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.
    const stringValue = returnWhatIPassIn("Hello"); // stringValue is of type "Hello"
    const booleanValue = returnWhatIPassIn(true); // Error: Argument of type 'boolean' is not assignable to parameter of type 'string'.

This is the same thing as if we had a type helper like -

    type ReturnWhatIPassIn<T extends string> = T;

    type numberType = ReturnWhatIPassIn<42>; // Type 'number' does not satisfy the constraint 'string'.