Let's say we have a function that takes a key and a value as an input and based on the key, it returns something -

    type Person = {
        name: string;
        age: number;
        birthDate: Date;
    };
    
    function remapPerson<K extends keyof Person>(key: K, value: Person[K]): Person[K] {
        if (key === 'birthDate') {
            return new Date();
        }

        return value;
    }

Here, we have a function 'remapPerson' that takes a key of type 'K' which extends the keys of the 'Person' type, and a value of type 'Person[K]'. The function checks if the key is 'birthDate', and if so, it returns a new Date object. Otherwise, it returns the value passed in.

At first glance, this seems like a valid implementation but as soon as you write this code in your IDE, you will see the error at the 'return' statement for the 'new Date()' saying -

    Type 'Date' is not assignable to type 'Person[K]'.
        Type 'Date' is not assignable to type 'never'.

Well, looking at this error, it looks like 'Person[K]' is being inferred as 'never' type. That is pretty interesting.

We have a function where it accepts a generic type parameter which is a union of keys of an object type. Since it can accept a union of keys, it means we can call this function like -

    remapPerson<"age" | "name">("age", 30);

So here, notice how we are passing a union of keys of the 'Person' type as the generic type parameter. This is perfectly valid and it will work without any issues. But if you hover over the 'remapPerson' function you will see -

    function remapPerson<"name" | "age">(key: "name" | "age", value: string | number): string | number

So, this function can now return either a string or a number.

Because 'K' is a generic, TypeScript thinks: "What if K is actually a union like 'name' | 'birthDate'?" In that case, the return type would need to satisfy both strings and dates.

And due to this, TypeScript cannot really trust any type of Narrowing that we do inside this type of a generic function. In simple words, TypeScript treats 'key' inside this generic function as 'any key of Person', even if we explicitly have a check for a specific key like the 'birthDate'.

That's why, when we return a 'new Date()', TypeScript tries to check - Is Date assignable to Person[K] for every possible key of Person? And since 'Person[K]' can be either 'string' or 'number' (because of the union of keys we passed), TypeScript concludes that 'Date' is not assignable to 'string' or 'number', and hence it gives us the error that 'Date' is not assignable to 'never' (because 'never' is the type that represents a value that never occurs, and since 'Date' cannot be assigned to 'string' or 'number', it is inferred as 'never').

And so, when you start seeing such errors in Generic functions, it means it is our job to tell TypeScript that we are doing the right thing and we know what we are doing.

Well, the solution to this problem is to use Type Assertions. We can assert the type of the value we are returning to be of type 'Person[K]'. This way, we are telling TypeScript that we know what we are doing and it should trust us -

    function remapPerson<K extends keyof Person>(key: K, value: Person[K]): Person[K] {
        if (key === 'birthDate') {
            return new Date() as Person[K];
        }
        return value;
    };

So now, we are asserting that the type of 'new Date()' is 'Person[K]'. This will fix the error and now TypeScript will trust us that we are returning the correct type.

Remember that the Generic type parameters are not narrowed by runtime checks, even if the check looks airtight to a human. So, when you are working with Generic functions and you have such errors, it is a good idea to use Type Assertions to tell TypeScript that you know what you are doing.