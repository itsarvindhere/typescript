We all know what 'Currying' is in functional programming. It is a technique of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.

For example, instead of having -

    function add(a, b) {
        return a + b;
    }

We can have -

    function add(a) {
        return function(b) {
            return a + b;
        }
    }

Basically, here, the 'add' function takes a single argument 'a' and returns another function that takes a single argument 'b' and returns the sum of 'a' and 'b'.

So now, we can call it like -

    const x = add(5)(10); // x will be 15

So, how is this useful? Currying allows us to create more flexible and reusable functions. We can create partially applied functions, which are functions that have some of their arguments fixed. This can be particularly useful in scenarios where we want to create specialized versions of a function.

Now, coming to TypeScript, let's say we have a function that is like this -

    const curryFunction = function(t: number) {
        return function(u: number) {
            return function(v: number) {
                return {
                    t,
                    u,
                    v
                };
            }
        };
    };

Here, we have a curried function that takes three arguments 't', 'u', and 'v' in a curried manner. Now, we can call this function like -

    const result = curryFunction(1)(2)(3);
    console.log(result); // { t: 1, u: 2, v: 3 }

So, right now, what do you think will be the type of 'result'? It is not hard to guess that the type of 'result' will be -

    {
        t: number;
        u: number;
        v: number;
    }

But, let's say that this function should be able to accept any type of arguments, not just numbers. In that case, we can make this function generic. We can define a generic type parameter for each argument. Here's how we can do it -

    const curryFunction = function<T, U, V>(t: T) {
        return function(u: U) {
            return function(v: V) {
                return {
                    t,
                    u,
                    v
                };
            }
        };
    };

Looks pretty good, right? Now, this function can accept any type of arguments. We can call it like -

    const result = curryFunction<string, boolean, number>('Hello')(true)(42);
    console.log(result); // { t: 'Hello', u: true, v: 42 }

Now, what do you think will be the type of 'result' now?

Well, surprisingly, it will be -

    const result: {
        t: string;
        u: unknown;
        v: unknown;
    }

So, even though our function is generic and we have specified the types for 't', 'u', and 'v', TypeScript is not able to infer the types for 'u' and 'v'.

Only the first type parameter 'T' is being inferred correctly, while the other two type parameters 'U' and 'V' are being inferred as 'unknown'.

This is quite confusing.

One way to fix this issue is to explicitly specify the type parameters when calling the function. For example -

    const result = curryFunction<string, boolean, number>('Hello')(true)(42);

But this is not very convenient. It would be nice if TypeScript could infer the types for 'u' and 'v' as well.

Well, the solution is -

    const curryFunction = function<T>(t: T) {
        return function<U>(u: U) {
            return function<V>(v: V) {
                return {
                    t,
                    u,
                    v
                };
            }
        };
    };

Interesting. So, here, we have moved the generic type parameters inside the function. Now, each function has its own generic type parameter. This way, TypeScript can correctly infer the types for 't', 'u', and 'v'.

But, why was it not working when we had all the generic type parameters at the top level?

Well, just think of this case. Let's just ignore that there are any nested functions. Let's say we just had -

    const curryFunction = function<T, U, V>(t: T) {
        return 'Hello world';
    };

    const result = curryFunction('Hello');

Here, what do you think will be the type of 'curryFunction'?

Well, it will be -

    const curryFunction: <string, unknown, unknown>(t: string) => string

So, notice how the type parameters 'U' and 'V' are being inferred as 'unknown' which makes sense here because here, we are only passing an argument for 'T', and there is no way for TypeScript to infer the types for 'U' and 'V'.

This is exactly the reason why in the previous example, when we had all the generic type parameters at the top level, TypeScript was not able to infer the types for 'u' and 'v'. When we had - 

    const curryFunction = function<T, U, V>(t: T) {
        return function(u: U) {
            return function(v: V) {
                return {
                    t,
                    u,
                    v
                };
            }
        };
    };

All the type arguments were attached to the first function, and since we were only passing an argument for 'T', TypeScript was inferring 'U' and 'V' as 'unknown'.

But when we moved the generic type parameters inside the function, each function had its own generic type parameter, and TypeScript was able to correctly infer the types for 't', 'u', and 'v'.

So, always keep this in mind that each function can capture its own generic type parameters. So it is important to note where are you putting your generic type parameters when you are working with functions.