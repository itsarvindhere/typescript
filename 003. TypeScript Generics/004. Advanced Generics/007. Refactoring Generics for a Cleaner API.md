Let's say we have a function -

    const useStyled = <T = {}>(func: (theme: T) => CSSProperties) => {
        return {} as CSSProperties;
    };

You might have seen something like this in React projects.

So, we can use this now like -


    interface MyTheme {
        color: {
            primary: string;
        };
        fontSize: {
            small: string;
        };
    }

    const buttonStyle = useStyled<MyTheme>(theme => ({
        color: theme.color.primary,
        fontSize: theme.fontSize.small,
    }));

    const divStyle = useStyled<MyTheme>(theme => ({
        backgroundColor: theme.color.primary,
    }));

Here, we have to specify the type parameter 'MyTheme' every time we call 'useStyled'.

This can be a bit verbose, especially if we have to use it in multiple places.

So, what if we could refactor our code such that we specify the type parameter only once, and then we can use the 'useStyled' function without having to specify the type parameter every time?

Well, that's something we can do using a Factory function. If you do not know, a Factory function is a function that returns another function. So, we can create a function that returns the 'useStyled' function and this outer function is the one that takes the type parameter.

    const makeUseStyled = <T = {}>() => {
        const useStyled = (func: (theme: T) => X) => {
            return {} as X;
        };

        return useStyled;
    };

Here, we have created a function 'makeUseStyled' that takes a type parameter 'T' and returns the 'useStyled' function.

Notice how we have specified the type parameter at the very top level, and this is then used in the inner function 'useStyled' without having to specify it again.

Now, it is worth mentioning that this factory function pattern is the only way we can do this in TypeScript. Because as we know, in generic functions, the generic type arguments are tied to the function itself. So, if we want to have a generic type parameter that is shared across multiple calls to the function, we need to use a factory function.

But this is an extremely useful pattern. It helps us avoid repetition and makes our code cleaner.