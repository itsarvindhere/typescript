In the last section, we saw how sometimes we might overuse generics, and how that can lead to code that is more complex than it needs to be. In this section, we will look at the opposite problem: when we forget to use generics where they would be helpful.

Let's say we have -

    const getValue = <T>(obj: T, key: keyof T) => {
        return obj[key];
    };

This is a pretty simple function that takes an object and a key, and returns the value at that key. 

So, we can use it like -

    const obj = {
        a: 1,
        b: 'hello',
        c: true
    };

    const numberResult = getValue(obj, 'a');
    const stringResult = getValue(obj, 'b');
    const booleanResult = getValue(obj, 'c');

Here, we have used the 'getValue' function to get values of different types from the object.

But there is one problem here. If you hover over the 'numberResult', 'stringResult', and 'booleanResult' variables, you will see that they are all of type -

    string | number | boolean

And this is because the 'getValue' function is not able to infer the type of the value that is being returned. All that it knows is that 'T' is some type, and that the key is a key of that type. So, it can only infer that the return type is a union of all the possible types that could be returned.

This is a case of missing generics. We have defined the 'getValue' function to be generic, but we are not using the generic type parameter 'T' in a way that allows TypeScript to infer the return type correctly.

Well, the solution is to explicitly have a second generic type parameter for the key -

    const getValue = <T, K extends keyof T>(obj: T, key: K) => {
        return obj[key];
    }

So now, when we hover over the 'numberResult', 'stringResult', and 'booleanResult' variables, we will see that they are of the correct types -

    const numberResult: number
    const stringResult: string
    const booleanResult: boolean

But why did this work? Well, by adding the second generic type parameter 'K', we are telling TypeScript that 'K' is a key of 'T'. This allows TypeScript to infer the return type based on the key that is being passed in. So, if we pass in 'a', TypeScript knows that the return type will be 'number', if we pass in 'b', it knows that the return type will be 'string', and if we pass in 'c', it knows that the return type will be 'boolean'.

In the previous code, TypeScript was not able to infer the return type because it did not have enough information about the relationship between the key and the value. We were typing the 'key' parameter as 'keyof T', which is a union of all the keys of 'T', but we were not telling TypeScript which specific key we were using. By introducing the second generic type parameter 'K', we are providing that information, and allowing TypeScript to infer the return type correctly.