Let's say we have a function that takes either a 'hello' or a 'goodbye' string and returns the opposite -

    function youSayGoodbyeISayHello(greeting: unknown){
        return greeting === 'goodbye' ? 'hello' : 'goodbye';
    }

We can call this function with either 'hello' or 'goodbye', and it will return the opposite -

    const result1 = youSayGoodbyeISayHello('hello'); // returns 'goodbye'
    const result2 = youSayGoodbyeISayHello('goodbye'); // returns 'hello'

Here, the return type of the function is always a string, but we want it to be more specific. We want the return type to be 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye'.

So, how do we achieve this? Well, we can use generics here to know the passed in type and return the opposite type.

So, we know that using generics we can do something like -

    function youSayGoodbyeISayHello<T extends string>(greeting: T) {
        return greeting === 'goodbye' ? 'hello' : 'goodbye';
    }

But, right now, the return type is still just string. We want it to be more specific. We want it to be 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye'.

So it looks like here, we also have to type the return type of the function.

Our return type will be either 'goodbye' or 'hello' depending on the input type. That is, our return type depends on the value of 'T'. So, it looks like we have to use conditional types here. Can we use conditional types here? Yes, we can. We can do -

    function youSayGoodbyeISayHello<T extends string>(greeting: T): T extends 'hello' ? 'goodbye' : 'hello' {
        return greeting === 'goodbye' ? 'hello' : 'goodbye';
    }

So now, if we hover over the function, we can see that the return type is 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye'. 

    const result1 = youSayGoodbyeISayHello('hello'); // result1 is of type 'goodbye'
    const result2 = youSayGoodbyeISayHello('goodbye'); // result2 is of type 'hello'

But now, there is another error thrown by TypeScript for this line -

    return greeting === 'goodbye' ? 'hello' : 'goodbye';

The error says -

    Type '"hello"' is not assignable to type 'T extends "hello" ? "goodbye" : "hello"'

    Type '"goodbye"' is not assignable to type 'T extends "hello" ? "goodbye" : "hello"'.

So, it looks like somehow, TypeScript is not able to infer the return type of the function correctly. Well, there is a solution for this and it is sort of a hacky solution because we have to tell TypeScript that we know better than it does about the return type of the function. We can do this by using a type assertion.

    function youSayGoodbyeISayHello<T extends string>(greeting: T): T extends 'hello' ? 'goodbye' : 'hello' {
        return (greeting === 'goodbye' ? 'hello' : 'goodbye') as any;
    }

Yes, it looks ugly, but it works. Now, if we hover over the function, we can see that the return type is 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye'. 

    const result1 = youSayGoodbyeISayHello('hello'); // result1 is of type 'goodbye'
    const result2 = youSayGoodbyeISayHello('goodbye'); // result2 is of type 'hello'

There is another solution. Instead of having a return type, why not tell TypeScript that the return type is 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye' by using a type assertion on the return value itself.

So, we can say -

    function youSayGoodbyeISayHello<T extends string>(greeting: T) {
        return (greeting === 'goodbye' ? 'hello' : 'goodbye') as (T extends 'hello' ? 'goodbye' : 'hello');
    }

Here, we are not specifying the return type of the function, but we are telling TypeScript that the return value is of type 'goodbye' if the input is 'hello', and 'hello' if the input is 'goodbye'. In this way, TypeScript can infer the return type of the function correctly without us having to specify it explicitly.

    const result1 = youSayGoodbyeISayHello('hello'); // result1 is of type 'goodbye'
    const result2 = youSayGoodbyeISayHello('goodbye'); // result2 is of type 'hello'

You can make it cleaner by creating a type alias for the return type of the function. 

    type Opposite<T> = T extends 'hello' ? 'goodbye' : 'hello';

    function youSayGoodbyeISayHello<T extends string>(greeting: T): Opposite<T> {
        return (greeting === 'goodbye' ? 'hello' : 'goodbye') as Opposite<T>;
    }

The bottom line is that TypeScript cannot map the conditional return type to the actual return value of the function, so we have to use a type assertion to tell TypeScript that we know better than it does about the return type of the function.

So, if you ever have to use a conditional type as a return type of a function, you will have to use a type assertion to tell TypeScript that you know better than it does about the return type of the function.