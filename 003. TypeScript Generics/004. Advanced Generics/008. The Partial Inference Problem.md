Let's talk about something that is quite annoying when working with TypeScript generics: the partial inference problem.

Let's say we have a function -

    const makeSelectors = <
        TSource,
        TSelectors extends Record<string, (source: TSource) => any> = {}
    > (selectors: TSelectors) => {
        return selectors;
    };

Here, we have a function 'makeSelectors' that takes a generic type 'TSource' and another generic type 'TSelectors' which is a record of string keys and functions that take 'TSource' as an argument. The default value for 'TSelectors' is an empty object.

And inside the function, we simply return the 'selectors' that we receive as an argument.

This looks correct, right?

Let's say we have an interface -

    interface Source {
        firstName: string;
        middleName: string;
        lastName: string;
    };

And we can now use the 'makeSelectors' function to create some selectors for our 'Source' interface -

    const selectors = makeSelectors<Source>({
        getFullName: (source) => `${source.firstName} ${source.middleName} ${source.lastName}`,
        getFirstAndLastName: (source) => `${source.firstName} ${source.lastName}`,
        getFirstNameLength: (source) => source.firstName.length,
    })

Here, we are calling 'makeSelectors' with the 'Source' type and passing an object with three selector functions. Each function takes a 'source' and returns some derived value.

Now, ideally, if we think about it, the 'source' parameter should be of type -

    {
        firstName: string;
        middleName: string;
        lastName: string;
    }

Because that's what we have defined in our 'makeSelectors' function. However, if we hover over the 'source' parameter in our selector functions, we will see that it is of type 'any'.

That's pretty interesting.

If we hover over the 'makeSelectors' function call, we will see that the type is -

    const makeSelectors: <{
        firstName: string;
        middleName: string;
        lastName: string;
    }, {}>(selectors: {}) => {}

So, we can see that while it correctly inferred the 'TSource' type as our 'Source' interface, it failed to infer the 'TSelectors' type and defaulted it to an empty object.

Interestingly, if we remove the 'Source' type argument and let TypeScript infer it from the selector functions, we will see that it correctly infers both 'TSource' and 'TSelectors' types.

    const selectors = makeSelectors({
        getFullName: (source) => `${source.firstName} ${source.middleName} ${source.lastName}`,
        getFirstAndLastName: (source) => `${source.firstName} ${source.lastName}`,
        getFirstNameLength: (source) => source.firstName.length,
    });

In this case, if you hover over 'makeSelectors', the type will be -

    const makeSelectors: <unknown, {
        getFullName: (source: any) => string;
        getFirstAndLastName: (source: any) => string;
        getFirstNameLength: (source: any) => any;
    }>(selectors: {
        getFullName: (source: any) => string;
        getFirstAndLastName: (source: any) => string;
        getFirstNameLength: (source: any) => any;
    }) => {
        getFullName: (source: any) => string;
        getFirstAndLastName: (source: any) => string;
        getFirstNameLength: (source: any) => any;
    }

So, now, while the 'TSource' type is inferred as 'unknown', the 'TSelectors' type is correctly inferred as the object we passed in.

That's pretty weird. It looks like as soon as we pass one type argument, inference doesn't work for the other type arguments.

This is what we call the Partial Inference Problem in TypeScript generics.

In TypeScript, the partial inference problem refers to the limitation where you cannot provide some generic type arguments manually while letting the compiler infer the rest for the same function call. It is an "all or nothing" system.

When you define a function with generics, like '<T, U>', TypeScript expects you to be consistent. If you manually pass a type for 'T', TypeScript stops trying to infer 'U' from your function arguments and will often default 'U' to unknown or throw an error if it can't be resolved.

This is still an issue in TypeScript and there is no way to solve it directly. However, there are some workarounds that we can use to mitigate this problem.

The solution is to use a factory function pattern where we have an outer function that takes the 'TSource' type and returns an inner function that takes the 'TSelectors' type -

    const makeSelectors = <TSource>() => {
        const makeSelectorsFn =  <TSelectors extends Record<string, (source: TSource) => any>>(selectors: TSelectors) => {
            return selectors;
        }

        return makeSelectorsFn;
    };

Here, we have an outer function 'makeSelectors' that takes the 'TSource' type and returns an inner function 'makeSelectorsFn' that takes the 'TSelectors' type.

And now, we can use this factory function to create our selectors -

    const selectors = makeSelectors<Source>()({
        getFullName: (source) => `${source.firstName} ${source.middleName} ${source.lastName}`,
        getFirstAndLastName: (source) => `${source.firstName} ${source.lastName}`,
        getFirstNameLength: (source) => source.firstName.length,
    });

And now, the type of 'source' will correctly be inferred as our 'Source' interface in all the selector functions.

Yes, this is a little messy and requires an extra function call, but it is a workaround to the partial inference problem in TypeScript generics.