Let's say we have an interface for our Cache -

    interface ICache<T> {
        get: (key: string) => T | undefined;
        set: (key: string, value: T) => void;
        clone: (transform: (element: unknown) => unknown) => ICache<unknown>;
    }

Here, we have a generic interface 'ICache' that takes a type parameter 'T'. The 'get' method returns a value of type 'T' or 'undefined', the 'set' method takes a key and a value of type 'T', and the 'clone' method takes a transform function and returns a new 'ICache' with an unknown type.

Let's say we have a function to create the cache -

    const createCache = <T>(initialCache?: Record<string, T>): ICache<T> => {
        const cache: Record<string, T> = initialCache || {};

        return {
            get: (key) => cache[key],
            set: (key, value) => {
                cache[key] = value;
            },
            clone: (transform) => {
                const newCache: Record<string, any> = {};
                for (const key in cache) {
                    newCache[key] = transform(cache[key]);
                }
                return createCache(newCache);
            }
        };
    };

So, here, the 'createCache' function takes an optional initial cache and returns an object that implements the 'ICache' interface. The 'get' method retrieves a value from the cache, the 'set' method adds or updates a value in the cache, and the 'clone' method creates a new cache by applying a transformation function to each element in the existing cache.

So far, nothing seems wrong.

Now, we can use this function to create caches like this -

    const numberCache = createCache<number>();
    numberCache.set('one', 1);
    console.log(numberCache.get('one')); // Output: 1

    const stringCache = createCache<string>();
    stringCache.set('hello', 'world');
    console.log(stringCache.get('hello')); // Output: 'world'

Now, let's try the 'clone' method. Let's say we want to clone our 'number' cache and transform the values to strings -

    const clonedCache = numberCache.clone((value) => String(value));
    
Here, we created a new cache by cloning the 'numberCache' and transforming the values to strings. 

The issue right now is that the type of the cloned cache is 'ICache<unknown>', which means we lose the type information about the values in the cache. This can lead to issues when we try to use the cloned cache, as we won't know what type of values it contains.

The reason why it is 'unknown' is because the 'clone' method is defined to return 'ICache<unknown>', which means that the type of the cloned cache is not specified and defaults to 'unknown'.

So, how do we fix this issue? Basically we want to make sure the type of the cloned cache is correctly inferred based on the transform function we provide.

Now, in the last section, we understood how generics work with functions. If you attach generic type parameters to a function, they will be inferred based on the arguments you pass to that function. Right now, our clone function is -

    interface ICache<T> {
        get: (key: string) => T | undefined;
        set: (key: string, value: T) => void;
        clone: <U>(transform: (element: T) => U) => ICache<U>;
    }

So, right now, the 'clone' method is defined to take a transform function that takes an 'unknown' element and returns an 'unknown' value, and it returns an 'ICache<unknown>'.

Since we know that any object that implements this 'ICache' interface will eventually deal with caches of 'T' values, it means the 'transform' method that we pass to the 'clone' function should also take 'T' values as input.

    clone: (transform: (element: T) => unknown) => ICache<unknown>;

But that's just one part of the problem. The other part is that the return type of the 'clone' method is still 'ICache<unknown>', which means we still lose the type information about the cloned cache.

We want TypeScript to properly infer the type of the cloned cache based on the transform function we provide. Well, we can make the 'clone' method a generic function that takes a type parameter 'U' which represents the type of the values in the cloned cache. This way, when we call the 'clone' method and provide a transform function, TypeScript can infer the type of 'U' based on the return type of the transform function -

    interface ICache<T> {
        get: (key: string) => T | undefined;
        set: (key: string, value: T) => void;
        clone: <U>(transform: (element: T) => U) => ICache<U>;
    }

And that's it!

So here, what we did is we made the 'clone' method a generic function that takes a type parameter 'U'. The transform function now takes an element of type 'T' and returns a value of type 'U', and the return type of the 'clone' method is now 'ICache<U>'. This way, when we call the 'clone' method and provide a transform function, TypeScript can infer the type of 'U' based on the return type of the transform function, and we won't lose the type information about the cloned cache.

It is important to understand where we add the generic type parameters. It wouldn't have worked if we had done -

    clone: (transform: (element: T) => T) => ICache<T>;

Because here, we are not making the 'clone' method a generic function, so TypeScript won't be able to infer the type of the cloned cache based on the transform function we provide. The return type of the 'clone' method would always be 'ICache<T>', which means we would still lose the type information about the cloned cache if we provide a transform function that returns a different type.

This is a really good example to understand how generics work with functions and how we should put the generic type parameters in the right place to ensure that TypeScript can properly infer the types based on the arguments we provide.

This example also shows that even if you are inside a generic class or a generic interface, you can still have generic functions that take their own type parameters, and those type parameters can be inferred based on the arguments you pass to those functions. This allows for a lot of flexibility and power when working with generics in TypeScript.