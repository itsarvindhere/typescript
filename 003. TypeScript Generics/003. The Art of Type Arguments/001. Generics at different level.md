Let's say we have a function -

    const getHomePageFeatureFlags = (
        config: unknown,
        override: (flags: unknown) => unknown
    ) => {
        return override(config.rawConfig.featureFlags.homePage);
    };

This function takes in a config object and an override function. It retrieves the home page feature flags from the config and then applies the override function to it.

Let's say our config is something that can have any properties in it but it has to have a 'rawConfig' property which is an object that has a 'featureFlags' property which is an object that has a 'homePage' property.

So, a valid config object could look like this:

    const EXAMPLE_CONFIG = {
        apiEndPoint: "https://api.example.com",
        apiVersion: "v1",
        apiKey: "abcdef",
        rawConfig: {
            featureFlags: {
                homePage: {
                    showBanner: true,
                    showLogOut: false
                },
                loginPage: {
                    showCaptcha: true,
                    showConfirmPassword: false
                }
            }
        }
    };

Here, we have a config object with some properties and a 'rawConfig' property that contains the feature flags for the home page and login page.

Now, we want to make this function a generic function so that if we call it -


    const flags = getHomePageFeatureFlags(EXAMPLE_CONFIG, (flags) => {
        return {
            ...flags,
            showBanner: false // Override to hide the banner
        };
    });

We want to the type of 'flags' to be correctly inferred as:

    {
        showBanner: boolean;
        showLogOut: boolean;
    }

So, how can we do it?

# FIRST APPROACH 

Well, the first approach is to create an object that represents the shape of the config object and then we can use that as a type argument for our function. Since we know that the mandatory properties of the config object are 'rawConfig' and 'featureFlags', we can define a type for it like this:

    type Config = {
        rawConfig: {
            featureFlags: {
                homePage: any
            }
        }
    };

So, there can be any type of config object as long as it has a 'rawConfig' property that has a 'featureFlags' property that has a 'homePage' property.

Now, we want to ensure that our function accepts a 'config' that satisfies this 'Config' type. We can do this by making our function a generic function that takes in a type parameter 'T' which extends 'Config'. This way, we can ensure that the 'config' parameter of our function is of type 'T' which satisfies the shape defined by 'Config'.

    const getHomePageFeatureFlags = <T extends Config>(
        config: T,
        override: (flags: unknown) => unknown
    ) => {
        return override(config.rawConfig.featureFlags.homePage);
    };

Here, we have made our function a generic function that takes in a type parameter 'T' which extends 'Config'. This means that the 'config' parameter of our function must be of type 'T' which satisfies the shape defined by 'Config'.

Alright, that's first part of our solution. Now, we also want to ensure that the 'override' function is correctly typed. We want the 'flags' parameter of the 'override' function to be of the same type as the 'homePage' property of the 'featureFlags' object in the 'config'.

Since T is an object type, we know we can use indexed access types to get the type of the 'homePage' property. We can do this by using 'T["rawConfig"]["featureFlags"]["homePage"]' to get the type of the 'homePage' property. And so, we can do -

    const getHomePageFeatureFlags = <T extends Config>(
        config: T,
        override: (flags: T['rawConfig']['featureFlags']['homePage']) => T['rawConfig']['featureFlags']['homePage']
    ) => {
        return override(config.rawConfig.featureFlags.homePage);
    };

Here, we are telling TypeScript that the 'flags' parameter of the 'override' function is of the same type as the 'homePage' property of the 'featureFlags' object in the 'config'. And we are also telling TypeScript that the return type of the 'override' function is also of the same type as the 'homePage' property.

And now, if we check the type of 'flags' when we call our function -

    const flags = getHomePageFeatureFlags(EXAMPLE_CONFIG, (flags) => {
        return {
            ...flags,
            showBanner: false // Override to hide the banner
        };
    });

This will be inferred as:

    {
        showBanner: boolean;
        showLogOut: boolean;
    }

Exactly what we wanted! We have successfully made our function a generic function that can accept any config object as long as it satisfies the shape defined by 'Config' and we have also correctly typed the 'override' function to ensure that the types are correctly inferred.

# SECOND APPROACH

The solution above has a downside that we have to manually index into the 'config' object to get the type of the 'homePage' property. This can be a bit verbose and can also lead to errors if we make a typo in the property names.

There is a better way.

    const getHomePageFeatureFlags = <HomePageFeatureFlags>(
        config: {
            rawConfig: {
                featureFlags: {
                    homePage: HomePageFeatureFlags
                }
            }
        },
        override: (flags: HomePageFeatureFlags) => HomePageFeatureFlags
    ) => {
        return override(config.rawConfig.featureFlags.homePage);
    };

What just happened here is that we have made our function a generic function that takes in a type parameter 'HomePageFeatureFlags' which represents the type of the 'homePage' property of the 'featureFlags' object in the 'config'. We have then used this type parameter to type the 'flags' parameter of the 'override' function and also the return type of the 'override' function.

You can see how this is much cleaner and less error-prone than the previous approach. We don't have to manually index into the 'config' object to get the type of the 'homePage' property. We can simply use the 'HomePageFeatureFlags' type parameter to represent that type.

So basically, we are telling TypeScript to infer the type of 'HomePageFeatureFlags' from the 'config' object when we call our function. This way, we can ensure that the types are correctly inferred without having to manually index into the 'config' object.

Generally, it is recommended that your Type Argument should represent the low level thing that you want to work with in your function. In this case, the low level thing is the type of the 'homePage' property of the 'featureFlags' object in the 'config'. By making our type argument represent this low level type, we can ensure that our function is more flexible and can work with any config object as long as it has the correct shape.
