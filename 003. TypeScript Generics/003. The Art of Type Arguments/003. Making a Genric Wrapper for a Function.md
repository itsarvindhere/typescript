Let's take a function -

    const makeSafe = (func: unknown) => 
    (...args: unknown): 
        | { type: "success", result: unknown}
        | { type: "failure", error: Error } => {
            try {
            const result = func(...args);
            return {
                type: 'success',
                result
            }
            } catch(e) {
            return {
                type: 'failure',
                error: e as Error
            }
            }
    }

Here, we have a function 'makeSafe' that takes a function 'func' as an argument and returns a new function that wraps the original function in a try-catch block. The returned function will return an object indicating whether the original function succeeded or failed, along with the result or error.

So, we can call it like -

    const func = makeSafe(() => 1);
    const result = func();

What do you think will be the type of 'result' here? It will be -

    | { type: "success", result: unknown}
    | { type: "failure", error: Error }

Here, the type is a union type that can either be a success object containing the result of the original function or a failure object containing the error that occurred. The 'result' property in the success case is of type 'unknown', which means it can be any type, and the 'error' property in the failure case is of type 'Error'.

The issue here is that we want to have a more specific type for the 'result' property in the success case, rather than just 'unknown'. The type that we want is -

    | { type: "success", result: number }
    | { type: "failure", error: Error }

This is possible if we make our 'makeSafe' function generic. Because if it is a generic function, TypeScript will be able to infer the type of the 'result' property based on the type of the original function that we pass in.

And yes, it means we also need to type the 'func' parameter as well, so that TypeScript can infer the return type of the original function.

# FIRST APPROACH

We know that whatever type is passed inside this 'makeSafe' function will be a 'function'. So, we can add a constraint to our generic type parameter to ensure that it is a function.

    const makeSafe = <T extends (...args: any) => any>(func: T) => ....

Here, we have defined a generic type parameter 'T' that extends a function type. This means that 'T' can be any function type.

Next up, we want to make sure that the 'result' will be the same type as the 'Return Type' of the original function. So, we can use the 'ReturnType' utility type to extract the return type of the original function and use it in our return type.

    | { type: "success", result: ReturnType<T>}

Here, we are using the 'ReturnType' utility type to extract the return type of the original function 'T' and use it as the type of the 'result' property in the success case.

Finally, we want to ensure that the function returned by 'makeSafe' has the same parameters as the original function. So, we can use the 'Parameters' utility type to extract the parameter types of the original function and use them in our returned function.

    (...args: Parameters<T>): 
        | { type: "success", result: ReturnType<T>}
        | { type: "failure", error: Error } => ...

And now, we have a fully typed 'makeSafe' function that can infer the types of the original function's parameters and return type, providing a more specific type for the 'result' property in the success case.

# SECOND APPROACH

There is another way we can do this. Instead of adding constraint to our generic type parameter to be a function, we can do -

    const makeSafe = <TParams extends any[], TReturnType>(func: (...args: TParams) => TReturnType) => 
    (...args: TParams): 
        | { type: "success", result: TReturnType}
        | { type: "failure", error: Error } => {...}
    
Here, we have defined two generic type parameters 'TParams' and 'TReturnType'. 'TParams' is an array of 'any' type, which represents the parameter types of the original function, and 'TReturnType' represents the return type of the original function. We then use these generic type parameters to type the 'func' parameter and the return type of the returned function.

So in this approach, we are explicitly defining the parameter types and return type of the original function, rather than using the 'ReturnType' and 'Parameters' utility types to infer them. Both approaches achieve the same result, and the only difference is where we do the extraction of the parameter types and return type of the original function.