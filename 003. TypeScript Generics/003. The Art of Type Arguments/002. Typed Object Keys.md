Let's say we have a function that uses the 'Object.keys' method to get the keys of an object.

    const typedObjectKeys = (obj: unknown) => {
        return Object.keys(obj);
    };

Here, the return type of the 'typedObjectKeys' function is 'string[]', which is not very useful because we lose the information about the actual keys of the object.

What if we call this function as -

    const result1 = typedObjectKeys({ a: 1, b: 2 });

In this case, ideally, we would like to have the type of 'result1' to be an array of the keys of the object, which are 'a' and 'b'. However, since the return type is 'string[]', we don't get that information.

And if you try to see the type of 'Object.keys', it is not a generic method -
        
    keys(o: object): string[];

So here, the return type is always 'string[]', which is not what we want. We want it to be an array of the keys of the object that we pass in.

# FIRST APPROACH

Well, the simplest approach would be to do -

    const typedObjectKeys = <T extends object>(obj: T) => {
        return Object.keys(obj) as Array<keyof T>;
    };

Here, we are using a generic type parameter 'T' that extends 'object'. This means that 'T' can be any object type. Then, we are asserting the return type of 'Object.keys(obj)' to be 'Array<keyof T>', which is an array of the keys of the object 'T'.

# SECOND APPROACH

Remember that in the last section, we saw how we should try to make the Type arguments represent the specific information that we want to capture.

In our case, we do not even want to care about the type of the values of the object. We only care about the keys.

Since the keys are the only thing that matter to us, why not make the type argument represent the keys directly? We can do that by using a mapped type.

    const typedObjectKeys = <T extends string>(obj: Record<T, any>) => {
        return Object.keys(obj) as Array<T>;
    };

What happened here? We are using a generic type parameter 'T' that extends 'string'. This means that 'T' can be any string type. Then, we are using 'Record<T, any>' to represent an object type where the keys are of type 'T' and the values can be of any type.

In this way, whatever object is passed to the 'typedObjectKeys' function, the type of 'T' will be inferred to be the keys of that object. Therefore, the return type of 'Object.keys(obj)' will be correctly inferred as 'Array<T>', which is an array of the keys of the object.

This is different from the first approach because in the first approach, the type parameter 'T' represents the entire object type, and we have to use 'keyof T' to get the keys. In the second approach, the type parameter 'T' directly represents the keys, so we can use it directly in the return type.

Now, it is not necessary to do this every time because sometimes, we do want to capture the entire object type. But in cases where we only care about the keys, this second approach can be more straightforward and easier to understand.