With Objects, TypeScript also behaves differently when it comes to generic inference.

Let's start with a simple example where we have a function which takes an object which has an 'input' property and returns the value of that property:

    const acceptsValueInAndObject = <T>(obj: { input: T }) => {
        return obj.input;
    };

Here, we have a generic function 'acceptsValueInAndObject' that takes an object with a property 'input' of type 'T' and returns the value of that property. 

When we call this function, TypeScript will try to infer the type of 'T' based on the argument we pass in. For example:

    const result = acceptsValueInAndObject({ input: "abc" });\

What do you think the type of 'result' will be in this case? Will it be "abc" or will it be 'string'? In this case, TypeScript will infer the type of 'T' as 'string', so the type of 'result' will be 'string'.

But, what if the object we pass has the 'as const' assertion? For example:

    const result = acceptsValueInAndObject({ input: "abc" } as const);

Now, the type of 'result' will be the literal type "abc" instead of 'string'. This is because the 'as const' assertion tells TypeScript to treat the value as a constant, which allows it to infer the more specific literal type.

Alright, let's take it one step further now. What if we add a constraint to out type parameter 'T' to only allow string?

    const acceptsValueInAnObjectFieldWithConstraint = 
        <T extends string>(obj: { input: T }) => {
            return obj.input;
        };

Here, we have added a constraint to our type parameter 'T' using 'extends string'. This means that 'T' can only be a subtype of 'string'.

Now, if we call -

    const result4 = acceptsValueInAnObjectFieldWithConstraint({ input: "abc" });

You will see that the type of 'result4' is now "abc". This is something we saw in the last section as well when we added a constraint to our type parameter. The constraint allows TypeScript to infer the more specific literal type instead of the broader 'string' type.

But, now comes the interesting part.

What if instead our generic type parameter 'T' represents the entire object instead of just the 'input' property? For example:

    const acceptValueWithObjectConstraint = 
        <T extends { input: string }>(obj: T) => {
            return obj.input;
        }

Here, we have a generic function 'acceptValueWithObjectConstraint' that takes an object of type 'T' which extends an object with an 'input' property of type 'string'.

At first glance, it looks like nothing is different here. But, when we call this function -

    const result5 = acceptValueWithObjectConstraint({ input: "abc" });

As we might have expected the type of 'result5' is "string".

But, maybe we can use 'as const' here as well to get the literal type?

    const result6 = acceptValueWithObjectConstraint({ input: "abc" } as const);

Well, surprisingly, the type of 'result6' is still "string".

This is because the constraint on 'T' is on the entire object, not just the 'input' property. So, even though we are using 'as const', TypeScript still infers the type of 'T' as an object with an 'input' property of type 'string', which means that the type of 'result6' is "string" instead of "abc".

What does this tell us?

Well, it shows that where you put the generic inference matters a lot. If you want to get the more specific literal type, you need to make sure that the generic inference is happening at the level of the property that you want to infer, rather than at the level of the entire object.

So, if the entire object is being inferred as a generic type, then the properties of that object will not be able to be inferred as literal types, even if you use 'as const'. On the other hand, if the generic inference is happening at the level of the property itself, then you can get the more specific literal type if you want.

Remember, the choices of what do you want your type arguments to represent do matter and can have an impact on the types that TypeScript infers for your variables.