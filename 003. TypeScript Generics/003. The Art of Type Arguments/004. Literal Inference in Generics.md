We have see a lot of examples of generics so far but how does TypeScript actually infers the thing that we are passing to the generic function?

Let's take an example to understand this better,

Suppose, we have a function that takes something and returns the same thing. And it is a generic function, so we can pass anything to it.

    const returnsValueOnly = <T>(t: T) => {
        return t;
    };

Here, we have a generic function 'returnsValueOnly' that takes a parameter 't' of type 'T' and returns it. The type 'T' is a placeholder for any type that we want to use when we call the function.


So, we can call it like -

    const result1 = returnsValueOnly(42); // T is inferred as 42
    const result2 = returnsValueOnly("Hello"); // T is inferred as "Hello"

If you notice here, the type of 'T' is inferred as the literal type of the value we are passing to the function. In the first call, 'T' is inferred as the literal type '42', and in the second call, 'T' is inferred as the literal type '"Hello"'.

Now, what happens if instead of returning a value, we return an object that contains the value?

    const returnsValueInAnObject = <T>(t: T) => {
        return {
            t
        };
    };

What do you think will happen if we call -

    const result3 = returnsValueInAnObject(42);
    const result4 = returnsValueInAnObject("Hello");

The type of result3 will be -

    {
        t: number;
    }

And similarly, the type of result4 will be -

    {
        t: string;
    }

Inside the returned object, the type of 't' is no longer inferred as the literal type, but instead it is inferred as the broader type 'number' for the first call and 'string' for the second call.

But, here is where it gets interesting. If we explicitly tell TypeScript that 'T' will be a string or a number, then the type of 't' inside the returned object will be inferred as the literal type.

    const returnsValueInAnObjectWithExplicitType = <T extends string | number>(t: T) => {
        return {
            t
        };
    };

Now, if we call -

    const result5 = returnsValueInAnObjectWithExplicitType(42);
    const result6 = returnsValueInAnObjectWithExplicitType("Hello");

Here, the type of 't' inside the returned object will be inferred as the literal type '42' for result5 and '"Hello"' for result6.

So, there are some times when TypeScript will throw you off. In the first case, it is possible that we got the literal type because we are returning the value directly. But in the second case, we are returning an object that contains the value, so TypeScript infers the broader type instead of the literal type. But when we explicitly tell TypeScript that 'T' can only be a string or a number, it is able to infer the literal type correctly.

So, depending on our use case, we can choose any of these approaches to get the desired type inference. TypeScript tries to be as helpful as possible, but sometimes it might not infer the type the way we expect it to.