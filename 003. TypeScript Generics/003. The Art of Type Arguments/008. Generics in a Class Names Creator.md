Let's say we have a function that returns a function like this -

    const createClassNamesFactory = (classes: unknown) => {
        return (type: unknown, ...otherClasses: string[]) => {
            const classList = [classes[type], ...otherClasses];
            return classList.join(" ");
        };
    };

So, right now, we have a 'createClassNamesFactory' function that takes an object 'classes' and returns another function. This returned function takes a 'type' and any number of additional class names, combines them into a single string, and returns that string.

So, we can call it like -

    const getBg = createClassNamesFactory({
        primary: "bg-blue-500",
        secondary: "bg-gray-500",
    });

    const result1 = getBg("primary");
    const result2 = getBg("secondary");

Now, at this point, our function is not type-safe. And TypeScript does show an error where we are accessing 'classes[type]', because 'classes' is of type 'unknown' so TypeScript cannot be sure that 'type' is a valid key of 'classes'.

Now, how do we make this type-safe using Generics?

Remember, the choices of what do you want your type arguments to represent do matter and can have an impact on the types that TypeScript infers for your variables.

In our case, what is it that we want TypeScript to infer? In our case, it is the keys of the 'classes' object that we want TypeScript to infer. We do not care about the entire 'classes' object itself, we just care about its keys.

So, it is the keys of the 'classes' object that our generic type argument should represent.

So, we can say -

    const createClassNamesFactory = <T extends string>(classes: Record<T, string>) => {
        return (type: T, ...otherClasses: string[]) => {
            const classList = [classes[type], ...otherClasses];
            return classList.join(" ");
        };
    };

Alright, what did we do here.

We defined a generic type parameter 'T' that extends 'string'. This means that 'T' can be any string type. Then, we used 'T' to define the type of the 'classes' parameter as 'Record<T, string>'. This means that 'classes' is an object where the keys are of type 'T' and the values are of type 'string'.

Then, in the returned function, we used 'T' as the type of the 'type' parameter. This means that 'type' must be one of the keys of the 'classes' object.

In this way, we have made our function type-safe. Now, if we try to call 'getBg' with an invalid key, TypeScript will show an error.

If we try to call -

    const result3 = getBg("tertiary");

We will see an error because 'tertiary' is not a valid key of the 'classes' object -

    Argument of type '"tertiary"' is not assignable to parameter of type '"primary" | "secondary"'

Of course another way to make this function type-safe is by making our generic type argument represent the entire 'classes' object itself like this -

    const createClassNamesFactory = <T extends Record<string, string>>(classes: T) => {
        return (type: keyof T, ...otherClasses: string[]) => {
            const classList = [classes[type], ...otherClasses];
            return classList.join(" ");
        };
    };

Here, we defined a generic type parameter 'T' that extends 'Record<string, string>'. This means that 'T' can be any object where the keys are strings and the values are strings. Then, we used 'keyof T' as the type of the 'type' parameter in the returned function. This means that 'type' must be one of the keys of the 'classes' object.

This will work too so it depends on your preference which approach you want to take. Personally, I prefer the first approach where the generic type argument represents the keys of the 'classes' object because it is more explicit about what we want TypeScript to infer.



