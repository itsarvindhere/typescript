Let's take another real-world example.

Let's say we have a function that takes a URL and fetches some data from that URL -

    const fetchData = async (url: string) => {
        const data = await fetch(url).then(response => response.json());
        return data;
    }

Here, we have a 'fetchData' function that takes a URL as a string and fetches data from that URL. The function returns the fetched data.

Now, we can use it like -

    const promise = fetchData<{ title: string }>('https://jsonplaceholder.typicode.com/posts/1');

    promise.then(data => {
        console.log(data);
    });

But, what will be the type of 'data' here?

If you hover over 'data', you'll see that its type is 'any'. Similarly, the type of 'promise' is 'Promise<any>'.

Now, this makes sense because we didn't specify what type of data we are expecting from the 'fetchData' function. It could be anything - an object, an array, a string, etc.

Maybe we can pass some type argument to the 'fetchData' function to specify what type of data we are expecting.

    const fetchData = async <T>(url: string) => {
        const data = await fetch(url).then(response => response.json());
        return data;
    }

    const promise = fetchData<{ title: string }>('https://jsonplaceholder.typicode.com/posts/1');

    promise.then(data => {
        console.log(data);
    });


But now the question is, where do we use this 'T' inside the 'fetchData' function?

One thing we can do is to use this 'T' in the 'fetch' function to let TypeScript know what type of data we are expecting from the 'fetch' function.

In case of 'reduce' we could do -

    reduce<something...>{...}

Can we do the same with 'fetch'?

Unfortunately, we cannot do that because the 'fetch' function does not accept any type arguments. If you see its definition, it is not generic.

    declare function fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;

So here, 'fetch' is not a generic function.

Well, if we cannot pass the type argument to 'fetch', can we at least tell TypeScript that the 'data' we are getting from 'fetch' is of type 'T'?

Yes we can.

We can do -

    const fetchData = async <T>(url: string) => {
        const data: T = await fetch(url).then(response => response.json());
        return data;
    }

Now, we are telling TypeScript that the 'data' we are getting from 'fetch' is of type 'T'.

And now, if you hover over 'data' inside the 'then' callback, you'll see that its type is '{ title: string }'. Similarly, the 'promise' variable will have the type 'Promise<{ title: string }>'.


You could've done it differently, maybe by doing -

    const fetchData = async <T>(url: string): Promise<T> => {
        const data = await fetch(url).then(response => response.json());
        return data;
    }

But if you do it this way, even though TypeScript knows that this function returns a 'Promise<T>', it still doesn't know what type 'data' is inside the function. So, 'data' will still be of type 'any'. So if you try to access any property on 'data' inside the function, you'll get an error.

The best way is to explicitly tell TypeScript that 'data' is of type 'T' -

    const fetchData = async <T>(url: string) => {
        const data: T = await fetch(url).then(response => response.json());
        return data;
    }

You could've also done -

    const fetchData = async <T>(url: string) => {
        const data = await fetch(url).then((response): Promise<T> => response.json());
        return data;
    }

So, this is how we can use generics to avoid 'any' types in real-world scenarios.