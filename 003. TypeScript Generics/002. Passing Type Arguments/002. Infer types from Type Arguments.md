Let's say we have a Generic class -

    class Component<T> {
        #props: T;

        constructor(props: T) {
            this.#props = props;
        }

        getProps() {
            return this.#props;
        }
    }

Here, we have a generic class 'Component' that takes a type parameter 'T'. The constructor of the class accepts an argument of type 'T', and we have a method 'getProps' that returns the value of the private property '#props'.

Nothing new here as this is something we have already seen.

Now, we want to create a function which takes an instance of type 'Component' as an argument and returns a new component with the same props.

Something like -

    const cloneComponent = (component: unknown) => {
        return new Component(component.getProps());
    }

At runtime, this function will work perfectly fine. However, TypeScript will throw an error because it cannot infer the type of 'component' and hence cannot determine the type of props.

Right now, the type of 'component' is 'unknown', so TypeScript has no information of a 'getProps' method existing on it.

Now, you can say that lets just say that 'component' is of type 'Component<any>' -

    const cloneComponent = (component: Component<any>) => {
        return new Component(component.getProps());
    }

The errors goes away and we can call this function like this -

    const component = new Component({ name: 'Test', value: 42 });
    const clonedComponent = cloneComponent(component);

But, if you hover over the type of 'clonedComponent', you will see that it is of type 'Component<any>'.

This means, 'T' that is the type parameter of 'Component' is now 'any', and we have lost the actual type information of the props.

And you will see this when you try to access the props -

    const props = clonedComponent.getProps();
    // props is of type 'any'

This is not what we want. We want the type of 'clonedComponent' to be 'Component<{ name: string; value: number }>'.

But of course the props can be any type, so we cannot hardcode the type as an object with 'name' and 'value' properties.

Basically, we want out 'cloneComponent' function to be generic itself, so that it can infer the type of 'T' from the argument passed to it.

And well, that's something we can easily do by making the function generic -

    const cloneComponent = <T>(component: Component<T>) => {
        return new Component(component.getProps());
    }

Here, we have made the 'cloneComponent' function generic by adding a type parameter 'T'. The type of the 'component' argument is now 'Component<T>', which means that TypeScript can infer the type of 'T' from the argument passed to the function.

So, when we do -

    const component = new Component({ name: 'Test', value: 42 });
    const clonedComponent = cloneComponent(component);

This is what happens step by step -

    1. We create a new instance of 'Component' with props of type '{ name: string; value: number }'.
    2. The 'cloneComponent' function infers the type 'T' as '{ name: string; value: number }' from the argument passed to it.
    3. The return type of 'cloneComponent' is now 'Component<{ name: string; value: number }>'.
    4. When we call 'getProps' on 'clonedComponent', TypeScript knows that the type of props is '{ name: string; value: number }'.