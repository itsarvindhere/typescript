Let's take a real-world example.

Let's say we have an array -

    const array = [
        {
            name: 'John'
        },
        {
            name: 'Steve'
        }
    ];

Now, we want to create an object where the key is the name of the person and the value is the person object itself That is, something like -

    {
        John: { name: 'John' },
        Steve: { name: 'Steve' }
    }

One way to do this is by using the 'reduce' function. Something like -

    const obj = array.reduce((accum, item) => {
        accum[item.name] = item;
        return accum;
    }, {});

But, since we are using TypeScript, of course we cannot leave it untyped. Moreover, we will already see some errors here.

TypeScript will throw an error where we are doing 'accum[item.name] = item;' because it cannot be sure that 'item.name' is a valid key for the accumulator object -

    Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{}'.
        No index signature with a parameter of type 'string' was found on type '{}'.

Why is that?

If you hover over the 'accum' parameter, you will see that its type is inferred to be '{}'. This is because we have passed an empty object '{}' as the initial value to the 'reduce' function. And TypeScript infers the type of 'accum' from that initial value.

Now, since type is '{}', TypeScript cannot be sure that 'item.name' (which is of type 'string') is a valid key for that object. Of course we know that it will be, but TypeScript cannot.

We have to tell Typescript the shape of the object that we are trying to create.

Let's see the syntax of the 'reduce' function -

    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;

So, this function is a generic function with the type parameter 'U' representing the type of the accumulator (or previousValue). It takes a callback function and an initial value of type 'U', and it returns a value of type 'U'.

Since in our case we set the initialValue as '{}', TypeScript infers the type 'U' as '{}'.

But, we need to tell Typescript that 'U' is actually an object with string keys and values of the type of the items in the array.

So, we have to explicitly pass the type argument to the 'reduce' function like this -

    const obj = array.reduce<{ [key: string]: typeof array[number] }>((accum, item) => {
        accum[item.name] = item;
        return accum;
    }, {});

Here, we are passing the type argument '{ [key: string]: typeof array[number] }' to the 'reduce' function. This type represents an object with string keys and values of the same type as the items in the 'array'.

This means now, TypeScript knows that 'accum' is of type '{ [key: string]: { name: string } }', and hence it will not throw any error when we do 'accum[item.name] = item;'.

We could've also used a Type Assertion to achieve the same result like this -

    const obj = array.reduce((accum, item) => {
        accum[item.name] = item;
        return accum;
    }, {} as { [key: string]: typeof array[number] });

Here, we are asserting that the initial value '{}' is of type '{ [key: string]: typeof array[number] }'. This also tells TypeScript the shape of the accumulator object.

Finally, we could've also typed the accumulator parameter in the callback function like this -

    const obj = array.reduce((accum: { [key: string]: typeof array[number] }, item) => {
        accum[item.name] = item;
        return accum;
    }, {});

So, whatever you way you choose, the end result is that TypeScript now knows the shape of the accumulator object, and you won't get any errors.