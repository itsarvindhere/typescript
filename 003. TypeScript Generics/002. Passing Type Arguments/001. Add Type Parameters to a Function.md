Let's take an example of a function -

    const createSet = () => {
        return new Set();
    };

This function creates and returns a new 'Set' object. However, it doesn't specify what type of elements the 'Set' will hold.

This means, if we do -

    const stringSet = createSet();
    const numberSet = createSet();

Both 'stringSet' and 'numberSet' will be of type 'Set<unknown>', which is not ideal. We want 'stringSet' to be of type 'Set<string>' and 'numberSet' to be of type 'Set<number>'.

Now, if you have used 'Set' in TypeScript before, you would know that 'Set' is a generic type that takes a type parameter to specify the type of elements it holds. So, cannot we do the same with our function? That is, what if we can do -

    const stringSet = createSet<string>();
    const numberSet = createSet<number>();

Right now it shows an error saying -

    Expected 0 type arguments, but got 1

So, here TypeScript is telling us that our function 'createSet' is not defined to take any type arguments.

Well, we can add type parameters to our function to make it generic. Here's how we can do that - 

    const createSet = <T>() => {
        return new Set<T>();
    };

Here, we have added a type parameter 'T' to our function 'createSet'. Now, when we call 'createSet<string>()', TypeScript understands that 'T' is 'string', and thus it returns a 'Set<string>'. In this way, we can create sets of different types using the same function.

It is worth mentioning that we had to explicitly pass a type argument when calling the function because in this case, our function does not have any parameters from which TypeScript can infer the type argument. If our function had parameters, TypeScript could infer the type argument based on the arguments passed to the function.

So, if we had -

    const createSet = <T>(items: T[]) => {
        return new Set<T>(items);
    };

Here, we are passing an array of items of type 'T' to the function. Now, when we call the function like this -

    const stringSet = createSet(['a', 'b', 'c']);
    const numberSet = createSet([1, 2, 3]);

You will see that TypeScript can infer the type argument 'T' based on the type of the array passed to the function. Thus, 'stringSet' will be of type 'Set<string>' and 'numberSet' will be of type 'Set<number>'.

But our original function did not have any parameters, so we had to explicitly provide the type argument when calling the function. If we do not provide the type argument, TypeScript cannot infer it and thus it will result in 'unknown'.

# DEFAULT TYPE PARAMETERS

At this point, our 'createSet' function is a generic function that can create sets of any type.

But, there is till an issue.

We have to explicitly specify the type argument when calling the function. What if we forget to do that? For example -

    const unknownSet = createSet();

Maybe we want to create a set of 'string' type by default.

So, how do we tell TypeScript that if we did not provide a type argument, it should default to 'string'? Well, we can actually pass a default type parameter to our generic function like this -

    const createSet = <T = string>() => {
        return new Set<T>();
    };

Now, our 'unknownSet' will be of type 'Set<string>' since we did not provide any type argument, and thus it defaulted to 'string'.