Let's take an example that we had taken when we learned about Generics with Conditional types.

    const youSayGoodByeISayHello = (greeting: "Goodbye" | "Hello") => {
        return greeting === "Goodbye" ? "Hello" : "Goodbye";
    };

    const result = youSayGoodByeISayHello("Goodbye");
    const result2 = youSayGoodByeISayHello("Hello");

Here, the function 'youSayGoodByeISayHello' is a simple function that takes a string literal type as an argument and returns the opposite string literal type.

Now, right now, if you hover over the 'result' variable, you'll see that its type is inferred as '"Goodbye" | "Hello"'. Ideally, we would want the type of 'result' to be '"Hello"' and the type of 'result2' to be '"Goodbye"'.

We know that previously, we fixed this using a conditional type like this -

    type Opposite<T> = T extends "Goodbye" ? "Hello" : "Goodbye";

    const youSayGoodByeISayHello = <T extends string>(greeting: T): Opposite<T> => {
        return (greeting === "Goodbye" ? "Hello" : "Goodbye") as Opposite<T>;
    };

    const result = youSayGoodByeISayHello("Goodbye");
    const result2 = youSayGoodByeISayHello("Hello");

But, it was not very clean. We had to use a type assertion to tell TypeScript that the return type of the function is 'Opposite<T>'. This is where function overloads can help us.

We know that there can only be two valid inputs to the function, "Goodbye" and "Hello". So, we can define two overloads for the function like this -

    function youSayGoodByeISayHello(greeting: "Goodbye"): "Hello";
    function youSayGoodByeISayHello(greeting: "Hello"): "Goodbye";
    function youSayGoodByeISayHello(greeting: string): string {
        return greeting === "Goodbye" ? "Hello" : "Goodbye";
    }

    const result = youSayGoodByeISayHello("Goodbye");
    const result2 = youSayGoodByeISayHello("Hello");

Here, we simply define two overloads for the function, one for each valid input. The implementation of the function remains the same. Now, if you hover over the 'result' variable, you'll see that its type is inferred as '"Hello"' and the type of 'result2' is inferred as '"Goodbye"'. This is a much cleaner solution compared to using conditional types with type assertions.

# IMPORTANT THINGS TO NOTE WITH FUNCTION OVERLOADING

Now, there is an important thing to note with function overloading. Remember that if you define overloads for a function, you have to provide all the overloads before the implementation of the function.

To make it easier to understand, what if we had -

    function youSayGoodByeISayHello(greeting: "Goodbye"): "Hello";
    function youSayGoodByeISayHello(greeting: string): string {
        return greeting === "Goodbye" ? "Hello" : "Goodbye";
    }

Here, we have only defined one overload for the function, which is for the input "Goodbye".

Now, the IDE will start complaining for -

    const result2 = youSayGoodByeISayHello("Hello");

Here, we will get an error -

    Argument of type '"Hello"' is not assignable to parameter of type '"Goodbye"'.

The error also says -

    The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible.

Remember that when we define overloads for a function, the implementation signature is not visible outside the function. This means that the function can only be called with the types defined in the overloads. In this case, since we have only defined an overload for "Goodbye", we cannot call the function with "Hello".

This is a very important thing to remember when working with function overloads. Always make sure to define all the overloads for a function before the implementation of the function. That's because the actual implementation of the function is not visible outside the function, and the function can only be called with the types defined in the overloads.

Similarly, it is important to make sure that the overload signatures are compatible with the implementation signature. This means, we cannot do -

    function youSayGoodByeISayHello(greeting: number): "Hello"; // WRONG OVERLOAD
    function youSayGoodByeISayHello(greeting: "Hello"): "Goodbye";
    function youSayGoodByeISayHello(greeting: string): string {
        return greeting === "Goodbye" ? "Hello" : "Goodbye";
    }

Here notice that the first overload is not compatible with the implementation signature. The implementation signature expects a string as an argument, but the first overload expects a number. This will result in an error -

    This overload signature is not compatible with its implementation signature.

So, when working with function overloads, always make sure to define all the overloads for a function before the implementation of the function, and also make sure that the overload signatures are compatible with the implementation signature.

Finally, it is a good practice to have the return type of the implementation signature to be explicitly defined. This is because if you do not define the return type of the implementation signature, there can be type-safety issues. For example, if we had -

    function youSayGoodByeISayHello(greeting: "Goodbye"): "Hello";
    function youSayGoodByeISayHello(greeting: "Hello"): "Goodbye";
    function youSayGoodByeISayHello(greeting: string) {
        return "Some random string is returned";
    }

Here, notice how the implementation signature does not have an explicit return type. So, even though inside the implementation signature we return a different string, the function will still compile without any errors. This can lead to type-safety issues because the function is expected to return either "Hello" or "Goodbye", but it can return any string.

So, a better way to write the implementation signature would be -

    function youSayGoodByeISayHello(greeting: "Goodbye"): "Hello";
    function youSayGoodByeISayHello(greeting: "Hello"): "Goodbye";
    function youSayGoodByeISayHello(greeting: "Goodbye" | "Hello"): "Goodbye" | "Hello" {
        return "Some random string is returned";
    }

Now, TypeScript will give us an error for the implementation signature because the return type of the implementation signature is not compatible with the return type we have given for this implementation signature. This is a much safer way to write the implementation signature because it ensures that the function will only return the expected types.

So, sometimes, using Function overloads can be a much cleaner solution compared to using conditional types with type assertions. However, it is important to remember the rules of function overloading to avoid any type-safety issues.

Always make sure to define all the overloads for a function before the implementation of the function, and also make sure that the overload signatures are compatible with the implementation signature. Finally, it is a good practice to have the return type of the implementation signature to be explicitly defined to ensure type-safety.