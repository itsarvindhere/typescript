Let's say we have a function -

    function useData<T>(params: { fetchData: () => Promise<T>; initialData?: T}): {
        getData: () => T | undefined;
    } {
        let data = params.initialData;

        params.fetchData().then(d => data = d);

        return {
            getData: () => data
        };
    };

So, what is going on here?

We have a function 'useData' that takes an object with a 'fetchData' function and an optional 'initialData'. The 'fetchData' function returns a promise that resolves to a value of type 'T', and the 'initialData' is also of type 'T'.

It returns an object with a 'getData' function which returns either the data of type 'T' or 'undefined'.

Inside the function, we initialize a variable 'data' with the value of 'initialData'. Then we call 'fetchData' and when it resolves, we update 'data' with the fetched value.

So, if we call it -

    const numData = useData({
        fetchData: () => Promise.resolve(1),
    });
    const data = numData.getData();

Since 'initialData' is not provided, 'data' will have a type as 'number | undefined' which is fine.

But, what if we have -

    const numData2 = useData({
        fetchData: () => Promise.resolve(1),
        initialData: 2,
    });
    const data2 = numData2.getData();

Here, even though we provided an 'initialData' of type 'number', the type of 'data2' will still be 'number | undefined'.

The reason why this happens is because in our function, we have told TypeScript that 'initialData' may or may not be provided, so it has to account for both cases. Therefore, the type of 'data' is inferred as 'T | undefined', which in this case is 'number | undefined'.

We want to make sure that if a user passes an 'initialData', the type of 'data' should be just 'T' and not 'T | undefined'.

So, basically, we have different return types based on whether 'initialData' is provided or not. This is where function overloads come into play.

So, we can create two overloads for our function -

    function useData<T>(params: { fetchData: () => Promise<T>; initialData: T}): {
        getData: () => T;
    };
    function useData<T>(params: { fetchData: () => Promise<T> }): {
        getData: () => T | undefined;
    };

Here, the first overload is for when 'initialData' is provided, and it returns a type where 'getData' returns 'T'. The second overload is for when 'initialData' is not provided, and it returns a type where 'getData' returns 'T | undefined'.

And that's it. So, the final code will be -

    function useData<T>(params: { fetchData: () => Promise<T>, initialData: T}): {
        getData: () => T;
    }
    function useData<T>(params: { fetchData: () => Promise<T> }): {
        getData: () => T | undefined;
    }
    function useData<T>(params: { fetchData: () => Promise<T>; initialData?: T}): {
        getData: () => T | undefined;
    } {...}

So here, the function overloads make sense because we have different return types based on the presence of 'initialData'. If 'initialData' is provided, we can guarantee that 'getData' will return a value of type 'T'. If 'initialData' is not provided, we have to account for the possibility that 'data' might be 'undefined', hence the return type is 'T | undefined'.