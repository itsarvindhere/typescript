Let's see how we can use generics in function overloads.

Suppose, we have a function -

    function returnWhatIPassInExceptFor1(t: unknown): unknown {
        return t;
    }

This simple function has one job. It returns whatever we pass in. But, if we pass it the number 1, it will return something else (maybe a 2). For any other value, it will return the value itself.

So, we can call it like -

    const result = returnWhatIPassInExceptFor1(1);
    const a = returnWhatIPassInExceptFor1('a');
    const b = returnWhatIPassInExceptFor1('b');
    const c = returnWhatIPassInExceptFor1('c');

Right now, since we are using 'unknown' as the type for the parameter and return value, TypeScript doesn't know what type to expect. This means that we won't get any type safety or autocompletion when we use this function.

Well, one fix is to simply us a generic type parameter. We can define our function like this -

    function returnWhatIPassInExceptFor1<T>(t: T): T extends 1 ? 2 : T {
        return t as any;
    }

Here, we are using a generic type parameter 'T' to represent the type of the input parameter. The return type is a conditional type that checks if 'T' is 1. If it is, it returns 2; otherwise, it returns 'T'.

Remember that here, when we say we want to return '2', it just means that we want to return a value of type '2'. It doesn't necessarily mean that we will return the number 2. We can return any value as long as it is of type '2'. So, it is the type that we want to change if the input is 1, not the actual value.

Alright, so now, our function is more type-safe. When we call it, TypeScript will infer the type of 'T' based on the argument we pass in.

    const result = returnWhatIPassInExceptFor1(1); // result is of type 2
    const a = returnWhatIPassInExceptFor1('a'); // a is of type 'a'
    const b = returnWhatIPassInExceptFor1('b'); // b is of type 'b'
    const c = returnWhatIPassInExceptFor1('c'); // c is of type 'c'

But, here, we have to use 'any' because as we know, when we have a conditional type for the return type, TypeScript can't determine the return type correctly. So, we have to use 'any' to bypass the type checking. This is not ideal, but it's a limitation of TypeScript's type system.

Another way to fix this problem is to use Function overloads.

We know that there are basically two different ways to call this function such that we get different outputs.

    1. When we pass in the number 1, we want to get a return type as 2 back.
    2. When we pass in any other value, we want to get that value back.

For the first case, we can simply define an overload like this -

    function returnWhatIPassInExceptFor1(t: 1): 2;
    function returnWhatIPassInExceptFor1(t: unknown): unknown {
        return t as any;
    }

This will cover the first case. Now, when we call the function with the number 1, TypeScript will know that the return type is 2.

    const result = returnWhatIPassInExceptFor1(1); // result is of type 2

But, what about the other cases?

Of course it does not make sense to create an overload for every possible value that we can pass in. That would be a nightmare to maintain. We can pass literally any value to this function, so we can't create an overload for each of them.

One way can be to use 'any' but that would defeat the purpose of using TypeScript in the first place. We want to have type safety and autocompletion, so we don't want to use 'any'.

Well, in such cases, we can use a generic type parameter in the overload to cover all the other cases. We can define our overload like this -

    function returnWhatIPassInExceptFor1(t: 1): 2;
    function returnWhatIPassInExceptFor1<T>(t: T): T;
    function returnWhatIPassInExceptFor1(t: unknown): unknown {
        return t as any;
    }

So now, we have two overloads. The first one covers the case when we pass in the number 1, and the second one covers all the other cases.

You might be thinking that shouldn't we also make sure the implementation signature is typed properly instead of 'unknown'? Well, if you think about it, 'unknown' is pretty okay here because we are just returning whatever we pass in. We don't need to know the exact type of the input parameter in the implementation signature because we are not doing anything with it. We are just returning it as is. Another benefit of 'unknown' is that if we want to add some logic in the future that checks the type of the input parameter, we can do that without having to change the implementation signature.

And that's how we can use generics in function overloads to achieve type safety and autocompletion while still maintaining the flexibility of our function.