Let's look at a really common error that can occur when working with generics and object types in TypeScript.

    const obj = {
        a: 1,
        b: 2,
        c: 3
    } as const;

    type ObjKey = keyof typeof obj; // 'a' | 'b' | 'c'

    const getObjValue = <T extends ObjKey>(key: T = 'a') => {
        return obj[key];
    };

Here, we have a function 'getObjValue' that takes a generic type parameter 'T' which extends the keys of the 'obj'. The function has a default parameter value of 'a'.

    const one = getObjValue('a'); // type -> 1
    const oneByDefault = getObjValue(); // type -> 1 | 2 | 3
    const two = getObjValue('b'); // type -> 2
    const three = getObjValue('c'); // type -> 3

When we try to call this function without providing an argument, we  expect it to return the value of 'obj['a']', which is '1'.

But right now, we get an error where we are defaulting 'key' to 'a', which is of type 'T' -

    Type '"a"' is not assignable to type 'T'.
        '"a"' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint '"a" | "b" | "c"'.

And also, the type for 'oneByDefault' is '1 | 2 | 3' instead of just '1'.

So, what is this weird error? We know that 'a' is indeed one of the keys of 'obj', so why is TypeScript complaining about it?

Well, since this is generic function, it means we could also do -

    getObjValue<'b'>();

So here, we are explicitly saying that 'T' is 'b', but the default value for 'key' is still 'a'. This is why TypeScript is giving us an error, because it can't guarantee that 'a' will always be a valid key for any possible instantiation of 'T'.

If you think about it, there are now two different ways to call 'getObjValue' - one where we provide an argument, and one where we don't. In the first case, TypeScript can infer the type of 'T' based on the argument we provide.

If we do not provide any argument, we just want to return the value of 'a' by default, and we don't care about the type of 'T' in that case.

So, this is a good place to use function overloads to handle these two different cases separately.

We can define an overload for the case where we do not provide an argument like this -

    function getObjValue (): typeof obj['a'];

Since we want to return the value of 'a' by default, we can specify the return type as 'typeof obj['a']', which is '1'.

Then, we can define another overload for the case where we do provide an argument. In that case, we want to make sure that the argument is of type 'T' and that 'T' extends 'ObjKey' -

    function getObjValue <T extends ObjKey>(key: T): typeof obj[T];

Here, we are saying that if we do provide an argument, it must be of type 'T' which extends 'ObjKey', and the return type will be 'typeof obj[T]', which will be the value corresponding to the key we provided.

And finally, we also want to make sure our implementation of the function matches these overloads -

    function getObjValue(key: ObjKey = 'a') {
        return obj[key];
    };

Here, we removed the generic type parameter from the implementation, and we just specify that 'key' is of type 'ObjKey' with a default value of 'a'. This way, we can satisfy both overloads - when we call 'getObjValue()' without an argument, it will return the value of 'a', and when we call it with an argument, it will return the corresponding value based on the key provided.

So, the final code with the overloads will look like this -

    function getObjValue (): typeof obj['a'];
    function getObjValue <T extends ObjKey>(key: T): typeof obj[T];
    function getObjValue(key: ObjKey = 'a') {
        return obj[key];
    };

Well, the next time you encounter the 'Instantiated with Subtype' error, try to think about whether there are different ways to call the function that might require different type handling, and consider using function overloads to address those cases separately.