In one of the previous section, we saw how sometimes, the Function Overloads can be much cleaner than using Conditional Types. Now, let's see how they compare to Union Types.

Let's say we have -

    function runGenerator(generator: unknown) {
        if (typeof generator === 'function') {
            return generator();
        };
        return generator.run();
    }

    const result1 = runGenerator({
        run: () => 'Hello',
    });

    const result2 = runGenerator(() => 'Hello');

Here, we have a function 'runGenerator' that can accept either a function or an object with a 'run' method. The implementation checks the type of the input and calls it accordingly.

Now, right now, our function is using 'unknown' as the type for the 'generator' parameter, which is not ideal.

# USING A UNION TYPE

We know that whatever we pass to this function has one of these two shapes -

    1. A function that returns a string.
    2. An object that has a 'run' method which returns a string.

So, why not just use a Union Type to represent this?

    function runGenerator(generator: (() => string) | { run: () => string }) {
        if (typeof generator === 'function') {
            return generator();
        };
        return generator.run();
    }

Here, we have replaced 'unknown' with a Union Type that represents the two possible shapes of the input. This is much better than using 'unknown',

# USING FUNCTION OVERLOADS

But, if you think about it, we could've solved this issue with Function Overloading as well because we know that there are two different ways that the function can be called. So, we can define two overloads for the 'runGenerator' function -

    function runGenerator(generator: () => string): string;
    function runGenerator(generator: { run: () => string }): string;
    function runGenerator(generator: (() => string) | { run: () => string }) {
        if (typeof generator === 'function') {
            return generator();
        };
        return generator.run();
    }

Notice that here, we still have to type the 'generator' parameter in the implementation signature as a Union Type, because it can be either of the two shapes.

But, if you think about it, even if remove the overloaded signatures, our function will still work just as we want it to work.

    function runGenerator(generator: (() => string) | { run: () => string }) {
        if (typeof generator === 'function') {
            return generator();
        };
        return generator.run();
    }

This is the same code as we wrote when we were using Union Types. So, in this case, using Function Overloads doesn't really add any value, and it just adds more code to our function.

One of the reasons why we do not really need Function Overloads here is because if you notice, there is no change in the return type based on the input type. In both cases, the return type is 'string'.

Let's say there was a different return type in case the 'generator' was an object. So, if it was an object, it would return another object which has a 'result' property which is a string.

In that case, it makes more sense to use Function Overloads because then we can have different return types based on the input type.

    function runGenerator(generator: () => string): string;
    function runGenerator(generator: { run: () => string }): { result: string };
    function runGenerator(generator: (() => string) | { run: () => string }): string | { result: string } {
        if (typeof generator === 'function') {
            return generator();
        };
        return { result: generator.run() };
    }

In this case, if we use a Union Type -

    function runGenerator(generator: (() => string) | { run: () => string }): string | { result: string } {
        if (typeof generator === 'function') {
            return generator();
        };
        return { result: generator.run() };
    }

    const result1 = runGenerator({
        run: () => 'Hello',
    });

    const result2 = runGenerator(() => 'Hello');

TypeScript cannot really infer the return type of 'result1' and 'result2' correctly because it doesn't know which shape of the input we are passing to the function. It will infer the return type as 'string | { result: string }', which is not ideal.

So, this means the function overloads are more useful when we have different return types based on the input type. If the return type is the same for both cases, then using Union Types is just as good and is much cleaner.