Typescript allows us to specify the types for the functions as well.

Let's say we have this function code - 

    type User = {
        id: string;
        name: string;
    }

    const modifyUser = (user: User[], id: string, makeChange) => {
        return user.map(u => {
            if (u.id === id) {
                return makeChange(u);
            }
            return u;
        })
    }

    let users: User[] = [
        { id: "1", name: "John Doe" },
        { id: "2", name: "Jane Smith" },
    ];

    modifyUser(users, "1", (user) => {
        return { ...user, name: "Johnathan Doe" };
    });

    modifyUser(users, "2", (user) => {
        return { ...user, name: "Jane Doe" };
    });

Here, we have a function 'modifyUser' that accepts three arguments. One is an array of 'User' type, the second is a string 'id', and the third is a function 'makeChange' that defines how to modify a user.

Now, if you write this code in a typescript file, you will see a compile-time error for the 'makeChange' because we have not specified its type which means Typescript is implicitly inferring it as 'any'. As we discussed in the last section, using 'any' is not a good practice in Typescript and it should always be the last resort.

In our case, we know that 'makeChange' accepts a 'User' type as an argument and returns a 'User' type as well. So if we know it, there is no need to use 'any' here.

So, let's tell TypeScript the exact type of the 'makeChange' function.

We can now write out 'makeChange' argument inside 'modifyUser' like this -

    const modifyUser = (user: User[], id: string, makeChange: (user: User) => User) => {
        // CODE
    }

So, this is what we did -

    makeChange: (user: User) => User

Here, we are telling TypeScript that 'makeChange' is a function that accepts one argument which is of type 'User' and it returns a 'User' type as well.

The benefit now is that TypeScript can catch any errors related to the 'makeChange' function at compile time, rather than at runtime. For example, if we try to pass a function that doesn't match the expected signature, TypeScript will give us an error.

    modifyUser(users, "1", (user) => {
        return 'Hello World';
    });

The above code will cause a compile-time error because the return type of the function does not match the expected return type of 'User'.

And just like before, we are extract the type into a separate variable and use that wherever we want it like this -

    type MakeChangeFunction = (user: User) => User;

    const modifyUser = (user: User[], id: string, makeChange: MakeChangeFunction) => {
        // CODE
    }

# TYPING EVENT LISTENERS

In web development, you will come across event listeners that respond to user interactions. These listeners often have specific types for the event objects they receive.

Let's say we have a function that adds a 'click' listener the document -

    const addClickEventListener = (listener) => {
        document.addEventListener('click', listener);
    }

So, we can call it like this -

    addClickEventListener(() => {
        console.log("Clicked");
    });

Just like before, we will get an error in our ide because we have not specified the type of 'listener' which is implicitly 'any'. This means, we can even call it like this and there won't be any error in he ide -

    addClickEventListener('Hello World');

But, this is wrong because a 'listener' is expected to be a function, not some other type like a string or number.

Here, the listener is a function but it does not return anything. You might wonder what to tell TypeScript if a function does not return anything at all. Well, there is a 'void' type that we can use here.

    const addClickEventListener = (listener: () => void) => {
        document.addEventListener('click', listener);
    }