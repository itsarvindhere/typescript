Let's talk about 'Sets' and 'Maps' in TypeScript.

# SET

The 'Set' object lets us store unique values in it and those values can be of any type, including primitive types and object references.

A value in a set must be unique, meaning that the same value cannot occur more than once. If you try to add a duplicate value to a set, it will simply be ignored.

Suppose, we have this code in TypeScript -

    const userIds = new Set();

    userIds.add(1);
    userIds.add(2);
    userIds.add(3);

So, we have a set of user IDs. We know that userId will always be a number. But right now, if we do this -

    userIds.add('Hello There');

Or even this -

    userIds.add({id: 10, name: 'Max'})

Or even this -

    userIds.add(() => 'Hello World');

All of these are valid as per TypeScript because we have not specified any type for the set which means it can accept any type of value that we provide it.

## unknown

If you hover over the 'userIds' variable, you will see its type being shown like this -

    const userIds: Set<unknown>

So, the 'userIds' is a 'Set' of 'unknown'. What is this 'unknown'? Isn't it supposed to be 'any'?

Well, 'unknown' is like a type-safe counterpart of 'any'. It means that you can assign any value to an 'unknown' type, but you cannot perform any operations on it until you assert its type.

This means, we cannot do this directly -

    userIds.forEach(id => {
        id++;
    })

The ide will show an error saying -

    'id' is of type 'unknown'.

That's the benefit of 'unknown'. It will force us to first verify the type before performing any operation. So, weh have to write -

    userIds.forEach(id => {
        if (typeof id === 'number') {
            id++;
        }
    })

Coming back to our set, we know that this should be a set of 'number' types. So, we can explicitly tell that to TypeScript using -

    const userIds = new Set<number>();

You might recall this <> notation from our earlier discussion on Array type.

Once we make the above change to our code, all these are now invalid in TypeScript -

    
    userIds.add('Hello There');
    userIds.add({ id: 10, name: 'Arvind' })
    userIds.add(() => 'Hello World');

Another way is to set the type on 'userIds' like this -

    const userIds: Set<number> = new Set();

Whatever way you choose to set the type, the benefit is that you get type safety and better tooling support in your IDE.

# MAP

Speaking of maps, they are objects that hold key-value pairs and they remember the insertion order of the keys. While we can use plain objects to hold key-value pairs, the 'keys' in plain objects should always be either string or symbol. 

But, in maps, the key can be any value - primitive or objects.

Let's say we have this code -

    const userMap = new Map();
    userMap.set(1, {
        name: 'Max',
        age: 30
    });

    userMap.set(2, {
        name: 'John',
        age: 28
    });

If you hover over 'userMap', you will see its type being shown like this -

    const userMap: Map<any, any>

This means, 'userMap' is a map that can accept 'any' type of key and 'any' type of value. It means we can do something like this and it will be a valid TypeScript code -

    
    userMap.set('Hello', () => console.log("Hello World"));

In our case, that's not what we want. We want a key of type 'number' and a value of type '{
    name: string;
    age: number;
}'.

So, let's tell that to TypeScript -

    const userMap = new Map<number, { name: string; age: number }>();

We can also write this -

    const userMap: Map<number, { name: string; age: number }> = new Map();

We can extract the type for user as well -

    type User = { name: string; age: number };
    const userMap = new Map<number, User>();

And now, we have a map that should only accept keys of type 'number' and values of type 'User'.