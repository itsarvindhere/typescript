Let's say we have this piece of code - 

    const add = (a: boolean, b: boolean) => {
        return a + b;
    }

Here, the function is trying to add two boolean values. However, in JavaScript (and TypeScript), the '+' operator is not defined for boolean types. This will result in a compilation error.

So, how can we fix it? Well, if you have no idea of TypeScript, you might think of simply removing the type like this -

    const add = (a, b) => {
        return a + b;
    }

While this might work, it is not a good practice. By removing the types, we lose the benefits of TypeScript's type checking. If you do the above, then it means 'add' can still accept any type, whether it is a boolean or even an object or array.

A better approach would be to change the function to accept numbers instead of booleans:

    const add = (a: number, b: number) => {
        return a + b;
    }

And now, the function can only accept numbers, and trying to pass in booleans or other types will result in a compilation error. This way, we maintain the benefits of TypeScript's type checking while also ensuring that our function behaves as expected.

# ANNOTATING EMPTY PARAMETERS

Let's take another example - 

    const concatTwoStrings = (a,b) => {
        return [a, b].join(" ");
    }

This time, let's have a 'tsConfig' file generated using 'tsc --init' command -

    {
        "compilerOptions": {
            "target": "es2016",
            "module": "commonjs",
            "forceConsistentCasingInFileNames": true,
            "strict": true,
            "skipLibCheck": true
        }
    }

There is one option in tsConfig which is 'false' by default named 'noImplicitAny'. If we turn it on -

    "noImplicitAny": true

You will see that we start seeing an error related to the parameters 'a' and 'b' in the 'concatTwoStrings' function. This is because TypeScript is unable to infer their types, and with 'noImplicitAny' set to true, it raises an error.

The 'noImplicitAny' option is a powerful feature in TypeScript that helps catch potential errors early in the development process by ensuring that all variables have a defined type. This encourages developers to be more explicit about their code and can lead to better overall code quality.

It is important to note that if we do not give a type to the parameters 'a' and 'b' in the 'concatTwoStrings' function, TypeScript will infer their types as 'any'. This means that we could potentially pass in values of any type, which could lead to runtime errors.

Now, you can fix this error by explicitly setting the type as 'any' once again like this -

    const concatTwoStrings = (a: any, b: any) => {
        return [a, b].join(" ");
    }

While the error will go away, this approach is not recommended. By using 'any', we are essentially opting out of type checking for these parameters, which defeats the purpose of using TypeScript in the first place. A better solution would be to provide more specific types for the parameters, like this -

    const concatTwoStrings = (a: string, b: string) => {
        return [a, b].join(" ");
    }

Now, the function can only accept strings, and trying to pass in values of other types will result in a compilation error. This way, we maintain the benefits of TypeScript's type checking while also ensuring that our function behaves as expected.

The 'noImplicitAny' is something that you should always keep enabled in your TypeScript projects. It helps catch potential errors early in the development process and encourages developers to be more explicit about their code.