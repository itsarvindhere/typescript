When we define an Array type, TypeScript has no idea exactly how many items are there in the array. And this can be a problem when we want to represent a structure that has a fixed number of elements.

For example, let's say we have this function -

    const setRange = (range: number[]) => {
        const x = range[0];
        const y = range[1];

        // Do something with x and y
    }

Let's say that 'range' should always have exactly two elements: a start and an end value.

The issue at this point is that we can call this function like this -

    setRange([1]);

And there will be no compile-time error because we told TypeScript that 'range' is an array of numbers, and arrays can have any number of elements.

Similarly, we can also call this function like this -

    setRange([1, 2, 3, 4, 5]);

So, here we are providing more than two elements, which should also result in a compile-time error. But it won't happen here because this is a valid code according to TypeScript as [1,2,3,4,5] is an array of numbers.

# TUPLE

And this is where 'Tuples' come in.

A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.

In our case, instead of saying that 'range' will be an array of numbers, we can say that it will be a tuple with exactly two numbers - 

    const setRange = (range: [number ,number]) => {
        const x = range[0];
        const y = range[1];

        // Do something with x and y
    }

The benefit now is that we have to call 'setRange' with an array that has exactly two elements, nothing less and nothing more.

So, now, these will result in compile-time errors:

    setRange([1]);  
    setRange([1, 2, 3]);

We can also have optional properties in the tuples and we use '?' to mark them as optional.

For example:

    const setRange = (range: [number, number?]) => {
        const x = range[0];
        const y = range[1];

        // Do something with x and y
    }

Now, we can call 'setRange' with just one element:

    setRange([1]);

And it will work just fine. This is because the second element is optional, so we can call the function with just the first element.

Note that since second element is optional, it means if we do 'range.length' it can either be 1 or 2. It is not guaranteed to be 2 anymore since we can call the function with just one element.

Finally, we can have 'readonly' tuple types as well which means they are immutable and cannot be changed after creation.

    const setRange = (range: readonly [number, number]) => {
        const x = range[0];
        const y = range[1];

        range[0] = 10; // Cannot assign to '0' because it is a read-only property

        // Do something with x and y
    }
