# PRIMITIVES

There are some basic types that we get in TypeScript out of the box such as -

    1. string
    2. number
    3. boolean
    4. symbol
    5. bigint
    6. null
    7. undefined

All these come under Primitive types. 

--------------------------- 

Fun fact - We know about 'typeof' operator, right? If you use the 'typeof' operator on the the above primitive type (except null), it will return the type as a string. For example:

    typeof "hello"; // "string"
    typeof 42;      // "number"
    typeof true;    // "boolean"
    typeof Symbol(); // "symbol"
    typeof 123n;    // "bigint"
    typeof undefined; // "undefined"

But, when you use 'typeof' on null, it will return "object":

    typeof null; // "object"

The reason could be that conceptually, 'undefined' indicates the absence of a value, while 'null' indicates the absence of an object.

--------------------------- 

You might be hearing about 'bigint' and 'symbol' for the first time. Here are brief explanations -

## bigint
As the name suggests, 'bigint' is basically used for very large numbers that are beyond the safe integer limit for JavaScript's number type (which is 2^53 - 1). You can create a bigint by appending 'n' to the end of an integer literal, like this:

    let a: bigint = 123n;

You can also use the 'BigInt' constructor to create a bigint:

    let b: bigint = BigInt(123);

This allows you to work with arbitrarily large integers without losing precision.

## symbol

You might also be wondering about what a 'symbol' is. This is also a data type that was introduced in ES6 and it basically represents a unique identifier that is immutable. We can use it for things like unique keys in objects and even to hide the internal properties so that they are not accessible in things like 'for in' loops or Object.keys method.

For example, we can define a symbol using the Symbol() function:

    const mySymbol = Symbol('description');

This creates a new symbol with an optional description. Each time you call Symbol(), it returns a unique symbol, even if the description is the same.

This means - 

        const mySymbol = Symbol('description');
        const anotherSymbol = Symbol('description');

        console.log(mySymbol === anotherSymbol); // false

Let's say we want to use a symbol as a unique key in an object:

   const id = Symbol();

Now, we can use it like -

    let user = {
        name: "Arvind",
        [id]: 12345 // Symbol used as key
    };

And to access it, instead of using user.id, we have to write -

    user[id]

As mentioned above, we cannot access the 'id' using 'Object.keys' -

    console.log(Object.keys(user)); // ["name"]

# OBJECTS

You must've read that in JavaScript, everything is an object. Well, in TypeScript, it's no different.

Objects are a collection of key-value pairs. The keys are either strings or symbols. If other types are used to define keys, they will be implicitly converted to strings.

Here's a simple example of an object in TypeScript:

    let person = {
        name: "Arvind",
        age: 30,
        isEmployed: true
    };

In this example, 'person' is an object with three properties: 'name', 'age', and 'isEmployed'. Each property has a specific type associated with it.

Let's say we have a concatName method that takes an object as input -

    function concatName(obj): string {
        return `${obj.firstName} ${obj.lastName}`;
    }

And we can use it like this -

    let user = {
        firstName: "Arvind",
        lastName: "Rana"
    };

    console.log(concatName(user)); // "Arvind Rana"

Well, you will see an error in the ide for the 'obj' parameter because remember that we have enabled the 'noImplicitAny' option in our tsconfig.json file. This means that we need to explicitly define the types for our function parameters. But, how do we type an object in TypeScript?

Well, for that, we use curly braces and inside that we define the properties and their types. 

Here's how we can do it for our concatName function:

    function concatName(obj: { firstName: string; lastName: string }): string {
        return `${obj.firstName} ${obj.lastName}`;
    }

Now, if we try to call this function with an object that doesn't match the expected shape, TypeScript will give us an error.

What if we want the 'lastName' to be optional? Well, we can do that like this -

    function concatName(obj: { firstName: string; lastName?: string }): string {
        return `${obj.firstName} ${obj.lastName}`;
    }

Note the question mark (?) after 'lastName'. This indicates that the property is optional. If it's not provided, TypeScript won't throw an error.

The issue, however, is that since 'lastName' is optional, if it is not provided, the value will be 'undefined'. This means we need to handle that case in our function:

    function concatName(obj: { firstName: string; lastName?: string }): string {
        return `${obj.firstName} ${obj.lastName}`;
    }

Let's say if the 'lastName' is not provided, we should return only the 'firstName':

    function concatName(obj: { firstName: string; lastName?: string }): string {
        if (!obj.lastName) {
            return `${obj.firstName}`;
        }
        return `${obj.firstName} ${obj.lastName}`;
    }

Now, if we call this function without the 'lastName', it will still work:

    console.log(concatName({ firstName: "Arvind" })); // "Arvind "

