One of the very common places where we will be dealing with 'unknown' is in the 'catch' block of a try-catch. 

Let's say we have this code -

    const fn = () => {
        if (Math.random() > 0.5) {
            throw new Error('Something went wrong');
        }

        return 'all good';
    };

    try {
        fn();
    } catch (error) {
        // Some code to handle the error
    }

So, we have a function 'fn' that randomly throws an error. We are calling this function inside a try-catch block to handle any potential errors.

If you hover over the 'error' argument, it has a type as 'unknown'. And this is the default behavior in TypeScript in this case. This means that you cannot directly access any properties or methods on 'error' without first asserting its type.

For example, if you want to log the error message we cannot just write -

    console.log(error.message);

Instead, we have to first ensure that 'error' object has a property named 'message' in it.

This is a good practice because it forces you to handle the error in a type-safe manner.

First way would be to do something like this -

    if ('message' in error) {
        console.log(error.message);
    }

This will still show an error saying -

    'error' is of type 'unknown'

Remember that we cannot do any operations on 'error' unless we have narrowed it down to a more specific type.

Maybe let's narrow it down to an object -

    if (typeof error === 'object' && 'message' in error) {
        console.log(error.message);
    }

Well, now we get another error in the ide - 

    'error' is possibly 'null'

This is because typeof 'null' is also 'object'. So, if 'error' is null, then this will throw a runtime error because we are trying to access a property of null which cannot happen.

To fix this, we can add an additional check to ensure that 'error' is not null before trying to access its properties.

    if (typeof error === 'object' && error && 'message' in error) {
        console.log(error.message);
    }

Now, we have safely narrowed down the type of 'error' and can access its properties without any issues.

Is there a better way to do this?

Well, there is! It is using the 'instanceOf' operator. This is an operator in JavaScript that checks whether a value is an 'instance' of another value or not. In our case, we can simply check if 'error' is an instance of the 'Error' class. If it is, then we know that it will be an object and will definitely have a property named 'message'.

    if (error instanceof Error) {
        console.log(error.message);
    }

And that's it!

Remember that this only works if we throw an error using the 'new Error' syntax. If we throw a string or some other type, then 'instanceof Error' will return false.

    throw 'Some error';

So, it is a good practice to do something like this in the catch block -

    if (error instanceof Error) {
        console.log(error.message);
    } else {
        throw error;
    }

So, in case the error thrown is not an instance of Error, instead of swallowing the error, we re-throw it so that it can be handled further up the call stack.