To understand literal types in TypeScript, let's take an example. Let's say we have this function - 

    function move(direction: string, distance: number) {
        // Some logic based on direction and distance
    }

Let's say that the 'direction' can be any one of these four values - 'up', 'down', 'left', 'right'.

Well, right now, our function is going to work fine if we call it like -

    move('up', 10);
    move('down', 5);
    move('left', 3);
    move('right', 8);

But, remember that 'direction' is a string which means apart from these four values, we could technically pass in any string. This could lead to potential bugs if we accidentally call the function with an invalid direction.

What if we call it with -

    move('forward', 10);

And this is a kind of situation where we can use Literal Types in Typescript.

Since we know that 'direction' will always be one of these four values - 

    'up', 'down', 'left', 'right'

We can use Literal Types to enforce this in our function definition.

We can say -

    function move(direction: 'up' | 'down' | 'left' | 'right', distance: number) {
        // Some logic based on direction and distance
    }

To make it even more clear - 

    type Direction = 'up' | 'down' | 'left' | 'right';

    function move(direction: Direction, distance: number) {
        // Some logic based on direction and distance
    }

And now, we know that 'direction' is of type Direction, which can only be one of the four specified string literals.

Fun fact - If you define a variable in TypeScript using var or let like this -

    let dir = 'up';
    or
    var dir = 'down';

If you hover over 'dir' variable in your IDE, you will probably see - 

    let dir: string
    or
    var dir: string

This means, TypeScript infers the type of 'dir' as string, which is the most general type.

But, if we create a 'const' like this -

    const dir = 'up';

And hover over 'dir', we will see -

    const dir: "up"

So, in case of a 'const', TypeScript infers the most specific type possible, which is the literal type "up" in this case.

As we saw in our earlier example, when we combine literal types to create Union types, then they become even more powerful. So, for functions that only accept a certain set of known values, we can combine all those known values into a Union type, just like how we did with the direction in the above example.

Moreover, it is not just the strings that can be used as literal types. We can also use numbers and booleans as literal types in TypeScript.

For example, we can define a literal type for a specific number like this -

    type OneToFive = 1 | 2 | 3 | 4 | 5;

And then use this literal type in a function definition -

    function printNumber(num: OneToFive) {
        console.log(num);
    }

Now, the 'num' parameter can only accept one of the specified numbers, making our function calls safer and more predictable.

Similarly, we can define a literal type for a boolean value -

    type YesOrNo = true | false;

And use it in a function definition -

    function isTrue(value: YesOrNo) {
        // Some logic based on the boolean value
    }

In fact, the type 'boolean' is an alias for the union true | false.

This way, we can leverage literal types not just for strings, but for other types as well, enhancing the type safety and predictability of our code.

Another benefit of Literal types and combining them is that we get a nice autocomplete experience in our IDEs. When we use literal types, the IDE can provide better suggestions and help us avoid mistakes by only showing the valid options.
