So, we already saw Union Types and Literal Types, and how we can combine Literal types to create new types.

Now, let's go one step further. What about combining Union Types?

Let's say we have this piece of code -

    type HttpCode = "400" | "401" | "404" | "500" | "200" | "201" | "204";

    const handleErrorCase(code: string) => {
        // Some code to handle HTTP errors
    }

    const handleSuccessCase(code: string) => {
        // Some code to handle HTTP success
    }

So, we have a union type named 'HttpCode' which is a union of different string literals. Then, we have two methods, both of which accept an Http code as an argument and do something.

Right now, the 'code' argument is typed as 'string' meaning it can accept any string. This can cause issues. So, let's change the type of the 'code' argument in both methods to 'HttpCode' instead of 'string' because we know that 'code' can only be one of the specified HTTP status codes.

    const handleErrorCase = (code: HttpCode) => {
        // Some code to handle HTTP errors
    }

    const handleSuccessCase = (code: HttpCode) => {
        // Some code to handle HTTP success
    }

While it is better now, there is one more problem. We know that 'HttpCode' contains both success and error codes. So, even though our 'handleSuccessCase' function expects a status code for a success response, it can still accept error codes as well -

    handleSuccessCase("404"); // No Error because "404" is a valid HttpCode
    handleErrorCase("200"); // No Error because "200" is a valid HttpCode

This is not ideal.

What if we can pass only success codes in the handleSuccessCase function and only error codes in the handleErrorCase function?

Let's create two different types for success and error codes:

    type SuccessHttpCode = "200" | "201" | "204";
    type ErrorHttpCode = "400" | "401" | "404" | "500";

Now, we can update our functions to use these new types:

    const handleErrorCase = (code: ErrorHttpCode) => {
        // Some code to handle HTTP errors
    }

    const handleSuccessCase = (code: SuccessHttpCode) => {
        // Some code to handle HTTP success
    }

With this setup, the TypeScript compiler will enforce that only the appropriate status codes can be passed to each function, making our code safer and more predictable.

Maybe there is a function that can accept both success and error codes. We can create a new type that combines both:

    type HttpCode = SuccessHttpCode | ErrorHttpCode;

Now, we can create a function that accepts any HTTP code:

    const handleHttpCode = (code: HttpCode) => {
        // Some code to handle both HTTP success and error
    }

So here, we have combined two union types into one, allowing us to create more flexible and reusable code.

# THERE IS A LIMIT TO HOW BIG A UNION TYPE CAN GET

Well, there is actually a limit to how many members a union type can have.

For example, if we have a type like this -

    type Alphabet = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";

And we create a type -

    type tooBigString: `${Alphabet}${Alphabet}${Alphabet}${Alphabet}`

Don't be confused with the above line as here we are just saying that we want to create a string that is made up of four Alphabet types concatenated together.

This is basically saying that each of the four characters can be any one of the 26 letters of the alphabet.

Basically, it means there are 26^4 (or 456976) possible combinations for this type. And since there are so many possible combinations, TypeScript simply throws an error in the ide saying -

    Expression produces a union type that is too complex to represent.

Typescript cannot represent union types with more than almost 100,000 members. In our case, this number is 456976. So, sometimes, it is better to simply write -

    type tooBigString = string;

# HOW TYPESCRIPT RESOLVES LITERAL TYPES INTO WIDER TYPES

We already saw that if we have something like -

    type Test = "small" | "medium" | "large";

Then, TypeScript knows that the variable of type 'Test' can only be one of the three specified string literals.

But, what if we write this -

    type Test = "small" | "medium" | "large" | string;

Well, now, if you hover over 'Test' in the IDE, you will see it is shown as -

    type test = string

This means, as soon as we combine the literal types with their wider type (in this case, 'string'), TypeScript resolves the entire union type to the wider type.

And so, we lose all the auto-completion and type-checking benefits that come with using specific string literals.