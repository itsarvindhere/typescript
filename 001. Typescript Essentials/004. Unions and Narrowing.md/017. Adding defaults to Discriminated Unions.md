Let's come back to the square and circle example that we had -

    type Circle = {
        kind: 'circle';
        radius: number;
    }

    type Square = {
        kind: 'square';
        sideLength: number;
    }

    type Shape = Circle | Square;

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            return Math.PI * shape.radius * shape.radius;
        } else if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        }
    }

What if we call this function like this -

    const result = calculateArea({ radius: 5 });

Of course it will throw an error right now because the function is expecting a 'Shape' type. The 'Shape' type is a union of two types and both those types have a common 'kind' property. Since we are not passing a 'kind' property, TypeScript cannot determine which specific shape we are dealing with. So, it shows an error saying -

    Argument of type '{ radius: number; }' is not assignable to parameter of type 'Shape'.
        Property 'kind' is missing in type '{ radius: number; }' but required in type 'Circle'.

Let's say that if we do not provide a 'kind' property to the passed object, we want it to be treated as a 'circle'. So, how do we provide a default value for 'kind'?

Well, one way is to create a new type for the default behavior where 'kind' is optional ? -

    type Default = {
        kind?: 'circle';
        radius: number;
    }

Well, now, we can update the 'Shape' type -

    type Shape = Circle | Square | Default;

So, now, our calculateArea function can accept an object which is either of type 'Circle' which means it has a 'kind' property for sure and also a 'radius', or it is of type 'Square', which means it has a 'kind' property for sure and also a 'sideLength', or it is of type 'Default' which means it may or may not have a 'kind' property but must have a 'radius'.

So, our function now becomes -

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        } else { // If it is not a square, it will always be a circle
            return Math.PI * shape.radius * shape.radius;
        }
    }

But, there is no need to have a separate type just to handle the case where 'kind' can be optional and it still needs to be treated as a circle. We can simply update our 'Circle' type like this -

    type Circle = {
        kind?: 'circle';
        radius: number;
    }

And now, our calculateArea function can accept an object which is either of type 'Circle' which means it may or may not have a 'kind' property but it will definitely have a 'radius', or it is of type 'Square', which means it has a 'kind' property for sure and also a 'sideLength'.

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        } else {
            return Math.PI * shape.radius * shape.radius;
        }
    }

Note how we swapped the order in which we had written our if statements initially. We were previously having -

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            return Math.PI * shape.radius * shape.radius;
        } else {
            return shape.sideLength * shape.sideLength;
        }
    }

But right now, this will show an error for 'sideLength'. That's because after we made 'kind' as optional, it can now have three possible values - "circle" | "square" | undefined.

Since we are only checking for 'circle' in the first 'if' block, it means the else block not only handles the kind as 'square', but it also handles the case when 'kind' is simply not provided, meaning when it is undefined.

So, we can simply reverse the order of our if statements to check for 'square' first and then 'circle'. This way, we can ensure that if 'kind' is not provided, it will be treated as a 'circle' by default.

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        } else {
            return Math.PI * shape.radius * shape.radius;
        }
    }

It is important to note that you should only have one optional 'kind' property in your union types. Having multiple optional properties can lead to ambiguity and make it difficult for TypeScript to infer the correct type.

For example, if we also make the 'kind' property of the 'Square' type optional, we could end up with a situation where TypeScript cannot determine whether a given shape is a 'Circle' or a 'Square' just by looking at the properties it has.

    type Circle = {
        kind?: 'circle';
        radius: number;
    }

    type Square = {
        kind?: 'square';
        sideLength: number;
    }

    type Shape = Circle | Square;

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        } else {
            return Math.PI * shape.radius * shape.radius;
        }
    }

In this case, it will show an error saying -

    Property 'radius' does not exist on type 'Shape'.
        Property 'radius' does not exist on type 'Square'.

This is because TypeScript has no way to know what the shape really is if the 'kind' is not provided because for both 'Square' and 'Circle', 'kind' property is optional. So, to fix this, we can make only the 'kind' property of the 'Circle' type required.

    type Circle = {
        kind?: 'circle';
        radius: number;
    }

    type Square = {
        kind: 'square';
        sideLength: number;
    }
