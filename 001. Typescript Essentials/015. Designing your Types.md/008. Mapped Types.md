In the last section, we learned about the 'Template Literal Types' in TypeScript, which allow us to create new string literal types by combining existing ones. Now, let's explore another powerful feature of TypeScript - 'Mapped Types.'

Let's say we have an interface -

    interface Attributes {
        firstName: string;
        lastName: string;
        age: number;
    }

We want to create another type from this which is something like this -

    type AttributeGetters = {
        firstName: () => string;
        lastName: () => string;
        age: () => number;
    }

So, here we have created a new type 'AttributeGetters' where each property from the 'Attributes' interface is transformed into a function that returns the corresponding type.

So, how do we achieve this in TypeScript? Of course one way is to manually define the 'AttributeGetters' type as shown above. But this approach is not scalable, especially when dealing with larger interfaces.

What if in future we add more properties to the 'Attributes' interface? We would have to remember to update the 'AttributeGetters' type as well. This is where Mapped Types come into play.

Mapped Types allow us to create new types by transforming existing ones in a more dynamic way.

You must've used the 'map' function in JavaScript to transform arrays. Mapped Types work similarly but for types.

The official documentation says -

    Mapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:

Remember the 'index signatures' we discussed earlier? They allow us to define types for properties that are not known at the time of writing the code. Index signatures use the syntax -

    {
        [key: string]: any;
    }

The mapped type syntax is similar.

A mapped type is a generic type which uses a union of 'PropertyKeys' (frequently created via a keyof) to iterate through keys to create a type:

In our case as well, we want to take each key from the 'Attributes' interface and transform it into a function that returns the corresponding type.

Our 'AttributeGetters' will be like this -

    type AttributeGetters = {
        firstName: () => string;
        lastName: () => string;
        age: () => number;
    }

Note on the left side of the colon, we have all the keys from the 'Attributes' interface, and on the right side, we have the transformed type.

How do we get all the keys from the 'Attributes' interface? We can use the 'keyof' operator.

So, on the left, we can say -

    {
        [Key in keyof Attributes] : ?
    }
    

This will iterate over each key in the 'Attributes' interface and assign it to 'Key'.

What about the right side?

Remember that what we want to do is, the right side should be a function that returns the type of the corresponding key from the 'Attributes' interface. Just ask yourself. How can we get the type of a property from an interface using its key?

We can use the indexed access type syntax. It looks like this -

    Attributes[Key]

For example, to get the type of the 'firstName' property, we can write -

    Attributes['firstName']

Similarly, for 'lastName', it would be -

    Attributes['lastName']

And this is what we can use on the right side of our mapped type. So, the complete mapped type would look like this -

    type AttributeGetters = {
        [K in keyof Attributes] : () => Attributes[K]
    }

Here, we are telling TypeScript to iterate over each key in the 'Attributes' interface and create a new property in the 'AttributeGetters' type where the property name is the same as the key, and the type is a function that returns the type of the corresponding property from the 'Attributes' interface.

And this is how we can use Mapped Types in TypeScript to create new types by transforming existing ones dynamically!

You might also think that what if we had used a 'Record' type here instead of a mapped type? Would that work?

Let's see. We want the key on the left side to be the same as the keys from the 'Attributes' interface. So, we can use 'keyof Attributes' for that -

    type AttributeGetters = Record<keyof Attributes, () => ??? >

But, what about the right side? We want the type to be a function that returns the corresponding type from the 'Attributes' interface. But in the 'Record' type, we cannot dynamically get the type based on the key. We have to provide a single type for all keys.

And that's why here, using a 'Record' type won't work for our use case.

Another thing worth mentioning is that you are not restricted to only using the 'keyof' operator in mapped types. We can use any union of something that is assignable to a 'string'. For example, if we had a union type like this -

    type Colors = 'red' | 'green' | 'blue';

We could've created a mapped type like this -

    type ColorHexCodes = {
        [C in Colors] : string;
    }

Notice how we used the 'Colors' union type on the left side of the mapped type to create a new type 'ColorHexCodes' where each color is mapped to a string type representing its hex code.

But remember that it only works if the union is assignable to 'string', 'number', or 'symbol' since those are the valid types for object keys in TypeScript. If we had -

    type InvalidKeys = { a: number } | { b: number };

Then, trying to create a mapped type like this -

    type InvalidMappedType = {
        [K in InvalidKeys] : string;
    }

It would result in an error -

    Type 'InvalidKeys' is not assignable to type 'string | number | symbol'.

It clearly says that 'InvalidKeys' is not assignable to 'string | number | symbol', which is required for object keys in TypeScript.