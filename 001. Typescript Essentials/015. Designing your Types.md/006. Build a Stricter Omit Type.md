Remember the 'Omit' type that comes built-in with TypeScript?

To recall, it allows you to create a new type by excluding specific keys from an existing type. However, the built-in 'Omit' type doesn't enforce that the keys you want to omit actually exist on the original type.

So, something like this is valid -

    type Example = Omit<{a : string }, "b">;

Notice how we're trying to omit the key "b", which doesn't exist on the original type. This can lead to potential mistakes in your code. Since there is no error, you might think that the omission was successful, but in reality, nothing changed.

So, let's try to create a stricter version of 'Omit' that ensures the keys you want to omit are indeed present in the original type.

We want to create a type that takes two arguments just like 'Omit' - the original type and the keys to omit.

   type StrictOmit<T,K> = Omit<T,K>

So, how do we tweak it so that we ensure that 'K' should only be a union of the keys in 'T'?

Remember that to get all the keys of an object type, we can use the 'keyof' operator.

So, we can get a union of all keys in 'T' using -

    keyof T

Let's say 'T' is -

    {
        name: string;
        age: number;
        isAdmin: boolean;
    }

In that case, 'keyof T' would give us the union type -

    "name" | "age" | "isAdmin"

So, now, we want to add a constraint that 'K' should always be a subset of the keys of 'T'. And well, we can do that by using the 'extends' keyword. Here's how our 'StrictOmit' type looks now -

    type StrictOmit<T, K extends keyof T> = Omit<T,K>;

Notice how we added the constraint 'K extends keyof T'. This ensures that 'K' can only be a union of keys that exist in 'T'.

So, it means Type parameters can rely on other Type parameters for their constraints! Pretty neat, right?

So, now if we try to use 'StrictOmit' like this -

    type Example = StrictOmit<{a : string }, "b">;

This will give us an error -

    Type '"b"' does not satisfy the constraint '"a"'.

And just like 'Omit', we can pass a union of keys to omit multiple keys at once -

    type Example2 = StrictOmit<{a : string; b: number; c: boolean}, "a" | "c">;

Here, since both "a" and "c" exist in the original type, this will work just fine.