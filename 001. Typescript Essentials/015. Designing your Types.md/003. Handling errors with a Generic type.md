One of the really powerful use case of generic types is to handle errors in a consistent way.

Let's say we have a generic type -

    type Result<TResult, TError> = {
        success: true;
        data: TResult;
    } | {
        success: false;
        error: TError;
    }

So, in this type, we can either have a successful result with the data of type 'TResult' or an error result with the error of type 'TError'.

Let's say we have a function -

    const createRandomNumber = (): Result<number, Error> => {
        const num = Math.random();

        if (num > 0.5) {
            return {
                success: true,
                data: 123
            }
        }

        return {
            success: false,
            error: new Error('Number is too low')
        }
    }

So, this function returns a 'Result' type where the successful result contains a number and the error result contains an Error object. And TypeScript knows that based on the 'success' property, we can determine whether the result is successful or an error. So, you will see that inside the 'if' block, TypeScript knows that since 'success' is true, the 'data' property is available. You won't be able to use the 'error' property there.

Similarly, in the 'else' block, TypeScript knows that since 'success' is false, the 'error' property is available. You won't be able to use the 'data' property there.