Alright, let's take Mapped types one step further.

Let's take the same example as before -

    interface Attributes {
        firstName: string;
        lastName: string;
        age: number;
    }


    type AttributeGetters = {
        [K in keyof Attributes] : () => Attributes[K]
    }

So far, this will create a new type 'AttributeGetters' like this -

    type AttributeGetters = {
        firstName: () => string;
        lastName: () => string;
        age: () => number;
    }

But, what if we want the keys to be 'getFirstName', 'getLastName', and 'getAge' instead of just 'firstName', 'lastName', and 'age'?

The first thing that comes to mind is to concatenate 'get' with the keys. We have learned about 'Template Literal Types' in one of the previous sections. We can use that here as well.

But, how can we use those?

Can we write -

    type AttributeGetters = {
        [`get${K in keyof Attributes}`] : () => Attributes[K]
    }

Well, this won't work as the syntax is wrong.

There is actually another keyword that we can use here and that's 'as'.

The 'as' keyword in TypeScript lets us remap keys in mapped types. There is actually a separate section on the official TypeScript documentation about this - https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as

So, we can use 'as' to give a different name to the keys while iterating over them.

We want all the keys to have a prefix of 'get'. So, we can do something like this -

    type AttributeGetters = {
        [K in keyof Attributes as `get${K}`] : () => Attributes[K]
    }
    
So, we are telling TypeScript to iterate over each key in the 'Attributes' interface, and for each key, create a new property in the 'AttributeGetters' type where the property name is 'get' followed by the original key name, and the type is a function that returns the type of the corresponding property from the 'Attributes' interface.

So, we will get -

    type AttributeGetters = {
        getfirstName: () => string;
        getlastName: () => string;
        getage: () => number;
    }

But there is still one problem here. The keys are 'getfirstName', 'getlastName', and 'getage'. We want the key names to be capitalized after 'get'. So, does this mean we have to create a new type to capitalize each key?

Well, there is a built-in utility type in TypeScript called 'Capitalize' that can help us here. It capitalizes the first letter of a string literal type. We just have to pass it a string type, and it will return the capitalized version of it. So, we can use it like this -

    type AttributeGetters = {
        [K in keyof Attributes as `get${Capitalize<K>}`] : () => Attributes[K]
    }

And boom! We get the desired result -

    type AttributeGetters = {
        getFirstName: () => string;
        getLastName: () => string;
        getAge: () => number;
    }

This shows the power of mapped types in TypeScript. You can not only transform the types but also remap the keys dynamically using the 'as' keyword along with other utility types like 'Capitalize'. 

So, in this example, we used various features of TypeScript together - mapped types, indexed access types, template literal types, key remapping using 'as', and utility types to create a new type.