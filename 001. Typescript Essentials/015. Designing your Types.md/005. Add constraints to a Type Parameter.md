In the last section, we saw how we can have default type parameters for our generic types.

Now, let's take the same example and take another scenario.

    type Result<TResult, TError = Error> = {
        success: true;
        data: TResult;
    } | {
        success: false;
        error: TError;
    }

So, what if we want to enforce the fact that the 'TError' type parameter should always be an object and that object should have at least one property named 'message ' of type string?

This means, if we do -

    type X = Result<number, string>

This should not be allowed because 'string' does not satisfy the constraint that we want to impose on the 'TError' type parameter.

All of these should be valid -

    type A = Result<number, { message: string }>;
    type B = Result<number, { message: string; code: number }>;
    type C = Result<number, { message: string; info: any }>;

So, how do we add constraints to a type parameter in TypeScript?

For this we can use the 'extends' keyword.

So, we can tell TypeScript that 'TError' actually extends an object type that has a 'message' property of type string.

Something like this -

    type Result<TResult, TError extends { message: string} = Error> = {...}

Here, we are telling TypeScript that whatever type is passed as 'TError' should at least have a 'message' property of type string. And now, if we try to create a type like -

    Result<number, string>
    
TypeScript will throw an error because 'string' does not satisfy the constraint. The error message will say -

    Type 'string' does not satisfy the constraint '{ message: string; }'

So, it clearly indicates that the type we are passing does not have the required structure.

Remember that our default value should also satisfy the constraint. In our case, the default type is 'Error' which does have a 'message' property of type string, so it's valid.

But, if we had something like -

    type Result<TResult, TError extends { errorMessage: string} = Error> = {...}

This would have resulted in an error for the default type parameter 'Error' because it does not have a property named 'errorMessage'.

So, this is also one thing to keep in mind while adding constraints to type parameters in TypeScript.

Also, when we add a constraint, it does not mean that the type we pass has to be exactly the same as the constraint type. It can have additional properties as well. As long as it has at least the properties defined in the constraint, it's valid.

That's why, when we created types A, B, and C above, they were all valid because they all had at least the 'message' property of type string. It does not matter if they have additional properties. And it makes sense because 'extends' means 'is a subtype of' or 'has at least the structure of'. It does not mean 'is exactly the same as'.