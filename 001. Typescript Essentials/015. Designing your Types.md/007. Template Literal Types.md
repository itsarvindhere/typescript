Let's talk about something really cool in TypeScript - Template Literal Types!

They are pretty similar to the template literals you might be familiar with in JavaScript, but instead of working with strings at runtime, they work with types at compile time.

Let's understand them with an example.

    type AbsoluteRoute = string;
    const goToRoute = (route: AbsoluteRoute) => {};

Here, we have a function 'goToRoute' that takes a string as an argument. But we want to ensure that the string passed to this function is always an absolute route, meaning it should start with a '/'.

So, right now we have an 'AbsoluteRoute' type defined as a string, but this doesn't enforce our requirement.

We want to ensure that any string assigned to 'AbsoluteRoute' starts with a '/'. This is where we can use Template Literal Types.

Just like in case of normal template literals where we can embed expressions within backticks, in Template Literal Types, we use backticks to define a pattern for our types.

So, we can write -

    type AbsoluteRoute = `/${string}`;

And that's it! Now, any string assigned to 'AbsoluteRoute' must start with a '/'.

    goToRoute("/home"); // Valid
    goToRoute("/about"); // Valid
    goToRoute("/contact"); // Valid
    goToRoute("somewhere"); // ERROR

So, the error will say -

    Argument of type '"somewhere"' is not assignable to parameter of type '`/${string}`'.

This means we are not enforcing that the string starts with a '/'. And this is just the beginning of what you can do with Template Literal Types. You can create complex patterns and even combine them with other types to create powerful type definitions.

You can say 'Template Literal Types' are like literal strings but on steroids! In Literal Types, you define exact values, while in Template Literal Types, you define patterns that types must follow.

One thing worth mentioning is that when we write -

    type AbsoluteRoute = `/${string}`;

Here, we can think of 'string' as a placeholder that can be replaced with any string value. And this value can also be nothing at all. So this is a valid assignment -

    goToRoute("/"); // Valid

# REPRESENT ALL POSSIBLE TYPE COMBINATIONS

Let's take another example -

    type BreadType = 'rye' | 'brown' | 'white';

    type Filling = 'cheese' | 'ham' | 'salami';

    type Sandwich = unknown;

Here, we have two types - 'BreadType' and 'Filling'. Now, we want to create a new type 'Sandwich' that represents all possible combinations of bread types and fillings.

So, 'Sandwich' can be any of these -

    "rye sandwich with cheese"
    "rye sandwich with ham"
    "rye sandwich with salami"
    "brown sandwich with cheese"
    "brown sandwich with ham"
    "brown sandwich with salami"
    "white sandwich with cheese"
    "white sandwich with ham"
    "white sandwich with salami"

One way is to manually list all these combinations, but that would be tedious and error-prone.

here, we can see that all the possible combinations follow a specific pattern -

    First the bread type, followed by " sandwich with ", and then the filling.

Well, we can sue Template Literal Types to define this pattern and let TypeScript generate all the combinations for us -

    type Sandwich = `${BreadType} sandwich with ${Filling}`;

And boom! Now, 'Sandwich' type represents all possible combinations of bread types and fillings.

If you hover over 'Sandwich', you'll see that TypeScript has generated all the combinations for you - 

    type Sandwich = "rye sandwich with cheese" | "rye sandwich with ham" | "rye sandwich with salami" | "brown sandwich with cheese" | "brown sandwich with ham" | "brown sandwich with salami" | "white sandwich with cheese" | "white sandwich with ham" | "white sandwich with salami"

So, we can see how powerful and convenient Template Literal Types can be for generating complex type combinations based on patterns!