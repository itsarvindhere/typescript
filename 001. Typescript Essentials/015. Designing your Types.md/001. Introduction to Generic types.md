So, what are 'Generic Types' in TypeScript?

First, let's understand what even are 'Generics.' In simple words, Generics are parameters to a type/interface. Generics is to a type, like parameters are to a function.

So, why do we need Generics?

Let's take an example to understand this better.

Let's say we have these types =

    type ErrorShape = {
        error: {
            message: string;
        };
    };

    type UserDataShape = {
        data: {
            id: string;
            name: string;
            email: string;
        };
    } | ErrorShape;

    type PostDataShape = {
        data: {
            id: string;
            title: string;
            body: string;
        };
    } | ErrorShape;

Here, we have three types - ErrorShape, UserDataShape, and PostDataShape.

If you notice, we are doing kind of the same thing for both UserDataShape and PostDataShape. Both types have a 'data' property that contains specific fields, and both can also have an 'error' property of type ErrorShape.

If more and more shapes are added, we will end up repeating the same structure again and again.

So, how can we reduce the amount of repetition here?

That's where we can create a Generic type. A type that in itself is not that useful but when we pass other types to it, it becomes useful.

We can create some sort of a type e.g. 'DataShape' and maybe we can then pass it the specific object structure we want for the 'data' property. E.g. we can then use it like -

    type UserDataShape = DataShape<{
        id: string;
        name: string;
        email: string;
    }>;

    type PostDataShape = DataShape<{
        id: string;
        title: string;
        body: string;
    }>;

So, how do we create such a type?

We can create a Generic type by using angle brackets <> and defining a type parameter inside it. Here's how we can define the 'DataShape' type:

    type DataShape<T> = {
        data: T;
    } | ErrorShape;

Here, we are saying that 'DataShape' is a type that takes a type parameter 'T'. The 'data' property of 'DataShape' will be of type 'T'.

So, if we pass it an object let's say { id: string; name: string; email: string; }, then the 'data' property will be of that type. So, in that case, we will get -

    {
        data: {
            id: string;
            name: string;
            email: string;
        };
    } | 
    error: {
         message: string;
    };

Notice how 'T' gets replaced by the actual type we passed to 'DataShape'. It's something like how we pass arguments to functions and those arguments get used inside the function body.

Whatever we pass inside the angle brackets <> is called a 'Type Parameter.' And we can have multiple type parameters as well, separated by commas.

And if you have used TypeScript, you know that there are various built-in Generic types as well, like 'Array<T>', There is a single type 'Array' but we can pass different types to it, and it will create an array of that specific type. That's the magic of Generics!

And we can see the benefit already. Not only have we reduced repetition, but we have also made our types more flexible and reusable. We can now create new data shapes just by passing different types to 'DataShape', without having to redefine the entire structure each time. In the future, if we decide to change the structure of our data shapes, we only need to update the 'DataShape' type, and all the other types that use it will automatically reflect those changes. This makes our codebase easier to maintain and less error-prone.

So, there is a single source of truth for our data shapes, which is always a good practice in software development.