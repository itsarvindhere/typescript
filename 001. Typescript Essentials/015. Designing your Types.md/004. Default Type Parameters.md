So, we know that we can have multiple Type Parameters in our generic types. But, what if we have some type with a lot of type parameters, and we want to provide a default type for some of them? Maybe we do not want to specify all the type parameters every time we use that type?

If we take the example from the previous section where we had a 'Result' generic type -

    type Result<TResult, TError> = {
        success: true;
        data: TResult;
    } | {
        success: false;
        error: TError;
    }

And instead of returning 'Result<number, Error>', what if we want to return 'Result<number>' instead?

Right now, we cannot because it will say that "Generic type 'Result' requires 2 type arguments." So, right now, both the type parameters are required. We need to make the second type parameter optional and provide a default type for it.

Well, as it turns out, just like we do with function parameters, we can also provide default types for type parameters in TypeScript. We use the equals sign (=) to provide a default type for a type parameter -

    type Result<TResult, TError = Error> = {..}

Here, we are telling TypeScript that if the user of this type does not provide a type for the 'TError' type parameter, it should default to the built-in 'Error' type.

So now, we can use the 'Result' type like this -

    const createRandomNumber = (): Result<number> => {
        const num = Math.random();

        if (num > 0.5) {
            return {
                success: true,
                data: 123
            }
        }

        return {
            success: false,
            error: new Error('Number is too low')
        }
    }

Since inside the 'if' block, we are returning a successful result, TypeScript infers the type of 'createRandomNumber' function to be 'Result<number>', and since we did not provide a type for the 'TError' type parameter, it defaults to the built-in 'Error' type.

For the 'success: false' case, we are explicitly creating a new 'Error' object, which is compatible with the default type of the 'TError' type parameter.

Remember that just like normal functions, the default type parameters should always be after the required type parameters. That is, we cannot do -

    type Result<TResult = number, TError> = {..} // Error

Here, TypeScript will throw an error saying "Required type parameters may not follow optional type parameters."