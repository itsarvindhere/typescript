The main use case of declaration files is that they allow TypeScript to understand the types of JavaScript libraries that do not have built-in type definitions. By providing type information through declaration files, developers can leverage TypeScript's static type checking and IntelliSense features when working with these JavaScript libraries.

In fact, there is whole repository called 'DefinitelyTyped' which is a repo for TypeScript type definitions for various JavaScript libraries. For example, libraries like 'lodash', 'node' etc. are written in JavaScript so they do not have built-in type definitions. However, you can find their type definitions in the 'DefinitelyTyped' repository, which can be installed via npm using the '@types' scope.

For example, for node, you can install the type definitions using the following command:

    npm install --save-dev @types/node

You must have seen such '@types' packages for various libraries in your projects. These packages provide the necessary type definitions for the corresponding JavaScript libraries, allowing TypeScript to understand their types and provide better tooling support.

Let's try to recreate the issue that the declaration files try to solve.

Let's say we have an example.js file in our typescript project -

    export const myFunc = () => {
        return 'Hello World';
    }

All this file does is export a function called myFunc which returns a string 'Hello World'.

We have a typescript file named 'index.ts' which calls the myFunc function from example.js -

    import {myFunc} from "./example";

    const result = myFunc();

Well, we will see an error in the IDE saying -

    Could not find a declaration file for module './example'.

So, we are trying to use a JavaScript module in our TypeScript file, but TypeScript cannot find any type information for the module. This is where declaration files come into play.

So to create a file that provides type information for example.js, we create a declaration file named example.d.ts in the same directory as example.js - 

    export const myFunc: () => string;

So, all this file does is declare the type of the myFunc function, which is a function that takes no arguments and returns a string.

And now, the error in index.ts will go away because TypeScript can now find the type information for the myFunc function from the declaration file example.d.ts.

In case it does not go away for you, try to rewrite the import statement in index.ts. Sometimes it takes a little nudge to recognize the declaration file.

So, now, we can use the 'myFunc' function in our TypeScript file with proper type checking and IntelliSense support, thanks to the declaration file we created.

You should remember that the declaration file will not stay in sync with the code inside example.js. If we change the implementation of myFunc in example.js, we need to manually update the declaration file example.d.ts to reflect those changes. But, this is a small price to pay for the benefits of type safety and better tooling support that declaration files provide when working with JavaScript libraries in TypeScript.