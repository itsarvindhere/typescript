Nowadays, the norm is to use modules in the frontend applications. Modules help to keep the code organized, maintainable, and reusable.

Since we know TypeScript supports both modules and scripts, it's possible to accidentally write code that doesn't use modules at all. This can lead to issues like global namespace pollution and difficulties in managing dependencies. So, how do we enforce module usage in TypeScript?

So, if we have a script file, then we should see an error.

There is an option in the tsconfig.json file called 'moduleDetection'. This is the option which controls how TypeScript actually detects modules in your codebase.

By default, this option is set to 'auto', which means apart from import and export statements, TypeScript also looks at the 'type' property in the package.json file to determine if the file should be treated as a module or a script.

There is another option named 'legacy' which is an old behavior where TypeScript only looks for import and export statements to determine if the file is a module.

Finally, we have an option called 'force' which enforces that all files (except declaration files) are treated as modules, regardless of the presence of import/export statements or package.json settings.

So, if we want to enforce module usage in our TypeScript project, we can set the 'moduleDetection' option to 'force' in our tsconfig.json file like this:

    {
        "compilerOptions": {
            "moduleDetection": "force"
        }
    }

So now, if we have a script1.ts file without any import/export statements, an script2.ts calls a function from script1.ts, we will see an error saying - 'Cannot find name 'func'. That is because TypeScript is treating script1.ts as a module.

It is recommended that you set the 'moduleDetection' option to 'force' in your tsconfig.json file to ensure that all files are treated as modules. This helps to maintain a clean and organized codebase, avoiding potential issues with global namespace pollution.