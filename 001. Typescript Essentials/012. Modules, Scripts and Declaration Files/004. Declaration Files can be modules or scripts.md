Now, the declaration files can be of two types - modules or scripts.

When we have export or import statements in a declaration file, it is considered a module. But, when there are no export or import statements, it is considered a script. And when it is a 'script', all the declarations inside it are considered to be in the global scope.

So, if we have a file foo.d.ts with this code -

    type MyType = string;

    interface MyInterface {
        myProp: string;
    }

Here, we are not exporting or importing anything. So, this file is considered a script, and both 'MyType' and 'MyInterface' are in the global scope. Therefore, we can use them in other files without importing them.

So, if we have a file index.ts, we can directly use 'MyType' like this -

    type X = MyType

There is no need to import 'MyType' from 'foo.d.ts' because it is in the global scope.

So, here, 'foo.d.ts' is a declaration file that is a script.

Remember the 'moduleDetection' option in tsconfig.json? When we set it to 'force', all typescript files are treated as modules, even if they don't have export or import statements.

But, that property has no effect on declaration files. Declaration files are always treated as modules or scripts based on the presence of export or import statements, regardless of the 'moduleDetection' setting. So, even if we set 'moduleDetection' to 'force', the above 'foo.d.ts' will still be treated as a script because it has no export or import statements.


There is one interesting thing with declaration files. Let's say we have this foo.d.ts file -

    export type MyType = string;

    interface MyInterface {
        myProp: string;
    }

Notice how here, we are exporting 'MyType', but not exporting 'MyInterface'. Since there is an export statement, this file is considered a module. Therefore, both 'MyType' and 'MyInterface' are not in the global scope. To use them in other files, we need to import them explicitly.

Do you think we can use 'MyInterface' in other files with import statement? Remember that it is not exported from 'foo.d.ts'.

In an ideal situation, we should not be able to import 'MyInterface' in other files because it is not exported. However, TypeScript allows us to import 'MyInterface' in other files even though it is not exported from 'foo.d.ts'.

    import type { MyInterface } from "./foo";

    type X = MyInterface

That's a pretty weird behavior in declaration files.

But, if we have an empty export {} statement in 'foo.d.ts', like this -

    export type MyType = string;

    interface MyInterface {
        myProp: string;
    }

    export {}

Then, we will not be able to import 'MyInterface' in other files.

I do not know why TypeScript behaves this way with declaration files. But, this is something to keep in mind while working with declaration files. So, if you want to make sure that your declaration file is a module and does not pollute the global scope, you can add an export {} statement at the end of the file.