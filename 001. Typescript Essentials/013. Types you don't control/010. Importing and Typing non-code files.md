So far, we have used TypeScript and declaration files to type files that are code files, such as JavaScript or TypeScript files.

But, what about non-code files, such as JSON files, image files, CSS files, etc.?

Is it possible to import such non-code files in TypeScript and type them properly?

Let's say we have this code in our TypeScript file -

    import { test } from './test.jpg';

We have an image file named 'test.jpg' in the same directory as our TypeScript file. Now, if we try to compile this code, TypeScript will throw an error saying -

    Cannot find module './test.jpg' or its corresponding type declarations.

So, here, TypeScript is telling us that it cannot find a module named './test.jpg' and it also cannot find any type declarations for it.

So, how do we fix this?

Well, again, we can use declaration files to declare types for such non-code files.

Since we are following this syntax -

    import { test } from './test.jpg';

It basically suggests that 'test.jpg' is a module that exports a named export 'test'.

So, why not tell TypeScript that for 'test.jpg' module, there is a named export 'test' of type 'string'?

Let's try if that works -

    declare module 'test1.jpg' {
        const image: string;
    }

Somehow, this does not work. TypeScript still throws the same error.

The reason is that this will only work if we import the module like this -

    import { image } from 'test.jpg';

Notice how we are not having a relative path './' in the module name. But in real scenarios, we will mostly be using relative paths to import such non-code files. So, how do we handle that?

Well, here, we can use a wildcard module declaration to declare types for all '.jpg' files. We use an asterisk (*) as a wildcard to match any module name that ends with '.jpg'.

So, we can write the declaration like this -

    declare module '*.jpg' {
        const image: string;
    }

Now, we are telling TypeScript that for any module that ends with '.jpg', there is a named export 'image' of type 'string'.

You might think what if we had -

    declare module './test1.jpg' {
        const image: string;
    }

Well, this would not work because TypeScript does not support relative paths in module declarations. So, we have to use wildcards to match such modules.

And this is how we can import and type non-code files in TypeScript using declaration files!

What if we had a default export instead of a named export? That is, what if we had -

    import test from './test.jpg';

In that case, our declaration file wont work -

    declare module '*.jpg' {
        const image: string;
    }

Right now, we are declaring a named export 'image', but we need to declare a default export.

So, we can modify our declaration file like this -

    declare module '*.jpg' {
        const image: string;
        export default image;
    }

Now, we are telling TypeScript that for any module that ends with '.jpg', there is a default export of type 'string'.

And if there is a default export, the name of the constant does not matter. We can name it anything. What matters is that we are using 'export default' to indicate that it is a default export.