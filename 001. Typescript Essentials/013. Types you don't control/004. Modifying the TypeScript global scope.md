We have seen how the lib.dom.d.ts file provides type definitions for the DOM API, allowing us to use browser-specific features in our TypeScript code. However, there may be situations where we want to extend or modify the global scope provided by TypeScript.

For example, what if we know that there will be a global variable available at runtime in the 'window' object named 'DEBUG'?

Maybe in code, we want to use it like this -

    const state = window.DEBUG.getState();

Our code might run perfectly fine but at type level, TypeScript will throw an error -

    Property 'DEBUG' does not exist on type 'Window & typeof globalThis'.

And that's pretty expected because TypeScript has no knowledge of this global variable. All it knows are the types defined in the lib.dom.d.ts file.

So, how do we tell TypeScript about this global variable? In other words, how do we modify the TypeScript global scope?

If we look at the 'window' declaration in lib.dom.d.ts file, we will see something like this -

    declare var window: Window & typeof globalThis;

What is this 'Window' here? It's an interface defined in the same file. If we search for it, we will find its definition -

    interface Window extends ... {
        // many properties and methods
    }

Now, if you remember when we talked about interfaces in TypeScript way back, we learned that interfaces are open-ended. This means we can add new properties to an existing interface by simply redeclaring it.

So, what if we redeclare the window interface and add our DEBUG property to it?

All we need to do is to add a new 'DEBUG' property to the Window interface like this -

    interface Window {
        DEBUG: {
            getState: () => any;
        };
    }

So, where do we add it?

First place is in the same file where we are using it. And we can use it using the 'declare global' syntax like this -

    declare global {
        interface Window {
            DEBUG: {
                getState: () => any;
            };
        }
    }

    const state = window.DEBUG.getState();

With the 'declare global' syntax, we are telling TypeScript compiler that the declaration inside the block is a global declaration and should be available across all files.

So now, the error goes away and we can use the 'DEBUG' property on the 'window' object without any issues.

There is another way and that's to crate a separate declaration file, say window.d.ts, and put the interface declaration there like this -

    interface Window {
        DEBUG: {
            getState: () => any;
        };
    }

Here, we do not need to use the 'declare global' syntax because declaration files are treated as global by default, unless they are modules (i.e., they have import/export statements).

If we had an 'export' statement in the window.d.ts file, then there would still be an error in our code for 'window.DEBUG' object, because the declaration would be treated as a module and not global.

And that's how we can modify the TypeScript global scope to add our own properties or methods to existing global objects like 'window'.
