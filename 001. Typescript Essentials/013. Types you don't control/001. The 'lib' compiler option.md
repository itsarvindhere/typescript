Let's say we have this simple code - 

    const str = 'Hello World';
    str.replaceAll('Hello', 'Hi');

And our tsConfig is right now this -

    {
        "compilerOptions": {
            "module": "nodenext",
            "target": "es2015",
            "types": [],
            "sourceMap": true,
            "declaration": true,
            "declarationMap": true,
            "noUncheckedIndexedAccess": true,
            "exactOptionalPropertyTypes": true,
            "strict": true,
            "jsx": "react-jsx",
            "verbatimModuleSyntax": true,
            "isolatedModules": true,
            "noUncheckedSideEffectImports": true,
            "moduleDetection": "force",
            "skipLibCheck": true,
        }
    }

We will see an error on 'replaceAll' method saying -

    Property 'replaceAll' does not exist on type '"Hello World"'.

That is quite surprising since we know that 'replaceAll' is a valid method on string in JavaScript.

If you read the whole error, it will be -

    Property 'replaceAll' does not exist on type '"Hello World"'. Do you need to change your target library? Try changing the 'lib' compiler option to 'es2021' or later.

So, it is suggesting us to change the 'lib' compiler option.

There are actually two ways to fix this.

# THE 'target' OPTION

The first is to look at the 'target' property in tsConfig. The 'target' property defines the JavaScript version we are targeting. Each JavaScript version comes with its own set of features. The 'replaceAll' method was added in ES2021.

But, if we look at our tsconfig.json, we have 'target' set to 'es2015'. This means, if we try to use a feature that was added after ES2015, TypeScript will throw an error, even though at runtime (in Node.js or browser), it might work perfectly fine.

So, let's try to set the target to 'es2021' or later - 

    "target": "es2021"

Now, we see that the error on 'replaceAll' is gone.

If you want to see in which version a feature was added, you can actually ctrl + click on the method name in your IDE (if it supports it) and it will take you to the TypeScript definition file and you can actually check the name of the file where it is defined.

For example, if you ctrl + click on 'replaceAll', it will take you to 'lib.es2021.string.d.ts', which indicates that this method was added in ES2021. But, this will only work if the 'target' is set to a version that includes this feature. Otherwise, it won't take you anywhere. And that's the reason for the error because TypeScript does not know about this method when the target is set to 'es2015'.

This is a good place to reiterate how declaration files work in TypeScript.

TypeScript uses declaration files (with .d.ts extension) to understand the types and structures of JavaScript features. These declaration files are grouped based on the JavaScript version they belong to. When we set the 'target' in tsConfig, TypeScript includes the relevant declaration files for that version, which is why changing the target can resolve such issues.

# THE 'lib' OPTION

There is a second option to fix this issue, which is to use the 'lib' compiler option in tsConfig.

So, what is the 'lib' option?

This option basically lets you specify what library files you have access to.

With this, you can be really specific about what features you want to include in your project. If you do not choose anything, TypeScript will automatically include the library files based on the 'target' option.

So, what is the difference between 'target' and 'lib'?

Well, the 'target' property actually changes what JS features are downleveled (or transpiled) and which are left intact by TypeScript. So, it controls which target of JavaScript should be emitted from the given TypeScript.

For example, an arrow function '() => this' will be turned into an equivalent function expression if 'target' is ES5 or lower.

But, 'lib' does not do any downleveling. It just tells TypeScript what features are available in the environment where the code will run.

So, let's say we want to use 'Promises' in our code but we do not want to change the 'target' from 'es2015'. In that case, we can just add 'es2015.promise' to the 'lib' array in tsConfig like this -

    "lib": ["es2015.promise"]

Now, the TypeScript compiler won't complain about 'Promise' usage in our code. And it will still downlevel to ES2015 as per our 'target' setting.

If we have -

    {
        "compilerOptions": {
            "target": "ES5",
            "lib": ["ES2017", "DOM"]
        }
    }

This means:

    1. target: "ES5"

    Output JavaScript syntax compatible with ES5 environments (old browsers).

    TypeScript will down-compile newer JS features.

    2. lib: ["ES2017", "DOM"]

    You can still use types for ES2017 APIs (Promise, AsyncIterator, etc.).

    TS will not complain about missing types for modern APIs.

    Your runtime must support them or you must include polyfills.