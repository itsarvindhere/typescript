In the last section, we saw how we can integrate typescript with Node.js by installing the '@types/node' package. This package provides type definitions for Node.js, allowing TypeScript to recognize Node.js-specific globals and modules.

We know that Node has a global variable called 'process' that contains information about the current Node.js process, including environment variables. The 'env' property of the 'process' object is an object that contains the user environment.

So, what if we know that our application will have certain environment variables, and we want to add type definitions for those variables to get better type safety and autocompletion in our TypeScript code?

Let's say we have an environment variable named 'MY_ENV_VAR' that we want to use in our application.

If we try to say -

    const myEnvVar = process.env.MY_ENV_VAR;

The type for 'myEnvVar' will be 'string | undefined', because TypeScript doesn't know if 'MY_ENV_VAR' is defined in the environment or not. We are sure that it will be defined, so we want to tell TypeScript about it.

So, how do we modify the type definitions for 'process.env' to include our custom environment variable?

Well, from our previous knowledge, we can try to write something like this -

    declare global {
        interface ProcessEnv {
            MY_ENV_VAR: string;
        }
    }

Since the 'env' property is of type 'ProcessEnv' inside process.d.ts file, and 'ProcessEnv' is an interface, we can extend it by declaring a global interface with the same name.

So, it should work, right? But, it won't work! The type for 'myEnvVar' will still be 'string | undefined'. But, why is that the case?

Well, remember that the syntax is use above will simply extend an interface in the global scope. But, is 'ProcessEnv' really in the global scope?

If you hover over the 'env' property of 'process', you'll see -

    NodeJS.Process.env

So, the 'Process' interface is not in the global scope, but inside the 'NodeJS' scope. And if you open the process.d.ts file, it defines the scope as -

    global {
        namespace NodeJS {
            interface ProcessEnv extends Dict<string> {
                ...
            }
        }
    }

Therefore, to correctly extend the 'ProcessEnv' interface, we need to declare it inside the 'NodeJS' namespace as well.

And so, we can do this like this -

    declare global {
        namespace NodeJS {
            interface ProcessEnv {
                MY_ENV_VAR: string;
            }
        } 
    }

Again, a better place to put this declaration would be in a separate '.d.ts' file, so that it is picked up globally by TypeScript. And since we do not need 'declare global' in our d.ts file, we can simply write -

    namespace NodeJS {
        interface ProcessEnv {
            MY_ENV_VAR: string;
        }
    }

So, now we are telling TypeScript that inside the 'NodeJS' namespace, the 'ProcessEnv' interface has a property named 'MY_ENV_VAR' of type 'string'.

We could've also written -

    declare namespace NodeJS {
        interface ProcessEnv {
            MY_ENV_VAR: string;
        }
    }

But inside a '.d.ts' file, the 'declare' keyword is optional as the entire file is already considered an "ambient" declaration context. TypeScript understands that namespace NodeJS { ... } is meant to merge with and augment the existing global NodeJS namespace.

But for clarity, it's often better to include the 'declare' keyword.