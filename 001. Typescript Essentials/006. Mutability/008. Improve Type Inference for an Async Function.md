Let's say we have an async function -

    const fetchData = async () => {
        const result = await fetch('/');

        if (!result.ok) {
            return [new Error('Failed to fetch data')];
        }

        const data = await result.json();
        return [undefined, data];
    };

This function makes a network request and we want to return a tuple such that it can have at most two values. The first value is an error (if any) and the second value is the data fetched from the network request (if there is no error).

As we can see, if there is an error, we return a tuple with the first value as an 'Error' object. If there is no error, we return a tuple with the first value as 'undefined' and the second value as the fetched data.

Now, let's call this function -

    const example = async() => {
        const [error, data] = await fetchData();
    };

If you hover over 'error' and 'data' variables, you will see that TypeScript has inferred their types as 'any'. Ths makes sense because if you hover over 'fetchData' the type is inferred as '() => Promise<any[]>'.

We actually want TypeScript to infer a 'tuple' here.

One way is to use a tuple type.

So, let's create a new type for this -

    type APIResponse = [Error | undefined, any];

Since we know that the first value in the tuple can either be an 'Error' object or 'undefined', we define it as 'Error | undefined'. The second value can be of any type, so we define it as 'any'.

Now, we can use this type in our function -

    const fetchData = async (): Promise<APIResponse> => {
        const result = await fetch('/');

        if (!result.ok) {
            return [new Error('Failed to fetch data')];
        }

        const data = await result.json();
        return [undefined, data];
    };

    const fetchData = async (): Promise<APIResponse> => {...}

But there will be an error in the IDE because if there is an error, we are directly returning '[new Error('Failed to fetch data')]' which is of type '[Error]'. This is not compatible with our defined type 'APIResponse' which is of type '[Error | undefined, any]'. We want to ensure that the second value is optional. We can do that in a Tuple using a question mark.

    type APIResponse = [Error | undefined, any?];

Now, we are saying that the second value in the tuple is optional. So, if there is an error, we can return a tuple with just one value.

Now, inside our example function, if we hover over 'error' and 'data', we will see that TypeScript has inferred their types correctly as 'Error | undefined' and 'any' respectively.

But, instead of a type, we can simply use 'as const' as well -

    const fetchData = async () => {
        const result = await fetch('/');

        if (!result.ok) {
            return [new Error('Failed to fetch data')] as const;
        }

        const data = await result.json();
        return [undefined, data] as const;
    };

When we do this, TypeScript infers the return type of 'fetchData' as -

    Promise<readonly [Error] | readonly [undefined, any]>

So, instead of a tuple, we get a union of two tuples. The first tuple is for the case when there is an error and the second tuple is for the case when there is no error.

And this also works fine. If we hover over 'error' and 'data' inside the 'example' function, we will see that TypeScript has inferred their types correctly as 'Error | undefined' and 'any' respectively.