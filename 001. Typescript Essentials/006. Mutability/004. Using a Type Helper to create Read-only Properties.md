In the previous example, we learnt about the 'readonly' modifier that can be used to create read-only properties in a TypeScript interface. 

What if we have a existing object type and we want to make all its properties read-only without manually adding the 'readonly' modifier to each property?

For example, let's say we have this interface -

    interface SearchParams {
        q?: string;
        page: number;
        pageSize: number;
        sort?: string;
        order?: 'asc' | 'desc';
    }

And we have a method that takes an object of this type as a parameter -

    const handleSearchParams = (search: SearchParams) => {
        // Do Something
    }

Now, here, we have to do something with the 'search' object but we want to make sure that we don't accidentally modify any of its properties. One way is to manually go through each property and add the 'readonly' modifier like this -

    interface ReadonlySearchParams {
        readonly q?: string;
        readonly page: number;
        readonly pageSize: number;
        readonly sort?: string;
        readonly order?: 'asc' | 'desc';
    }

But, this is not an ideal solution, especially if the original interface has many properties or if it changes frequently.

There is a utility type that 'TypeScript' offers which we can use just for this and it is named 'Readonly'.

# READONLY

The syntax is simply -

    Readonly<Type>

It takes a single type argument and constructs a type with all properties of that type set to 'readonly', meaning the properties of the constructed type cannot be reassigned.

So, we can simply say -

    const handleSearchParams = (search: Readonly<SearchParams>) => {
        // Do Something
    }

Behind the scenes, this 'ReadOnly' does this -

    type Readonly<T> = {
        readonly [P in keyof T]: T[P];
    };

So, it simply takes a Type 'T' and adds a 'readonly' modifier to each property of that type. We could've done this ourselves as well like this -

    type ReadonlySearchParams = {
        readonly [K in keyof SearchParams]: SearchParams[K];
    };

But, since 'TypeScript' already provides this utility type, we can simply use it.

Now, it is worth mentioning that this will only make the top-level properties read-only. If any of the properties are objects themselves, their properties can still be modified.


For example, if the Search Params were like -

    interface SearchParams {
        q?: string;
        page: number;
        pageSize: number;
        sort?: string;
        order?: 'asc' | 'desc';
        filters: {
            category?: string;
            priceRange?: [number, number];
        };
    }

And we use the 'Readonly' utility type like this -

    const handleSearchParams = (search: Readonly<SearchParams>) => {
        // Do Something
    }

In that case, we can still modify the properties of the 'filters' object like this -

    const handleSearchParams = (search: Readonly<SearchParams>) => {
        search.page = 2; // Error: Cannot assign to 'page' because it is a read-only property.
        search.filters.category = 'books'; // This is allowed
    };

So, keep that in mind when using the 'Readonly' utility type.