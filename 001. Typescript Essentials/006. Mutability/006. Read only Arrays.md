Let's talk about arrays now.

How do we make an array read-only in TypeScript?

Let's say that we have this method -

    function printNames(names: string[]) {
      for (const name of names) {
        console.log(name);
      }

      names.push("New Name"); // Oops! We just modified the array!
      names[0] = "Changed Name"; // Oops! We just modified the array!
    }

We have a function whose only job is to take an array of strings and print them to the console. But, the issue is that if someone wanted to, they could modify the array inside this function. This is not what we want.

We want to ensure that whatever string array gets passed to ths function, that cannot be modified inside the function. In other words, we want to make the array read-only.

We can do it simply using the 'readonly' modifier. We just need to define the type of 'names' as a readonly array -

    function printNames(names: readonly string[]) {
      for (const name of names) {
        console.log(name);
      }

      names.push("New Name"); // Error!
      names[0] = "Changed Name"; // Error!
    }

Another way will be to use the 'ReadonlyArray' type -

    function printNames(names: ReadonlyArray<string>): void {
        for (const name of names) {
            console.log(name);
        }

        names.push("New Name");
        names[0] = "Changed Name";
    }

But, since we generally give the type of arrays using the 'type[]' syntax, we can use the 'readonly' modifier instead of using the 'ReadonlyArray' type.

# DISTINGUISHING ASSIGNABILITY BETWEEN READONLY AND MUTABLE ARRAYS

Let's say we have these two functions -

    function printNamesReadonly(names: readonly string[]) {
        for (const name of names) {
            console.log(name);
        };
    };

    function printNamesMutable(names: string[]) {
        for (const name of names) {
            console.log(name);
        };
    };

They both take an array of strings and print them to the console. The only difference is that the first function takes a 'readonly' array, while the second function takes a mutable array. This means, inside the first function, we cannot modify the array, while inside the second function, we can modify the array.

So, let's say we have a mutable array of strings -

    const mutableNames: string[] = ["Alice", "Bob", "Charlie"];

Do you think we can pass this mutable array to both the functions?

The answer is - we can pass it to both the functions!

    printNamesReadonly(mutableNames); // Works!
    printNamesMutable(mutableNames); // Works!

And it makes sense because when we pass a mutable array to a function that takes a readonly array, we are not breaking any rules. The function that takes a readonly array promises not to modify the array.

But, what if we have a readonly array of strings -

    const readonlyNames: readonly string[] = ["Alice", "Bob", "Charlie"];

Now, if we try to pass this readonly array to both the functions -

    printNamesReadonly(readonlyNames); // Works!
    printNamesMutable(readonlyNames); // Error!

Now, the function that expects a mutable array is not happy. And it makes sense because if we pass a readonly array to a function that expects a mutable array, then the function might try to modify the array, which is not allowed. So, TypeScript smartly prevents us from doing that.