Let's say we have the same interface as the previous examples -

    interface ButtonAttributes {
        type: 'button' | 'submit' | 'reset';
    }

Suppose we have a function to modify attributes of a button -

    const modifyButton = (attributes: ButtonAttributes) => {
        // Do Something
    }

If we try to use the function like this -

    const buttonAttributes = {
        type: 'button'
    };

    modifyButton(buttonAttributes);

TypeScript will complain and throw an error -

    Argument of type '{ type: string; }' is not assignable to parameter of type 'ButtonAttributes'.
        Types of property 'type' are incompatible.
            Type 'string' is not assignable to type '"button" | "submit" | "reset"'

We know that this is because of how in objects and arrays, the properties are mutable by default. So TypeScript infers the type of 'type' property as 'string' instead of the literal type ''button''.

One way to fix this is to explicitly tell TypeScript that the type of the object is 'ButtonAttributes' like this -

    const buttonAttributes: ButtonAttributes = {
        type: 'button'
    };

    modifyButton(buttonAttributes); // No Error

But, there is another way to fix this.

We can simply write -

    const buttonAttributes = {
        type: 'button'
    } as const;

    modifyButton(buttonAttributes); // No Error

Wait, what just happened? What is this 'as const'? As soon as we added 'as const', the type of 'buttonAttributes' changed from '{ type: string; }' to -

    const buttonAttributes: {
        readonly type: "button";
    };

So, not only it added a 'readonly' modifier to the property 'type', it also changed the type of 'type' from 'string' to the literal type ''button''.

We could've also added 'as const' to the 'type' property like this -

    const buttonAttributes = {
        type: 'button' as const
    };

    modifyButton(buttonAttributes); // No Error

This also works because we are telling TypeScript that the type of 'type' property is the literal type ''button'' and not 'string'. This means, we can use 'as const' for individual properties as well.

One benefit of doing this is that when we use 'as const' on the entire object, it makes all the properties 'readonly'. But if we use 'as const' on individual properties, we are just making the type of that property a literal type without making it 'readonly'. This is useful when we do not want to make the properties 'readonly' but only want to infer the literal types.

But, remember that doing this does not make the property immutable. Yes, it can only have 'button' as value but that also means we can do something like this and there won't be any error since 'type' is not readonly -

    buttonAttributes.type = 'button'; // No Error

# USING OBJECT.FREEZE

What if instead of 'as const', we used 'Object.freeze' like this -

    const buttonAttributes = Object.freeze({
        type: 'button'
    });

    modifyButton(buttonAttributes); // No Error

Well, if we hover over 'buttonAttributes', we will see that the type is -

    const buttonAttributes: Readonly<{
        type: "button";
    }>

So, 'Object.freeze' also added a 'readonly' modifier to the property 'type' and changed the type of 'type' from 'string' to the literal type ''button''.

# AS CONST VS OBJECT.FREEZE

So, what should we use if both are doing the same thing? Well, while both seem to be doing the same thing, there is one big difference.

To understand that, let's say we have two types -

    type ButtonType = 'button' | 'submit' | 'reset';

    interface ButtonAttributes {
        cancel: {
            type: ButtonType;
        };

        confirm: {
            type: ButtonType;
        };
    };

So now, we have a type 'ButtonType' which is simply a union of string literals. And we have an interface 'ButtonAttributes' which has two properties 'cancel' and 'confirm', both of which are objects with a property 'type' of type 'ButtonType'.

We have a function that takes an object of type 'ButtonAttributes' -

    const modifyButton = (attributes: ButtonAttributes) => {
        // Do Something
    }

And let's say we have an object that we want to pass to this function -

    const buttonAttributes = {
        cancel: {
            type: 'button'
        },
        confirm: {
            type: 'button'
        }
    };

What do you think will happen when we call 'modifyButton(buttonAttributes)'? Will it throw an error or not?

The answer is YES.

The reason is that TypeScript infers the type of 'buttonAttributes' as -

    const buttonAttributes: {
        cancel: {
            type: string;
        };
        confirm: {
            type: string;
        };
    }

So, the type of 'type' property in both 'cancel' and 'confirm' is inferred as 'string' instead of the literal type 'ButtonType'. As we saw earlier, one way to fix this is to use 'as const' like this -

    const buttonAttributes = {
        cancel: {
            type: 'button'
        },
        confirm: {
            type: 'button'
        }
    } as const;

    modifyButton(buttonAttributes); // No Error

And now, the type of 'buttonAttributes' is -

    const buttonAttributes: {
        readonly cancel: {
            readonly type: "button";
        };
        readonly confirm: {
            readonly type: "button";
        };
    }

What about Object.freeze? Let's see -

    const buttonAttributes = Object.freeze({
        cancel: {
            type: 'button'
        },
        confirm: {
            type: 'button'
        }
    });

    modifyButton(buttonAttributes); // Error

There is still an error. When we used 'Object.freeze', the type of 'buttonAttributes' is inferred as -

    const buttonAttributes: Readonly<{
        cancel: {
            type: string;
        };
        confirm: {
            type: string;
        };
    }>

It is using the 'Readonly' utility type and as we already know, it only makes the top-level properties readonly, but the nested properties are still mutable. So, the type of 'type' property in both 'cancel' and 'confirm' is still inferred as 'string' instead of the literal type 'ButtonType'.

That is why when we use 'Object.freeze', we still get an error.

So, that's the biggest difference between 'as const' and 'Object.freeze'. 'as const' makes the entire object and its nested properties readonly and infers the literal types, while 'Object.freeze' only makes the top-level properties readonly and does not infer the literal types for nested properties.

Moreover, 'as const' is something TypeScript offers so it does not have any runtime impact, while 'Object.freeze' is a JavaScript method that has a runtime impact.