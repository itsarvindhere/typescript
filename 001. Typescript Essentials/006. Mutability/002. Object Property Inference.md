Let's take a similar example as before. 

    interface ButtonAttributes {
        type: 'button' | 'submit' | 'reset';
    }

    const modifyButton = (attributes: ButtonAttributes) => {
        // Do some stuff
    }

    const buttonAttributes = {
        type: 'button'
    };

    modifyButton(buttonAttributes);  // ERROR

In this case, we have the same interface 'ButtonAttributes' as before but a new function 'modifyButton' which takes an argument of type 'ButtonAttributes'.

We have a new object 'buttonAttributes' which has the same structure as the 'ButtonAttributes' type. We then pass this object to the 'modifyButton' function.

But, TypeScript shows an error in the IDE - 

    Argument of type '{ type: string; }' is not assignable to parameter of type 'ButtonAttributes'.
            Types of property 'type' are incompatible.
                Type 'string' is not assignable to type '"button" | "submit" | "reset"'.ts

So, even if we have created our 'buttonAttributes' object just like how our interface is defined, TypeScript still throws an error. Why is that?

In fact, we are also using 'const' here which was supposed to help us avoid this issue. So, what's going on?

Well, it is important to note that if we have 'const' objects and arrays in JavaScript, it only means that the reference to the object or array cannot be changed. But the properties of the object or the elements of the array can still be changed.

This means, if we have - 

    const obj1 = { prop: 'value1' };

We can safely do -

    obj1.prop = 'value2'; // This is valid

But, we cannot do -

    obj1 = { prop: 'value3' }; // This will throw an error

In our example, we created an object with 'const' thinking that it will make the properties immutable. But that is not the case.

Since 'TypeScript' knows that the properties of a 'const' object can still be changed, it infers the type of the property 'type' in the 'buttonAttributes' object as 'string' and not the literal type 'button'.

That's why we get the error when we try to pass this object to a function which expects an argument of type 'ButtonAttributes'.

Similarly, if we had an array of objects -

    const buttonsToChange = [
        {
            type: 'button'
        },
        {
            type: 'submit'
        },
    ];

    const modifyButtons = (attributes: ButtonAttributes[]) => {
        // Do some stuff
    }

    modifyButtons(buttonsToChange); // ERROR

In this case too, we will get the same error because TypeScript infers the type of the 'type' property in each object in the 'buttonsToChange' array as 'string' and not the literal types.

One way to fix this would be to directly pass the object into the function instead of creating a variable like this -

    modifyButton({ type: 'button' }); // No Error

    modifyButtons([
        { type: 'button' },
        { type: 'submit' }
    ]); // No Error

But, that may not be the most ideal solution in many cases.

The other solution is to tell TypeScript that this object that we created is of type 'ButtonAttributes' and not some generic object -

    const buttonAttributes: ButtonAttributes = {
        type: 'button'
    };

    modifyButton(buttonAttributes); // No Error

    const buttonsToChange: ButtonAttributes[] = [
        {
            type: 'button'
        },
        {
            type: 'submit'
        },
    ];

    modifyButtons(buttonsToChange); // No Error