In TypeScript 3.0, a new "top" type was introduced named 'unknown'. A 'top' type means that it is a supertype of all types.

We already know that there is an 'any' type which is a supertype of all types, meaning you can assign any value to a variable of type 'any'. However, this can lead to potential runtime errors if you're not careful.

You can think of 'unknown' as a type-safe version of the 'any' type. This means, a variable that has a type as 'unknown' can be assigned any type of value. But, that variable cannot be assigned to anything else (except itself and 'any') without first asserting or narrowing to a more specific type. Similarly, no operations are permitted on an unknown without first asserting or narrowing to a more specific type.

Sounds confusing?

Let's take a simple example.

    const fn = (input: any) => {
        // Some code
    }

Here, we have a function that accepts an 'input' which is of type 'any'. This means, we can do any of these and there won't be any issues -

    
    fn('Hello');
    fn(42);
    fn(true);
    fn({ key: 'value' });
    fn([1, 2, 3, 4, 5]);
    fn(() => console.log("Hello world!"));

But, there is one problem with using 'any' here. Inside the 'fn' function, we can write stuff that may not be valid at runtime when we provide a value to 'input. For example, we might be having a line to convert input to uppercase like this -

    const fn = (input: any) => {
        console.log(input.toUpperCase());
    }

There won't be any error shown in the IDE because TypeScript does not know what type 'input' has. At runtime, if we pass a number to 'fn', it will throw an error because numbers do not have a 'toUpperCase' method.

And that's where 'unknown' comes in. As mentioned above, it is a 'type-safe' counterpart of 'any'. So, let's replace 'any' with 'unknown' and see what happens - 

    const fn = (input: unknown) => {
        console.log(input.toUpperCase());
    }

As soon as we replace 'any' with 'unknown' you will see an error in your IDE saying -

    'input' is of type 'unknown'.ts

And that's the benefit of 'unknown'.

Remember that no operations can be done on a variable of type 'unknown' before first asserting or narrowing to a more specific type.

So, before we use any method on 'input', we have to first narrow it down to a more specific type, in our case a string. We can use any of a narrowing techniques we have learnt so far.

So, we can write -

    if (typeof input === "string") {
        console.log(input.toUpperCase());
    }

Also, remember that we cannot assign a variable of type 'unknown' to anything else without first asserting or narrowing it down to a more specific type.

So, we cannot say -

    const newInput: string = input;

This will throw an error in the IDE saying -

    Type 'unknown' is not assignable to type 'string'

