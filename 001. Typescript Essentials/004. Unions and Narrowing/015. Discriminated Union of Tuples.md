So far, we saw Discriminated Unions of 'objects'. Now, let's explore how we can create Discriminated Unions of 'tuples'.

Let's say that we have this code -

    type User = {
        id: string;
    }

    type ApiResponse = [string, User[] | string];

    async function fetchData(): Promise<ApiResponse> {
        try {
            const response = await fetch('/api/data');
            if (!response.ok) {
                return ['error', 'An error occurred'];
            }
            const data = await response.json();
            return ['success', data];
        } catch (error) {
            return ['error', 'An error occurred'];
        }
    }

    async function fn() {
        const [status, value] = await fetchData();
        if (status === 'success') {
            console.log(value);
        } else {
            console.error(value);
        }
    }

We have a type 'User' which represents a user object with an 'id' property. The 'ApiResponse' type is a tuple that can either be a success response with a list of users or an error message.

Right now, the issue is we can return something like this and there won't any errors - 

    return ['asdasdasd', 'dasdasdas'];

So, maybe let's ensure that the first element of the tuple is either 'success' or 'error' -

    type ApiResponse = ['success' | 'error', User[] | string];

Now, we can only return tuples where the first element is either 'success' or 'error'.

But still, there is one issue. Since the second element of the tuple can either be an array of 'User', or a string, it means we can do something like these and they will be valid as per TypeScript -

    return ['success', 'An error occurred'];
    return ['error', [{id: '123'}]]

And you can actually see this inside the 'fn' function where we console log the 'value'. if you hover over the 'value' inside the first 'if' check, it will have a type as 'User[] | string', even though we know that for 'success', the type should be 'User[]'. Similarly, for the 'else' block, it should be a string but right now, it will show the type as 'User[] | string'.

And here, we can again make use of 'Discriminated Unions' to enforce this constraint.

We can create two separate types for the success and error cases -  

    
    type SuccessApiResponse = ['success', User[]];
    type ErrorApiResponse = ['error', string];

    type ApiResponse = SuccessApiResponse | ErrorApiResponse;

And now, we have a Discriminated Union of Tuples. Here, the discriminator is the first element of the tuple. The first element defines what the second element should be.

Now, inside the 'fn' function, inside the first 'if' check which is for 'success' case, the 'value' will correctly have a type as 'User[]'. Similarly, for the 'else' block, the 'value' will have a type as 'string'.

