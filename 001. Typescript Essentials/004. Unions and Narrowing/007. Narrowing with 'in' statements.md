Let's say we have this code - 

    type SuccessResponse = {
        data: {
            id: string
        }
    }

    type ErrorResponse = {
        error: string
    }

    type APIResponse = SuccessResponse | ErrorResponse;

    const handleResponse = (response: APIResponse) => {
        if ('data' in response) { // Some Condition to check if response is SuccessResponse
            return response.data.id;
        } else {
            throw new Error(response.error);
        }
    }

Here, we have a type 'APIResponse' which is a union of two types 'SuccessResponse' and 'ErrorResponse'. The type 'SuccessResponse' has a property 'data' which contains the 'id' of the resource, while the type 'ErrorResponse' has a property 'error' which contains the error message. 

We have a method named 'handleResponse' that takes an 'APIResponse' as an argument. Inside the method, we want to check if the response is a 'SuccessResponse' or an 'ErrorResponse' and handle it accordingly.

You may think that we can use 'typeof' operator here but remember that 'typeof' operator in JavaScript only works with built-in types like string, number, boolean, function, object, symbol, bigint, and undefined.

Note that we can use 'typeof' when we are defining types in Typescript (this will come later). But here, we cannot use 'typeof' to distinguish between 'SuccessResponse' and 'ErrorResponse'.

Here, we can make use of the 'in' operator. 

We know that 'response' can be one of two objects. Either it will be an object which has a 'data' property in it or it will be an object which has an 'error' property in it.

So, we can use the 'in' operator to explicitly check if 'response' has a 'data' property or not. If it has one, we know that it is a SuccessResponse.

    if ('data' in response) {
        return response.data.id;
    } else {
        throw new Error(response.error);
    }

And inside this 'if' check, if you hover over 'response', it will have the type 'SuccessResponse'. Similarly, in the 'else' block, it will have the type 'ErrorResponse'.

So, we have narrowed down the type of 'response' based on the presence of the 'data' or 'error' property. And even on the runtime level, this check will be present in the generated JavaScript code.

It is worth noting, however, that it is working here in our case because 'data' key is only present in SuccessResponse. If we had something like this - 

    type SuccessResponse = {
        data: {
            id: string
        }
    }

    type ErrorResponse = {
        data: string;
        error: string
    }

Now, our 'in' check no longer works because now, TypeScript does not know whether the response is a SuccessResponse or an ErrorResponse just on the basis of 'data' key because both the types have 'data' property.

So, this is something to keep in mind when designing your types. If you need to distinguish between different types in a union, make sure to include unique properties in each type that can be used for type narrowing.