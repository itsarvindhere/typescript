Let's now come to one of the TypeScript's most powerful features which is 'Narrowing'.

Let's say we have this piece of code - 

    const convertTime = (time: string | number) => {
        if (typeof time === 'string') {
            console.log(time);
            // Do something with string
        } else {
            console.log(time);
            // Do something with number
        }

        console.log(time);
    }

Our 'convertTime' function can accept a 'time' as either a 'string' or a 'number'.

If we get a 'string' value, we want to do something with it, but if we get a 'number', we want to do something else. So, we have to explicitly tell TypeScript this and we are doing that using 'typeof'.

This is what narrowing is all about. By using type guards like 'typeof', we can narrow down the type of a variable within a specific scope, allowing us to write more type-safe code.

If you hover over 'time' inside the 'if' block, the IDE will show -

    time: string

But, if you hover over 'time' inside the 'else' block, the IDE will show -

    time: number

If you hover over 'time' in the console.log statement that is outside the if or else blocks, the IDE will show -

    time: string | number

Typescript looks at these special checks like 'typeof' (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing.

Since we said 'Type Guards', it means that 'typeof' is not the only way to narrow types. There are other ways to achieve narrowing as well.