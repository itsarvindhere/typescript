Let's take the same old example as before and just tweak it a bit -

    type User = {
        id: string;
    }

    type ApiResponse = [boolean, User[] | string];

    async function fetchData(): Promise<ApiResponse> {
        try {
            const response = await fetch('/api/data');
            if (!response.ok) {
                return [false, 'An error occurred'];
            }
            const data = await response.json();
            return [true, data];
        } catch (error) {
            return [false, 'An error occurred'];
        }
    }

    async function fn() {
        const [succeeded, value] = await fetchData();

        if (succeeded) {
            console.log(value);
        } else {
            console.error(value);
        }
    }

Here, we have changed the type of 'ApiResponse' to use a boolean for the success status instead of a string literal - 

    type ApiResponse = [boolean, User[] | string];

And so, when there is a success response, we can simply return [true, data] and for an error response, we return [false, 'An error occurred']. This makes it very clear what the structure of the response will be.

But right now, inside our 'fn' function, in both 'if' and 'else' blocks, the type of 'value' is still 'User[] | string'.

This means, it is possible to return these inside fetchData and TypeScript won't show any errors -

    return [false, [{id: '123'}]]

    return [true, 'some error occurred']

This is wrong because ideally, if there is a success, we want to ensure that the second element is always a User[] and not a string. Similarly, if there is an error, we want to ensure that the second element is always a string and not a User[].

To achieve this, we can use a discriminated union -

    type SuccessApiResponse = [true, User[]]
    type ErrorApiResponse = [false, string]

    type ApiResponse = SuccessApiResponse | ErrorApiResponse;

And now, we ensure that if there is a success response, the second element is always a User[] and if there is an error response, the second element is always a string.

So, it means the discriminator does not always have to be a string. Here, the discriminator is a boolean value.