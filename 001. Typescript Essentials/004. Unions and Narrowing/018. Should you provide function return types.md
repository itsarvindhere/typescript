Let's end this section on Unions and Narrowing by talking about whether we should provide return types to our functions in TypeScript.

One of the biggest cons of providing return types to functions is tht the return types that we provide may be wider than what the function actually returns. This means, we can have a function like -

    const returnStringOrNumber = (): string | number => {
        return 1;
    }

Here, even though our function returns a number, we explicitly told TypeScript that it returns either a string or a number.

So, in such cases, we might have to write more defensive code than what we actually need. We may have a code for this function like this -

    const value = returnStringOrNumber();

    if (typeof value === 'string') {
        // Some logic
    }

In this case, this 'if' check will never pass because the function will always return a number. But still, we are writing this if check which is not necessary.

But, a benefit of providing return types for functions is that they can help enforce the type of the function so TypeScript will tell you when you are doing something wrong.

For example, if we have this code -

    type UserRole = 'admin' | 'editor' | 'viewer';

    function getPermissions(role: UserRole): string[] {
        switch (role) {
            case 'admin':
                return ['create', 'read', 'update', 'delete'];
            case 'editor':
                return ['create', 'read', 'update'];
            case 'viewer':
                return ['read'];
        }
    }

Here, TypeScript will enforce that the return type of the function is always a string array. If we try to return a different type, TypeScript will give us an error. This can help catch bugs early in the development process.

Moreover, if let's say we have not handled a case in this switch block -

    function getPermissions(role: UserRole): string[] {
        switch (role) {
            case 'admin':
                return ['create', 'read', 'update', 'delete'];
            case 'editor':
                return ['create', 'read', 'update'];
        }
    }

Here, we are not handling the 'viewer' case, which means 'undefined' will be returned for that case. TypeScript will catch this error because the return type is explicitly defined as a string array.

So, in future, if we add another role in 'UserRole' type and we do not handle it inside the switch statement, TypeScript will again catch this error and help us ensure that all possible cases are handled. Yes, we can have a default case that simply returns an empty array but that's not the point here.

The point is that, when we have functions that have multiple branches, explicitly defining the return type can help us catch errors early.

But, if we have a pretty simple and straightforward function, we might not need to provide an explicit return type. TypeScript can often infer the return type based on the function's implementation.

For example, consider the following function:

    function add(a: number, b: number) {
        return a + b;
    }

In this case, TypeScript can infer that the return type is 'number' based on the addition operation. So, we don't necessarily need to provide an explicit return type.
