Consider this type -

    type Shape = {
        kind: 'circle' | 'square';
        radius?: number;
        sideLength?: number;
    }

We have a type 'Shape' which has a 'kind' property of type 'circle' | 'square', an optional 'radius' property of type number, and an optional 'sideLength' property of type number.

Let's say we have a function that calculates the area - 

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            return Math.PI * shape.radius * shape.radius;
        } else {
            return shape.sideLength * shape.sideLength;
        }
    }

This function expects a 'Shape' type object as argument and inside it, if the shape has a 'kind' as 'circle', we calculate the area using the radius of the circle. Otherwise, we use the 'sideLength' since we know that if it is not a 'circle', it should be a 'square' since those are the only two options for 'kind' property.

But, this will show an error in the IDE in both if and else blocks. In the 'if' block, it will show an error saying -

    'shape.radius' is possibly 'undefined'.

Similarly, inside the 'else' block, it will say -

    'shape.sideLength' is possibly 'undefined'.

And if you think about it, it makes sense because even though we have narrowed down the shape to be a 'circle' in the first if check, TypeScript still has no idea that a 'circle' will indeed have a 'radius' property. Similarly, in the 'else' block, TypeScript cannot guarantee that a 'square' will have a 'sideLength' property. No matter the kind, the 'radius' and 'sideLength' will remain optional properties, meaning they can be 'undefined'. And remember that we cannot directly use 'undefined' to do any operations before we check for its existence.

One way is to explicitly check for a 'circle' whether it also has a 'radius' property and same for 'square' -

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle" && shape.radius) {
            return Math.PI * shape.radius * shape.radius;
        } else if (shape.kind === "square" && shape.sideLength) {
            return shape.sideLength * shape.sideLength;1
        }
    }

This will remove the error in the IDE but this is not the best way. What if there were more properties that are specific to a circle and some other properties specific to square? We cannot just go on checking for each property like this.

Moreover, right now, we can even pass a shape object to this function that is something like this -

    const myShape: Shape = { kind: 'circle', radius: 5, sideLength: 10 };

This does not make sense because a circle cannot have a side length. Similarly, we can also do -

    const myShape: Shape = { kind: 'square', sideLength: 10, radius: 5 };

But, TypeScript won't complain because as per our 'Shape' type, this is a valid object. But we know that if kind is a 'circle', it just cannot have a sideLength property at all.

And this is where we can use 'Discriminated Unions' to our advantage. 

# DISCRIMINATED UNIONS

What if, instead of having a single type 'Shape' for both circle and square, we have two separate types for them?

    type Circle = {
        kind: 'circle';
        radius: number;
    }

    type Square = {
        kind: 'square';
        sideLength: number;
    }

Now, we can have a 'Shape' type which is a union of these two -

    type Shape = Circle | Square;

And now, inside our function, we no longer need to explicitly check for each property. Since both the types have a common 'kind' property, we can use that to differentiate between the two -

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            return Math.PI * shape.radius * shape.radius;
        } else if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        }
    }

If you hover over 'shape' inside the 'if' block, it will have a type 'Circle'. Similarly, if you hover over 'shape' inside the 'else if' block, it will have a type 'Square'. This is the power of discriminated unions - TypeScript can narrow down the type based on the 'kind' property, allowing us to safely access the specific properties of each shape without additional checks.

So, a Discriminated Union will always have a common property (there can be more than one properties with the same name but there is usually always one discriminator) that is used to differentiate between the different types in the union. In our case, the 'kind' property serves this purpose. This common property is the 'discriminator' that tells TypeScript which specific type within the union it is dealing with at any given time.