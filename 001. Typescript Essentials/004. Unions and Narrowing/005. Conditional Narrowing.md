Let's take an example of a function that validates the username - 


    function validateUsername(username: string | null) {
        return username.length > 5;
    }

Our 'validateUsername' function accepts a 'username' which is of type 'string' or 'null'. It returns true only if the username has a length greater than 5.

The issue with this method is that the 'username' can be 'null'. It means, if it is null, then we cannot access the 'length' property on it, and this will result in a runtime error. That's why TypeScript shows an error in the IDE saying -

    'username' is possibly 'null'.

There are a lot of ways in which we can fix this issue.

The first and the simplest way is to just ensure that we check if the 'username' is null before accessing its properties.

    function validateUsername(username: string | null) {
        if (username) {
            return username.length > 5;
        }
        return false;
    }

Now, if the 'username' is null or even if it is an empty string, we return false immediately, preventing any runtime errors.

We can also do the opposite - 

    function validateUsername(username: string | null) {
        if (username === null) {
            return false;
        }
        return username.length > 5;
    }

Another way would be to use the 'typeof' operator to check the type of 'username'.

    function validateUsername(username: string | null) {
        if (typeof username === "string") {
            return username.length > 5;
        }
        return false;
    }

Just like above, we can do the opposite -

    function validateUsername(username: string | null) {
        if (typeof username !== "string") {
            return false;
        }
        return username.length > 5;
    }

Remember that we cannot do -

    typeof username === 'null'

Because in JavaScript, the 'typeof' operator will never return 'null' as a type. Instead, it will return 'object' for 'null' values. We could've written -

    function validateUsername(username: string | null) {
        if (typeof username === "object") {
            return false;
        }
        return username.length > 5;
    }

This will work because 'string' is not an object, so the check will correctly identify 'null' values.

# NARROWING WITH BOOLEAN WON'T WORK

In one of the code snippets above, we had -

    function validateUsername(username: string | null) {
        if (typeof username === "string") {
            return username.length > 5;
        }
        return false;
    }

We can also create a variable for the condition and use that in the if check -

    function validateUsername(username: string | null) {
        const isUsernameOK = typeof username === "string";
        if (isUsernameOK) {
            return username.length > 5;
        }
        return false;
    }

Instead of 'typeof' we can also convert the 'username' into a boolean like this -

    function validateUsername(username: string | null) {
        const isUsernameOK = !!username;
        if (isUsernameOK) {
            return username.length > 5;
        }
        return false;
    }

So, let's say 'username' is null. In that case, "!username" will give us 'true' and "!!username" will give us 'false', which is the desired outcome. Remember that "!!" is used to convert a value to a boolean in JavaScript.

This will work as expected.

But, if we use the 'Boolean' constructor like this -

    function validateUsername(username: string | null) {
        const isUsernameOK = Boolean(username);
        if (isUsernameOK) {
            return username.length > 5; // ERROR
        }
        return false;
    }

Then Typescript will show an error in the IDE saying -

    'username' is possibly 'null'.

So, somehow, TypeScript is not able to narrow down the type of 'username' even though we are using the 'Boolean' constructor. And this is one of the gotchas with TypeScript's type narrowing.

# GOTCHAS WHEN NARROWING A MAP IN TYPESCRIPT

Let's say we have this piece of code -

    type Event = {
        message: string;
    }

    const processUserMap = (eventMap: Map<string, Event>) => {
        if (eventMap.has('error')) {
            const message = eventMap.get('error').message;
            throw new Error(message);
        }
    }

We have a method 'processUserMap' which takes a map as an argument where the key is of type 'string' and the value is of type 'Event'.

Inside this function, we first check if the map has an entry for the key 'error'. If it does, we retrieve the corresponding event and throw an error with the event's message.

While this looks like a valid code, TypeScript will throw an error in this line saying -

    const message = eventMap.get('error').message; // Object is possibly 'undefined'
    
But, why is it doing so? Because, we already have an 'if' check which first checks whether the 'eventMap' has a key named 'error' in it. Well, Typescript does not really know the relationship between the 'has' and 'get' methods in Maps so it is causing this issue. This would not have been a problem if we had a simple object instead of a Map. 

To solve it, what we can do is, we can get the 'error' event from the map and then check if it is defined before accessing its properties.

    const processUserMap = (eventMap: Map<string, EventType>) => {

        const errorEvent = eventMap.get('error');
        if (errorEvent) {
            const message = errorEvent.message;
            throw new Error(message)
        }
    }