In the previous section, we had this example -

    type Circle = {
        kind: 'circle';
        radius: number;
    }

    type Square = {
        kind: 'square';
        sideLength: number;
    }

    type Shape = Circle | Square;

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            return Math.PI * shape.radius * shape.radius;
        } else if (shape.kind === "square") {
            return shape.sideLength * shape.sideLength;
        }
    }

We used 'Discriminated Unions' to our advantage here. By having separate types for each shape, we can easily differentiate between them and access their specific properties without any additional checks. This makes our code cleaner and more maintainable.

Now, what if, we want to destructure the 'shape' object that we pass into the 'calculateArea' function, maybe so that we do not have to write 'shape.' before accessing any property?

Something like this -

    const calculateArea = ({kind, radius, sideLength}: Shape) => {
        if (kind === "circle") {
            return Math.PI * radius * radius;
        } else if (kind === "square") {
            return sideLength * sideLength;
        }
    }

Well, right now, this will show an error in the IDE. For the 'radius', it will say -

    Property 'radius' does not exist on type 'Shape'.

And for the 'sideLength' it will say -

    Property 'sideLength' does not exist on type 'Shape'.

There is no such error for 'kind', however.

It makes sense because 'Shape' can either be 'Circle' or 'Square'. Since both have 'kind' property in them, TypeScript can safely access it without any issues. But, the same is not the case with the 'radius' and 'sideLength' properties.

We can try to maybe only have 'kind' in our destructured object as a separate variable and keep the rest in a different variable like this -


    const calculateArea = ({ kind, ...shape }: Shape) => {
        if (kind === "circle") {
            const { radius } = shape;
            return Math.PI * radius * radius;
        } else {
            const { sideLength } = shape;
            return sideLength * sideLength;
        }
    }

With this approach, TypeScript will still raise an error because it doesn't know that 'radius' and 'sideLength' are guaranteed to exist based on the 'kind'.

So, the best way would be to not destructure the arguments like above. Instead, let's destructure them when we have narrowed down the type:

    const calculateArea = (shape: Shape) => {
        if (shape.kind === "circle") {
            const { radius } = shape;
            return Math.PI * radius * radius;
        } else {
            const { sideLength } = shape;
            return sideLength * sideLength;
        }
    }

Since 'shape' is properly narrowed down to 'Circle' inside the first 'if' check, we can safely destructure 'radius' without any TypeScript errors. The same goes for 'sideLength' inside the 'else' check.