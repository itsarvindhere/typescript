Let's take an example -

    const findUserByName = (
        searchParams: {name?: string},
        users: {
            id: string;
            name: string
        }[]
        ) => {
            if (searchParams.name) {
                return users.filter(users => users.name.includes(searchParams.name));
            }

            return users;
    }

    const searchParams = { name: "Bob" };
    const users = [{
        id: '1',
        name: 'Bob'
        },
        {
            id: '2',
            name: 'Alice'
        }
    ];

    console.log(findUserByName(searchParams, users));

Here, we have a function named 'findUserByName'. This function takes two arguments - one is a search parameter object that may contain a name property, and the other is an array of user objects. Each user object has an id and a name.

Inside this function, we simply iterate over the 'users' array and then filter the users who have the name that includes the search parameter's name.

Well, so far, it looks like this is a valid TypeScript code. But, if you write this in your IDE, you will get an error from TypeScript inside the 'includes' method. This error says -

    Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
        Type 'undefined' is not assignable to type 'string'.

It is interesting to see that inside 'includes' method, the 'name' property is still considered as 'string | undefined', even though we have already checked for its existence in the 'if' condition. 

This happens because 'Narrowing' does not get carried over into other scopes, such as the callback function passed to the 'filter' method. This means, inside the 'includes' method, TypeScript still thinks that 'searchParams.name' could be 'undefined'. 

The best way to fix this is to use a local variable and pass that into the includes method.

    let name = searchParams.name;
    if (name) {
        return users.filter(users => users.name.includes(name));
    }

And now, the error goes away.

So, that's how we can ensure that narrowing works correctly in TypeScript, even in nested scopes.