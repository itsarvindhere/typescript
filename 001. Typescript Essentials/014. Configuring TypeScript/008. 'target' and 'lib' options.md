We know that there are several version of JavaScript (also known as ECMAScript) standards, such as ES5, ES6 (ES2015), ES2016, ES2017, and so on. Each version introduces new features and syntax to the language.

So, if we have a TypeScript application, does TypeScript simply know that we want to use the latest JavaScript features? The answer is no.

Let's say I want to tell TypeScript that our code can use all the ES2020 features. How can we tell it to do so?

That's where we can use the 'lib' option in the tsconfig.json file.

This does not affect the output JavaScript version. Instead, it tells TypeScript which built-in APIs (like Array, Map, Promise, etc.) are available in the target environment.\

We also know that there is a 'target' option in the tsconfig.json file. The 'target' option specifies the version of JavaScript that TypeScript will output after transpilation. This is what affects what gets generated in the final JavaScript files.

So, is this possible that we have something like this in our tsconfig file?

    "target": "es2015",
    "lib": ["es2022", "DOM"],

Here, we area basically telling TypeScript to transpile our code to ES2015 syntax, but we are also telling it that we can use all the ES2022 features and DOM APIs in our code.

So, how is TypeScript going to convert our code? What if we use some feature that is there in ES2022 but not in ES2015?

Since there is no error thrown here by TypeScript when we use this config, does this mean TypeScript will automatically polyfill those features for us?

That's where the confusion often arises.

No, TypeScript does not automatically polyfill features for you. It will allow you to use the features from the specified 'lib', but it won't add any polyfills to your output code.

Note that 'Polyfills' are pieces of code (usually JavaScript) that provide modern functionality on older browsers that do not natively support it.

Let's take an example.

Suppose, we have this code -

    const str = 'Hello World';

    str.replaceAll('World', 'TypeScript');

    const myFunc = (input?: {
        search?: string
    }) => {
        // Optional Chaining
        const search = input?.search;

        // Nullish Coalescing
        const defaulted = search ?? 'Hello';
    }

Here, we are using some features that might not be there in ES2015, such as String.prototype.replaceAll, Optional Chaining, and Nullish Coalescing.

So, let's see what happens when we transpile this code with the above tsconfig settings -

    var str = 'Hello World';
    str.replaceAll('World', 'TypeScript');
    var myFunc = function (input) {
        // Optional Chaining
        var search = input === null || input === void 0 ? void 0 : input.search;
        // Nullish Coalescing
        var defaulted = search !== null && search !== void 0 ? search : 'Hello';
    };

Interesting. So, while TypeScript has transpiled the Optional Chaining and Nullish Coalescing features into ES2015-compatible code, it has left the String.prototype.replaceAll method as is.

So, TypeScript will transform the syntax that is not supported in the target version, but it will not add polyfills for methods or APIs that are not available in the target environment.

And this is an important distinction to understand when configuring TypeScript for your projects. So, we will have to provide polyfills ourselves if we are targeting older environments that do not support certain features.

That is why, it is recommended to set the 'target' and 'lib' options to the same values, unless you have a specific reason to do otherwise.

So, in our case, a good practice would be to set both 'target' and 'lib' to 'es2022' if we want to use ES2022 features and ensure compatibility with environments that support them -

    "target": "es2022",
    "lib": ["es2022", "DOM"],

If we want to target let's say ES2015, we should also set 'lib' to 'es2015' to avoid using features that won't be available in that environment -

    "target": "es2015",
    "lib": ["es2015", "DOM"],

Now, the IDE will show an error if we try to use features that are not available in ES2015 e.g. the 'replaceAll' method will show an error now saying -

    Property 'replaceAll' does not exist on type '"Hello World"'. Do you need to change your target library? Try changing the 'lib' compiler option to 'es2021' or later.

So, that's how 'target' and 'lib' work together in TypeScript to help you manage the JavaScript features and APIs you can use in your code.