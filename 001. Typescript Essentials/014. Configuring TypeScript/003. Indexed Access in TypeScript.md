Let's say we have this code in our typeScript file -

    const array = [1,2,3];
    const mightNotExist = array[3];

What do you think the type of 'mightNotExist' is? If you guessed 'number', you are correct!

By default, TypeScript assumes that any indexed access into this array will return the type of the elements in the array. However, in this case, accessing index 3 of the array will actually return 'undefined' since the array only has elements at indices 0, 1, and 2.

So, how can we enforce this behavior in TypeScript such that before we use 'mightNotExist', we have to check if it is 'undefined' or not?

That's where the 'noUncheckedIndexedAccess' compiler option comes into play.

The 'noUncheckedIndexedAccess' setting makes TypeScript treat array and object index access as potentially 'undefined', which helps catch bugs where you access indices that might not exist.

So, if we have an object -

    const obj: Record<string, number> = { a: 1 };
    const value = obj['b']; 

Here too, without 'noUncheckedIndexedAccess', the type of 'value' would be 'number'.

But, if we turn on the 'noUncheckedIndexedAccess' option in our 'tsconfig.json' file, the type of 'value' would become 'number | undefined', prompting us to handle the case where the key might not exist in the object.

So now, you are forced to handle the possibility of 'undefined' whenever you access an array or object by index, making your code safer and more robust -

    console.log(value * 2); // ❌ Error: Object is possibly 'undefined'.

    if (value !== undefined) {
        console.log(value * 2); // ✅ OK - TypeScript knows it's defined here
    }