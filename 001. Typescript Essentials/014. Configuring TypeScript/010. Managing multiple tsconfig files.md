Let's say we have an application where both the client and the server are written in TypeScript. In such cases, it's common to have separate 'tsconfig.json' files for each part of the application to manage their specific compilation settings.

Let's say on the client side, we want to access the DOM APIs, while on the server side, we know that DOM APIs are not available. There can be other options that are specific to client and server as well.

So, is there a way to have multiple 'tsconfig.json' files in a single project?

Let's say we have two files in our 'src' folder: 'client.ts' and 'server.ts'. And in our root folder, we have two 'tsconfig' file.

So far, we know that TypeScript looks at the nearest 'tsconfig.json' file to compile the code. So far, it is looking at the root 'tsconfig.json' file.

So, what if we create two separate directories inside the 'src' folder: 'client' and 'server', and move the respective files into these directories. Then, we can create separate 'tsconfig.json' files in each of these directories.

In this way, for 'client.ts', the nearest 'tsconfig.json' file will be the one inside the 'client' directory, and for 'server.ts', it will be the one inside the 'server' directory.

In the client folder's tsconfig, we can have -

    {
        "compilerOptions": {
            "target": "ES2022",
            "module": "esnext",
            "moduleResolution": "bundler",
            "esModuleInterop": true,
            "noEmit": true,
            "strict": true,
            "skipLibCheck": true,
            "isolatedModules": true
        }
    }

Since here, we are not specifying the 'lib' option, TypeScript will include the default libraries for the specified target, which includes DOM APIs.

And for the server folder's tsconfig, we can have -

    {
        "compilerOptions": {
            "target": "ES2022",
            "module": "esnext",
            "moduleResolution": "bundler",
            "esModuleInterop": true,
            "noEmit": true,
            "strict": true,
            "skipLibCheck": true,
            "isolatedModules": true,
            "lib": ["ES2022"]
        }
    }

So, the difference is the 'lib' option here. By specifying only 'ES2022', we are making sure that if we try to access any DOM APIs in the server code, TypeScript will throw an error in the IDE.

Another benefit now is that if in the server folder, we have some globals in some 'd.ts' file like this -

    const ONLY_FOR_SERVER: string;

Then, we can only access them inside the 'server' directory and if we try to access them in the 'client' directory, TypeScript will throw an error. So, TypeScript is smart to understand that these globals are only available in the server context.

This can be really useful if for example we have some environment variables or some server-specific configurations that we want to keep separate from the client code. Or maybe for tests, there are some globals that are only available in specific environments.

# SHARING CONFIGURATION

One issue right now is that we have to duplicate all the common configuration options in both 'tsconfig.json' files. This can lead to maintenance issues if we want to change some common settings later.

For both the server and client, we have the same 'target', 'module', 'moduleResolution', 'esModuleInterop', 'noEmit', 'strict', 'skipLibCheck', and 'isolatedModules' options.

Is it possible to keep all the common configuration in a single place and have both the 'tsconfig.json' files extend from that common configuration?

Well, we can do that.

Let's create a separate tsconfig file that will act like a base configuration file. Let's call it 'tsconfig.base.json' and place it in the root directory. It is a good idea to name it something different than 'tsconfig.json' to avoid confusion. Because just by looking at 'tsconfig.json' files, it is not clear which one is the base configuration file. Also, we do not want TypeScript to use the base configuration file directly to compile the code. It should only be used for extending other 'tsconfig.json' files.

So, let's name is 'tsconfig.base.json'.

And we can move all the common configuration options to this file like this -

    {
        "compilerOptions": {
            "target": "ES2022",
            "module": "esnext",
            "moduleResolution": "bundler",
            "esModuleInterop": true,
            "noEmit": true,
            "strict": true,
            "skipLibCheck": true,
            "isolatedModules": true
        }
    }

The next step is to inherit from this base configuration file in both the client and server 'tsconfig.json' files.

And for this, there is an option in 'tsconfig.json' files.

Just like we have 'compilerOptions', we can have an 'extends' option at the root level of the 'tsconfig.json' file. This option lets us specify the path to another 'tsconfig.json' file from which we want to inherit the configuration.

So, for client 'tsconfig.json', we can have -

    {
        "extends": "../../tsconfig.base.json"
    }

And for the server 'tsconfig.json', we can have -

    {
        "extends": "../../tsconfig.base.json",
        "compilerOptions": {
            "lib": ["ES2022"]
        }
    }

Since the server 'tsconfig.json' file has some specific configuration, we can still have the 'compilerOptions' section to override or add any specific options.

Remember that if the base configuration file has some options that are also specified in the extending 'tsconfig.json' file, the options in the extending file will take precedence.