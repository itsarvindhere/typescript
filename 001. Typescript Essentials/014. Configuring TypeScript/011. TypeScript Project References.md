A lot of times, we create scripts in the 'package.json' file to compile the TypeScript code. Something like this -

    "scripts": {
        "dev": "run-p dev:*",
        "dev:client": "tsc --project ./src/client/tsconfig.json",
        "dev:server": "tsc --project src/server/tsconfig.json"
    }

Here, we have three scripts. The 'dev' script runs both the 'dev:client' and 'dev:server' scripts in parallel using the 'run-p' command from the 'npm-run-all' package. The 'dev:client' script compiles the client code using the 'tsconfig.json' file in the 'client' directory, and the 'dev:server' script compiles the server code using the 'tsconfig.json' file in the 'server' directory.

We might also have similar scripts for building the code for production or running tests.

Now, this seems pretty tedious to set up so is there a better way?

There is something called 'Project References' in TypeScript that can help us manage multiple 'tsconfig.json' files more efficiently.

So, what are 'Project References'?

There is a 'references' property that we can use in the 'tsconfig.json' file which is an array of objects and each object specifies the projects to reference.

Each object usually has a 'path' property which points to the directory of that project which contains the 'tsconfig.json' file. It can also refer directly to a 'tsconfig.json' file.

So, let's create a new 'tsconfig.json' in the root (it is different from the tsconfig.base.json file we created earlier).

So, in our case, we can write something like -

    {
    "references": [
            {
                "path": "./src/client"
            },
            {
                "path": "./src/server"
            }
        ]
    }

Now, one other thing to add is the 'files' property which should be an empty array. This is to ensure that the root 'tsconfig.json' file does not include any files on its own. In other words, we are telling TypeScript that this 'tsconfig.json' file is only for referencing other projects and not for type checking or compiling any files directly.

        {
            "references": [
                    {
                        "path": "./src/client"
                    },
                    {
                        "path": "./src/server"
                    }
            ],
            "files": []
        }

Next, in the package.json, we just need one script and that will be -

    tsc -b --watch

We use the '-b' flag to tell TypeScript to run in the 'build' mode. Since we do not specify any specific directory, this means, it will consider the root 'tsconfig.json' file and based on that, run all the referenced projects.

If we do not use the '-b' flag, TypeScript will not consider the 'references' property and will just look for files to compile in the current directory.

Final part of the puzzle is the 'composite' option in the 'tsconfig.json' files of the individual projects. This option is required for project references to work. It tells TypeScript that this project can be referenced by other projects. We can just add it once to the 'tsconfig.base.json' file so that both the client and server projects inherit it.

As the official TypeScript documentation says -

    The 'composite' option enforces certain constraints which make it possible for build tools (including TypeScript itself, under --build mode) to quickly determine if a project has been built yet.

Now, once we run this command, we now get type checking in the entire repository including both the client and server projects.

You will notice that after running the commands, it also created some 'tsbuildinfo' files in both the client and server directories. These files are used by TypeScript to store information about the build state of the project. They help TypeScript to determine if a project needs to be rebuilt or not. This is really important because using this, TypeScript can avoid unnecessary recompilations and speed up the build process significantly. That's why, when we use 'build' mode with project references, everything feels so much faster!

These files are not supposed to be committed to version control, so make sure to add them to your '.gitignore' file.

Typescript uses these files to keep track of the state of each project and its dependencies. If nothing has changed, then running the build command again will be super fast as TypeScript will know that everything is already up to date!

So, that's the basic idea of TypeScript Project References! They help us manage multiple 'tsconfig.json' files more efficiently and make our build process faster and more organized.

# WHAT ABOUT MOVING ALL THE TSCONFIG FILES TO THE ROOT?

You might be confused that there are now so many 'tsconfig.json' files in the project.There is a better way to manage this by keeping all of them at the root.

We can create separate 'tsconfig.client.json' and 'tsconfig.server.json' files at the root which extend the 'tsconfig.base.json' file and contain the specific compiler options for the client and server projects respectively.

So, the tsconfig.base.json will be -

    {
        "compilerOptions": {
            "target": "ES2022",
            "module": "esnext",
            "moduleResolution": "bundler",
            "esModuleInterop": true,
            "noEmit": true,
            "strict": true,
            "skipLibCheck": true,
            "isolatedModules": true,
            "composite": true
        }
    }

The tsconfig.client.json will be -

    {
        "extends": "./tsconfig.base.json",
        "include": ["src/client"]
    }

And the tsconfig.server.json will be -

    {
        "extends": "./tsconfig.base.json",
        "compilerOptions": {
            "lib": ["ES2022"]
        },
        "include": ["src/server"]
    }

Notice that since the tsconfig.client.json and tsconfig.server.json files are moved to the root now instead of their individual folders, we have to explicitly use the 'include' property to specify which files to include in each project.

Finally, the main tsconfig.json file will be -

    {
        "references": [
            {
                "path": "./tsconfig.client.json"
            },
            {
                "path": "./tsconfig.server.json"
            }
        ],
        "files": []
    }

It now references these new tsconfig files at the root instead of the ones in the individual folders. We can remove the ones that are in the individual folders now.

So, we have all our tsconfig files at the root now which makes it easier to manage them. The build process remains the same as before.

# TOO MANY TSCONFIG FILES AT THE ROOT?

But now, you can say that as we have more and more projects, the root will have more and more tsconfig files which can get messy. Cannot we have a config folder just for these extra files?

Well, we can. Let's create a '.config' folder at the root and move all the project specific tsconfig files there.

So, we will now have the 'tsconfig.base.json', 'tsconfig.client.json' and 'tsconfig.server.json' files inside the '.config' folder. And the main 'tsconfig.json' file at the root will now be -

    {
        "references": [
            {
                "path": "./.config/tsconfig.client.json"
            },
            {
                "path": "./.config/tsconfig.server.json"
            }
        ],
        "files": []
    }

So, now the project specific tsconfig files are nicely organized inside the '.config' folder and the root remains clean with just the main 'tsconfig.json' file. The build process remains unchanged.

# WHICH APPROACH IS BETTER?

Well, you can choose any approach based on your preference. The first approach with the tsconfig files in the individual folders is straightforward and easy to understand. The third approach with a config folder is more organized and keeps the root clean. The second approach with all tsconfig files at the root is a middle ground.