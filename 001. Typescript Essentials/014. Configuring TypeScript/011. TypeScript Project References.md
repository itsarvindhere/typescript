A lot of time, when our project is too big, 'tsc' feels slow. This is because, by default, 'tsc' will type check and compile all the files in the project every time we run it. This can be really time-consuming for large projects.

For example, we might have a repository with both client and server code and for each of them, we have separate 'tsconfig.json' files to manage their specific compiler options.

Moreover, there can be situations where multiple sub-projects exist within a single repository, each with its own 'tsconfig.json' file, and they might depend on each other. In such cases, running 'tsc' separately for each project can be inefficient and lead to longer build times.

So, how can we make 'tsc' faster and more efficient in such cases?

There is something called 'Project References' in TypeScript that can help us manage multiple 'tsconfig.json' files more efficiently.

If you have a huge project without references, changing one line of code forces TypeScript to re-analyze almost everything to ensure that change didn't break a file 50 folders away.

# PROJECT REFERENCES

In TypeScript, Project References allow you to treat parts of your application as independent mini-libraries rather than one giant blob of code. This means that when you make changes to one part of your application, TypeScript only needs to recompile that specific part and any parts that depend on it, rather than recompiling the entire application. This can significantly speed up the build process, especially in large projects.

So, how do we use Project References in TypeScript?

There is a 'references' property that we can use in the 'tsconfig.json' file which is an array of objects and each object specifies the projects to reference.

Each object usually has a 'path' property which points to the directory of that project which contains the 'tsconfig.json' file. It can also refer directly to a 'tsconfig.json' file.

So, let's create a new 'tsconfig.json' in the root (it is different from the tsconfig.base.json file we created earlier).

So, in our case, we can write something like -

    {
    "references": [
            {
                "path": "./src/client"
            },
            {
                "path": "./src/server"
            }
        ]
    }

Now, one other thing to add is the 'files' property which should be an empty array. This is to ensure that the root 'tsconfig.json' file does not include any files on its own. In other words, we are telling TypeScript that this 'tsconfig.json' file is only for referencing other projects and not for type checking or compiling any files directly.

        {
            "references": [
                    {
                        "path": "./src/client"
                    },
                    {
                        "path": "./src/server"
                    }
            ],
            "files": []
        }

Next, in the package.json, we just need one script and that will be -

    tsc -b --watch

We use the '-b' flag to tell TypeScript to run in the 'build' mode. Since we do not specify any specific directory, this means, it will consider the root 'tsconfig.json' file and based on that, run all the referenced projects.

If we do not use the '-b' flag, TypeScript will not consider the 'references' property and will just look for files to compile in the current directory.

Final part of the puzzle is the 'composite' option in the 'tsconfig.json' files of the individual projects. This option is required for project references to work. It tells TypeScript that this project can be referenced by other projects. When enabled, it basically tells TypeScript - "This folder is a self-contained project. Please generate metadata so other projects can build on top of it without recompiling me every time."

We can just add it once to the 'tsconfig.base.json' file so that both the client and server projects inherit it.

As the official TypeScript documentation says -

    The 'composite' option enforces certain constraints which make it possible for build tools (including TypeScript itself, under --build mode) to quickly determine if a project has been built yet.

Now, once we run this command, we now get type checking in the entire repository including both the client and server projects.

You will notice that after running the commands, it also created some 'tsbuildinfo' files in both the client and server directories. These files are used by TypeScript to store information about the build state of the project. They help TypeScript to determine if a project needs to be rebuilt or not. This is really important because using this, TypeScript can avoid unnecessary recompilations and speed up the build process significantly. That's why, when we use 'build' mode with project references, everything feels so much faster!

These files are not supposed to be committed to version control, so make sure to add them to your '.gitignore' file.

Typescript uses these files to keep track of the state of each project and its dependencies. If nothing has changed, then running the build command again will be super fast as TypeScript will know that everything is already up to date!

So, that's the basic idea of TypeScript Project References! They help us manage multiple 'tsconfig.json' files more efficiently and make our build process faster and more organized.

With Project References:

   - You change a file in 'App'.
   - You run tsc --build.
   - TypeScript looks at the 'Shared' project. It checks a hidden build info file (.tsbuildinfo).
   - It sees that 'Shared' hasn't changed since the last build.
   - It completely skips compiling 'Shared'. It doesn't even open the files. It just trusts the output from last time.
   - It only compiles 'App'.

Apart from speeding up the build process, Project References also help enforce strict boundaries. n a normal project, it is very easy to accidentally import "private" code. For example, if we have 'frontend' and 'backend' folders, it is possible that our IDE auto imports a database helper function from the backend's 'db/secrets.ts' file into the frontend code. This can lead to runtime errors and security issues.

With Project References, this is impossible. If 'Frontend' references 'Shared', it can only see what 'Shared' explicitly exports. It cannot reach into 'Backend' unless you explicitly add a reference to it in tsconfig. It forces you to be intentional about your dependencies.

So, You should use Project References if:

   1. Build Speed: Your type-checking or build process is taking too long (>10-20 seconds).
   2. Monorepo: You have multiple apps (e.g., Web, Mobile, Server) in one repository sharing code.
   3. Strictness: You want to stop developers from creating circular dependencies (where File A needs File B, and File B needs File A), which Project References strictly forbid.

# WHAT ABOUT MOVING ALL THE TSCONFIG FILES TO THE ROOT?

You might be confused that there are now so many 'tsconfig.json' files in the project.There is a better way to manage this by keeping all of them at the root.

We can create separate 'tsconfig.client.json' and 'tsconfig.server.json' files at the root which extend the 'tsconfig.base.json' file and contain the specific compiler options for the client and server projects respectively.

So, the tsconfig.base.json will be -

    {
        "compilerOptions": {
            "target": "ES2022",
            "module": "esnext",
            "moduleResolution": "bundler",
            "esModuleInterop": true,
            "noEmit": true,
            "strict": true,
            "skipLibCheck": true,
            "isolatedModules": true,
            "composite": true
        }
    }

The tsconfig.client.json will be -

    {
        "extends": "./tsconfig.base.json",
        "include": ["src/client"]
    }

And the tsconfig.server.json will be -

    {
        "extends": "./tsconfig.base.json",
        "compilerOptions": {
            "lib": ["ES2022"]
        },
        "include": ["src/server"]
    }

Notice that since the tsconfig.client.json and tsconfig.server.json files are moved to the root now instead of their individual folders, we have to explicitly use the 'include' property to specify which files to include in each project.

Finally, the main tsconfig.json file will be -

    {
        "references": [
            {
                "path": "./tsconfig.client.json"
            },
            {
                "path": "./tsconfig.server.json"
            }
        ],
        "files": []
    }

It now references these new tsconfig files at the root instead of the ones in the individual folders. We can remove the ones that are in the individual folders now.

So, we have all our tsconfig files at the root now which makes it easier to manage them. The build process remains the same as before.

# TOO MANY TSCONFIG FILES AT THE ROOT?

But now, you can say that as we have more and more projects, the root will have more and more tsconfig files which can get messy. Cannot we have a config folder just for these extra files?

Well, we can. Let's create a '.config' folder at the root and move all the project specific tsconfig files there.

So, we will now have the 'tsconfig.base.json', 'tsconfig.client.json' and 'tsconfig.server.json' files inside the '.config' folder. And the main 'tsconfig.json' file at the root will now be -

    {
        "references": [
            {
                "path": "./.config/tsconfig.client.json"
            },
            {
                "path": "./.config/tsconfig.server.json"
            }
        ],
        "files": []
    }

So, now the project specific tsconfig files are nicely organized inside the '.config' folder and the root remains clean with just the main 'tsconfig.json' file. The build process remains unchanged.

# WHICH APPROACH IS BETTER?

Well, you can choose any approach based on your preference. The first approach with the tsconfig files in the individual folders is straightforward and easy to understand. The third approach with a config folder is more organized and keeps the root clean. The second approach with all tsconfig files at the root is a middle ground.