In the last section, we learnt the 'module' option in the 'tsconfig' file which is basically an option that lets us specify what 'module system' we want to use in our TypeScript project. 

There is another important option related to modules in TypeScript called 'moduleResolution'.

So, what is this one?

Well, in simple words, 'moduleResolution' lets you specify how should an 'import' be resolved in your code. It does not impact what code is generated, but it impacts how TypeScript looks for the files that you are trying to import in your code.

Unlike the 'module' option, which has a ton of different values to choose from, the 'moduleResolution' option has only a few values -

    - classic
    - node/node10
    - node16
    - nodenext
    - bundler

So, these are the only options that you can use for the 'moduleResolution' option in your 'tsconfig' file.

So, which one to use and when?

1. 'classic'

The 'classic' option is something that is not recommended for modern projects and it is basically an older strategy (used before TypeScript 1.6). It is mainly kept for backward compatibility. Typescript says it should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.

2. 'node' / 'node10'

The 'node10' option is the same as 'node' and in TypeScript 5.0+ it is recommended that instead of 'node', you use 'node10'. When 'module' is 'commonjs', then the default 'moduleResolution' is 'node10'. This one mimics the module resolution mechanism in Node versions older than v12.

In Node 12, a different module resolution strategy was introduced for ES modules, and so, for modern Node.js projects, 'node10' is not recommended.

3. 'node16'

Node v12 and later support both CommonJS and ES modules. When 'module' is set to 'node16' or 'node18', then the default 'moduleResolution' is 'node16'.

In NodeJs, the 'import' statements and the dynamic import() calls are required to provide the file extension. So, if you are using 'node16' module resolution, then you need to provide the file extensions in your import statements -

    import { myFunction } from './myModule.js'; // CORRECT
    import { myFunction } from './myModule'; // INCORRECT

4. 'nodenext'

Next, we have 'nodenext'. This one is similar to 'node16' and it is the default when 'module' is set to 'nodenext'. This is more of a forward-looking module resolution strategy that will support new Node.js module resolution features as they’re added.

Remember that TypeScript says for 'module' option set to 'node16' and 'nodenext', the 'moduleResolution' option should be 'node16' and 'nodenext' respectively. Setting it to something else  will lead to errors.

5. 'bundler'

Finally, we have 'bundler'. 

Node.js v12 introduced some new module resolution features for importing npm packages—the "exports" and "imports" fields of package.json.

Many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports package.json "exports" and "imports" by default, but can be configured to ignore them. It requires setting module to 'esnext'.

Another thing about this 'bundler' option is that it does not require us to explicitly provide file extensions in the import statements, even when we are using ES modules, something that is not the case with 'node16' and 'nodenext'.

    import { myFunction } from './myModule'; // THIS IS CORRECT WITH 'bundler'

Finally, do note that if you use 'bundler' as the 'moduleResolution' option, then you need to make sure that the 'module' option is set to 'esnext' in your 'tsconfig' file. You cannot set 'module' to something else.