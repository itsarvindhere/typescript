A lot of time, we do not use 'TypeScript' to transpile our code from 'TypeScript' to 'JavaScript'. Instead, we use other tools like 'Babel' or 'esbuild' to do the transpilation. 

Now, most of these tools do transpilation on a per-file basis. This means that they do not have the context of the entire project when transpiling a single file.

For example, if we have a file 'a.ts' with this code -

    declare const enum Numbers  {
        Zero,
        One,
        Two
    }


    const example = Numbers.Zero;

You won't see any errors if we try to transpile this file using 'tsc' because 'tsc' has the context of the entire project and knows that 'Numbers' is a 'const enum'. If you compile the code using 'tsc', it will be transpiled to -

    const example = 0 /* Zero */;

So, as we can see, it has inlined the value of 'Numbers.Zero' as '0' and removed the enum declaration.

But, let's see what happens when we try to transpile this file using 'Babel' -

    const example = Numbers.Zero;

So, when babel transpiles the code, it does not have the context of the entire project and does not know that 'Numbers' is a 'const enum'. Therefore, it leaves the code as is, which will result in a runtime error because 'Numbers' is not defined.

And this is where, 'isolatedModules' comes into play. 

When we enable the 'isolatedModules' flag in our 'tsconfig.json', TypeScript will check each file in isolation and will throw an error if it finds any code that cannot be transpiled in isolation.

So, in our above example -

    declare const enum Numbers  {
        Zero,
        One,
        Two
    }


    const example = Numbers.Zero;

We will see an error like this -

    Cannot access ambient const enums when 'isolatedModules' is enabled.

This tells us that we cannot use 'ambient const enums' when 'isolatedModules' is enabled because they cannot be transpiled in isolation.

So, when isolatedModules is 'true', TypeScript enforces stricter rules to prevent you from using features that require cross-file type information to transpile correctly. This is important because tools like Babel, esbuild, and SWC (which are often faster than the TypeScript compiler) don't perform full type-checking. They just strip types and transform syntax file-by-file.

So, what all things are not allowed when 'isolatedModules' is 'true'?

1. Re-exporting types without the 'type' keyword

In may cases, we might have different files for our types and then a single barrel file to export all the types from a single file. When 'isolatedModules' is 'true', we need to use the 'type' keyword when re-exporting types.

So, if we have a user-types.ts file with -

    export type User = {
        id: number;
        name: string;
    }

And another file named types.ts where we want to re-export the 'User' type -

    export { User } from './user-types';

When 'isolatedModules' is 'true', we will see an error like this -

    Re-exporting a type when 'isolatedModules' is enabled requires using 'export type'.

So, the correct way to re-export the type would be -

    export type { User } from './user-types';

2. Using 'ambient const enums'

As we already saw in the above example, using 'ambient const enums' is not allowed when 'isolatedModules' is 'true' because they cannot be transpiled in isolation.

Note that something in TypeScript is called 'ambient' if it is declared using the 'declare' keyword. This means that it is generally only required for type checking and does not have any runtime representation. In runtime, that is removed. Everything inside a declaration file is implicitly ambient. But if we want to create an ambient declaration in a regular TypeScript file, we can use the 'declare' keyword. That's why when we use 'declare' with 'const enum', it becomes an ambient const enum.

The bottom-line is that if you are using a tool like 'Babel', 'esbuild', or 'SWC' to transpile your TypeScript code, it is a good idea to enable the 'isolatedModules' flag in your 'tsconfig.json' to ensure that your code can be transpiled correctly by these tools. In general as well, it is a good practice to enable this flag to catch potential issues early in the development process.