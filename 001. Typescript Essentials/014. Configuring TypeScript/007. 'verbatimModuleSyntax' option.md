So, let's talk about another interesting 'tsconfig' option named 'verbatimModuleSyntax'.

'verbatim' is a word that means 'in exactly the same words as were used originally'.

So, what happens when we set 'verbatimModuleSyntax' to true in our 'tsconfig.json'?

This is what happens when we enable it -

    1. Imports without the 'type' modifier are treated as real runtime imports and are preserved in the resulting JavaScript output.
    2. Imports with the 'type' modifier are treated as type-only imports and are completely erased from the JavaScript output.

In simple words, it enforces the "what you see is what you get" principle for module syntax, preventing TypeScript from automatically "guessing" whether an import is a type or a value and deciding to elide (remove) it.

Before this flag, TypeScript used a feature called "import elision" -

    1. The compiler would analyze an import statement (e.g., import { Car } from './car';) and automatically remove it from the JavaScript output if Car was only used in type positions (like an interface or type alias).
    2. While often helpful, this automatic elision caused significant issues when a module had side effects or when the TypeScript output was processed by different tools (like Babel or various bundlers) that weren't aware of TypeScript's type-only imports. This led to inconsistent builds and runtime errors because different tools might or might not drop the import.

'verbatimModuleSyntax' stops the guessing game, requiring developers to be explicit.

If we have a file that exports a type -

    // example.ts
    export type User = {
        name: string;
        age: number;
    }

And we are importing this type in another file -

    // index.ts
    import { User } from './example.js';

This will throw an error in case 'verbatimModuleSyntax' is enabled, saying -

    'User' is a type and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled.ts

So, it does not let us import a type using a regular import statement. Instead, we have to use the 'type' modifier in the import statement like this -

    // index.ts
    import type { User } from './example.js';

What if the 'example.ts' file also exports a value along with the type? Like this -

    // example.ts
    export const PI = 3.14;
    export type User = {
        name: string;
        age: number;
    }

In that case, we can import both the value and the type in the 'index.ts' file like this -

    import { PI, type User } from './example.js';

# EFFECTS ON CJS AND ESM

Apart from the general behavior, 'verbatimModuleSyntax' also has specific effects based on the module system being used. It  enforces strict consistency between the module syntax you write and the module kind your project is configured for, preventing TypeScript from transforming imports in ways that could break CJS-ESM compatibility at runtime.

So, let's say we have a file named 'example.cts' with this code -

    export const example = () => {
        return 'Hello World';
    }

So, as we can see, even though this is a 'cts' file, we are still using ESM syntax for the export. So, without 'verbatimModuleSyntax', TypeScript would automatically transform this ESM export into a CJS-compatible export during compilation and this is what we would get as the resulting js -

    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.example = void 0;
    const example = () => {
        return 'Hello World';
    };
    exports.example = example;

So, even though it converts the ESM syntax to CJS-compatible syntax, we are basically writing fake ESM syntax in a CJS module. A better way would be to ensure that inside a CJS module, we only use CJS syntax for imports and exports.

And so, let's see what happens when we enable 'verbatimModuleSyntax' in this case. With 'verbatimModuleSyntax' enabled, we will start getting an error in the IDE for the export statement, saying -

    A top-level 'export' modifier cannot be used on value declarations in a CommonJS module when 'verbatimModuleSyntax' is enabled.

This error is TypeScript's way of enforcing consistency between the module syntax we write and the module kind our project is configured for. It prevents us from writing ESM-style exports in a CJS module, which could lead to confusion and runtime errors.