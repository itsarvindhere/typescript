Let's now talk about a really really important configuration option in TypeScript, the 'module' option.

We already know that the 'target' option specifies the version of JavaScript that TypeScript will output.

So, what does the 'module' option do?

Basically, it is used to set the 'module system' for the code. In most of the cases, you want to use 'nodenext' as its value for modern Node.js projects. When we set the value to 'nodenext', then the emitted JavaScript will either use 'CommonJS' or ESM output depending on the file extension and the value of the 'type' property inside the package.json file.

Also, when 'module' is set to 'nodenext', TypeScript will automatically set 'moduleResolution' to 'nodenext' as well, unless it is explicitly specified in the tsconfig.json file.

Now, there are different values that 'module' option can accept such as 'CommonJS', 'ESNext', 'ES2020', 'AMD', 'UMD', etc. Each of these values corresponds to a different module system in JavaScript.

# The 'CommonJS' module option

For example, let's say we have 'module' set to 'CommonJS' and here is our typescript code (.ts file) -

    import { sayHello } from "./greet";
    sayHello();

When this code is transpiled, the output JavaScript will look like this -

    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const greet_1 = require("./greet");
    (0, greet_1.sayHello)();

So, we can see how it uses 'require' which is specific to the CommonJS module system.

# The 'ESNext' module option

What if we had 'module' set to 'ESNext'? In that case, TypeScript will leave the imports and exports as they are, since ESNext supports native module syntax -

    import { sayHello } from "./greet";
    sayHello();

# WHAT ABOUT FILES WITH 'CTS' AND 'MTS' EXTENSIONS?

Now, what about explicitly having file extensions like 'cts' and 'mts' for our typescript files?

Let's say we have a file names 'abc.cts' which has this code -

    export function greet(name: string): string {
        return `Hello, ${name}!`;
    }

What happens when 'module' is set to 'esnext'? Will Typescript transpile this file to JavaScript with '.js' extension or '.cjs' extension? Well, the answer is '.cjs' extension because 'cts' files are treated as CommonJS modules. So, the output JavaScript will be 'abc.cjs'. And the code in it will not be ES module syntax, but CommonJS syntax.

Similarly, if we have a file named 'xyz.mts' with this code -

    export function greet(name: string): string {
        return `Hello, ${name}!`;
    }

Even when 'module' is set to 'commonjs', the output JavaScript will be 'xyz.mjs' because 'mts' files are treated as ES modules.

So, when using 'cts' and 'mts' file extensions, TypeScript respects the module type implied by the file extension, regardless of the 'module' setting in tsconfig.json.

# The 'type' field in package.json

Another way by which we can specify the module type is by using the 'type' field in package.json file. If we set 'type' to 'module', then all '.js' files will be treated as ES modules and if we set it to 'commonjs', then all '.js' files will be treated as CommonJS modules.

But, if we set 'module' option to 'esnext' or 'commonjs', they do not respect the 'type' field in package.json. So, if we have -

    {
        "type": "module"
    }

Ideally, it means all the 'ts' files should be transpiled to ES modules.

But, what if we have module set to 'commonjs' in tsconfig.json? In that case, TypeScript will still transpile the 'ts' files to CommonJS modules, ignoring the 'type' field in package.json.

Similarly, if we have -
    
    {
        "type": "commonjs"
    }

And if 'module' is set to 'esnext' in tsconfig.json, TypeScript will still transpile the 'ts' files to ES modules, ignoring the 'type' field in package.json.

So, what if we want TypeScript to respect the 'type' field in package.json while transpiling if the extension is '.ts'?

# The 'nodenext' module option

That's where we can use 'nodenext' as the value for 'module' option. When we set 'module' to 'nodenext', TypeScript will check the 'type' field in package.json and transpile the 'ts' files accordingly (unless the file extension is 'cts' or 'mts' which have their own rules as discussed earlier).

So, when 'module' is set to 'nodenext', it provides the most flexibility and is recommended for modern Node.js projects.

Let's say our package.json has this content -

    {
        "type": "commonjs"
    }

And we have a file named 'abc.ts' with this code -

    import { greet } from './commonjs.cjs';
    greet('Hello World');

When we transpile this file with 'module' set to 'nodenext', the output JavaScript will be 'abc.js' and it will use CommonJS syntax because the 'type' field in package.json is set to 'commonjs'.

Similarly, if the 'type' field in package.json was set to 'module', then the output JavaScript would use ES module syntax.

So, that's how the 'module' option works in TypeScript and how it interacts with file extensions and the 'type' field in package.json.

There is another gotcha with the 'nodenext' module option: it enforces the strict rules of the Node.js runtime. When you use this module option, you will need to explicitly specify the final JavaScript file extension in your relative import statements.

Let's say we have a TypeScript file named 'a.ts' that exports something. If we have a file b.ts that imports from 'a.ts', the import statement in 'b.ts' must look like this:

    import { something } from './a.js';

    ❌ Incorrect: import { something } from './a.ts'; (TypeScript does not allow importing its own source extension.)

    ❌ Incorrect: import { something } from './a'; (This fails because Node.js requires the explicit extension in ESM.)

Now, there is another option that is used in conjunction with 'module' option, which is 'moduleResolution'. And this is what we will discuss in the next section.