Namespaces are one of the features introduced in the early days of TypeScript and the main task of them is to organize code in a logical way. They are a TypeScript-specific way to group related code together and avoid polluting the global scope.

Now, this is a feature that you should probably not use in modern TypeScript development. The reason for this is that the JavaScript ecosystem has evolved significantly since TypeScript was first introduced, and now we have better ways to organize and modularize our code, such as ES6 modules.

Let's look at a simple code snippet that uses namespaces -

    namespace GeometryUtils {
        export namespace Circle {
            export function calculateArea(radius: number) {
                // Implementation
            }

            export function calculateCircumference(radius: number) {
                // Implementation
            }
        }

        export namespace Rectangle {
            export interface Rectangle {
                width: number;
                height: number;
            }

            export function calculateArea(rect: Rectangle) {
                // Implementation
            }

            export function calculatePerimeter(rect: Rectangle) {
                // Implementation
            }
        }
    }

So, here we have a 'GeometryUtils' namespace that contains two nested namespaces: 'Circle' and 'Rectangle'. Each of these nested namespaces contains functions and interfaces related to their respective shapes.

So, what is the benefit?

The main benefit of using namespaces is that they help to avoid naming collisions. For example, if you had two functions named 'calculateArea' in the global scope, it would lead to a conflict. By using namespaces, you can have 'GeometryUtils.Circle.calculateArea' and 'GeometryUtils.Rectangle.calculateArea' without any issues.

Now, namespaces can be used a values like this -

    const circleArea = GeometryUtils.Circle.calculateArea(5);
    const rectangleArea = GeometryUtils.Rectangle.calculateArea({ width: 10, height: 5 });

And, they can also be used as types -

    const myRectangle: GeometryUtils.Rectangle = { width: 10, height: 5 };

# MERGING NAMESPACES IN TYPESCRIPT

Just like how interfaces can be merged in TypeScript, namespaces can also be merged. This means that if you declare a namespace with the same name in multiple places, TypeScript will combine them into a single namespace.

So, if we have this piece of code - 

    namespace MyNamespace {
        export function greet() {
            console.log("Hello from MyNamespace!");
        }
    }

    namespace MyNamespace {
        export function farewell() {
            console.log("Goodbye from MyNamespace!");
        }
    }

    MyNamespace.greet(); // Output: Hello from MyNamespace!
    MyNamespace.farewell(); // Output: Goodbye from MyNamespace!

Here, we can see that we have declared the 'MyNamespace' namespace twice, each time adding a different function. When we call 'MyNamespace.greet()' and 'MyNamespace.farewell()', both functions are available because TypeScript has merged the two declarations into a single namespace.

There are some gotchas. In the above code, what if we export one namespace but not the other?

    namespace MyNamespace {
        export function greet() {
            console.log("Hello from MyNamespace!");
        }
    }

    export namespace MyNamespace {
        export function farewell() {
            console.log("Goodbye from MyNamespace!");
        }
    }

Here, the second declaration of 'MyNamespace' is exported, but the first one is not. This will result in an error in the IDE saying - 

    Individual declarations in merged declaration 'MyNamespace' must be all exported or all local.

So, either both declarations should be exported or neither should be exported.

Another gotcha is that the two declarations cannot be in different scopes. Let's say we have -


    namespace MyNamespace {
        export function greet() {
            console.log("Hello from MyNamespace!");
        }
    }
    namespace Test {
        namespace MyNamespace {
            export function farewell() {
                console.log("Goodbye from MyNamespace!");
            }
        }
    }

Here, even though we have two declarations of 'MyNamespace', they are in different scopes. The first one is in the global scope, while the second one is nested inside the 'Test' namespace.

So, if you now try to access properties of 'MyNamespace', you will only see the properties from the first declaration. The second declaration is not merged with the first one because they are in different scopes.

# INTERFACES WITHING NAMESPACES CAN DECLARATION MERGE

We saw that interfaces can be merged in TypeScript. Now, if we have an interface inside a namespace, it can also be merged with another interface of the same name in the same namespace.

Let's say we have -

    namespace GeometryUtils {
            export namespace Rectangle {
                    export interface Rectangle {
                        width: number;
                        height: number;
                    }
            }
    }

    namespace GeometryUtils {
        export namespace Rectangle {
                export interface Rectangle {
                color: string;
            }
        }
    }

Here, we have two declarations of the 'Rectangle' interface inside the 'GeometryUtils.Rectangle' namespace. The first declaration has 'width' and 'height' properties, while the second declaration has a 'color' property.

If we have a variable of type 'GeometryUtils.Rectangle.Rectangle', it will have all three properties: 'width', 'height', and 'color'.

    const myRectangle: GeometryUtils.Rectangle.Rectangle = {
        width: 10,
        height: 5,
        color: "red"
    };

This means that interfaces within namespaces can also be merged, just like standalone interfaces. But, remember that this only works if the interfaces are in the same namespace. If they are in different namespaces, they will not be merged.