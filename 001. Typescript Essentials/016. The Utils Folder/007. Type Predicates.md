Alright, let's talk about one of the more advanced features in TypeScript: 'Type Predicates.'

So far, we have been using different ways to narrow down types, like type assertions. But, we can also create our own custom type guards using type predicates.

To understand this, let's take an example. A lot of time, we create functions that check if certain object has certain properties or meets certain conditions. For example, let's say we want to ensure that an object has a 'data' property which has an 'id' property in it. So, we might have a function that checks this -

    const hasDataAndId = (value: unknown) => {
        return (
            typeof value === 'object' &&
            value !== null &&
            'data' in value &&
            typeof value.data === 'object' &&
            value.data !== null &&
            'id' in value.data &&
            typeof value.data.id === 'string'
        );
    };

At first glance, this function looks fine. It checks if the value is an object, not null, has a 'data' property which is also an object and not null, and finally checks if 'data' has an 'id' property of type string.

So, ideally, this should work wherever we call this function -

    const parseValue = (value: unknown) => {
        if (hasDataAndId(value)) {
            return value.data.id;
        }
    }

Here, we have a function 'parseValue' that takes an 'unknown' value. If 'hasDataAndId' returns 'true', we try to access 'value.data.id'.

This seems like it should work, right?

But TypeScript throws an error here. It says that 'value' is of type 'unknown', and we can't access properties on 'unknown' types.

That's quite interesting because in the 'if' condition, we have already checked that 'value' has the required structure. So, why is TypeScript still complaining?

Another quite interesting thing is that, instead of calling 'hasDataAndId' function, if we directly put the same checks in the 'if' condition, TypeScript is happy and allows us to access 'value.data.id' -

    const parseValue = (value: unknown) => {
        if (typeof value === 'object' &&
            value !== null &&
            'data' in value &&
            typeof value.data === 'object' &&
            value.data !== null &&
            'id' in value.data &&
            typeof value.data.id === 'string') {

            return value.data.id;
        }
    }

So, here, TypeScript understands that within the 'if' block, 'value' has the required structure.

But, why doesn't it work when we use the 'hasDataAndId' function? Because inside the 'hasDataAndId' function, we are doing the same thing, right?

The reason is that 'hasDataAndId' function simply returns a 'boolean'. Just from this 'boolean', TypeScript cannot infer that 'value' has a specific structure.

So, for TypeScript, this function is just -

    const hasDataAndId: (value: unknown) => boolean

And boolean gives zero information about what changed when it became true.

The reason why it worked when we directly put the checks in the 'if' condition is that TypeScript can directly see the checks and understand that within that block, 'value' has a specific structure.

The solution is that we have to explicitly tell TypeScript that 'hasDataAndId' is a type guard function. And this is where we can use 'Type Predicates'.

A predicate takes the form -

    parameterName is Type

where 'parameterName' must be the name of a parameter from the current function signature.

And this should be the return type of our custom type guard function.

So, we can update our 'hasDataAndId' function like this -

    type DataWithId = {
        data: {
            id: string;
        }
    }
    const hasDataAndId = (value: unknown): value is DataWithId => {...}

Here, we are telling TypeScript that if 'hasDataAndId' returns 'true', then 'value' is of type 'DataWithId'.

    const parseValue = (value: unknown) => {
        if (hasDataAndId(value)) {
            return value.data.id;
        }
    }

In this way, when we use 'hasDataAndId' in the 'if' condition, TypeScript will understand that within that block, 'value' has the structure defined in 'DataWithId'.

Now, there are also some downsides of using type predicates. It is possible that we mistakenly use the wrong type in the predicate. For example, if we mistakenly wrote -

    const hasDataAndId = (value: unknown): value is string => {...}

Then, TypeScript will assume that if 'hasDataAndId' returns 'true', then 'value' is of type 'string'. This can lead to incorrect assumptions and potential runtime errors.

Similarly, what if our function was -

    const hasDataAndId = (value: unknown): value is DataWithId => {
        return (
            typeof value === 'object' &&
            value !== null &&
            'data' in value &&
            typeof value.data === 'object'
        );
    };

Note that here, we removed the checks for 'id' property. But still, we kept the return type as 'value is DataWithId'.

Now, TypeScript will assume that if 'hasDataAndId' returns 'true', then 'value' is of type 'DataWithId', even though our function does not actually check for the 'id' property. This can again lead to incorrect assumptions and potential runtime errors.

So, while type predicates are powerful, we need to be careful when using them to ensure that they accurately reflect the checks being performed in the function. This is kind of similar to type assertions, where we need to be careful to ensure that our assertions are correct.

# AUTOMATIC TYPE PREDICATES IN TYPESCRIPT 5.5 AND ABOVE

In TypeScript 5.5 and above, there are now inferred type predicates. This means in most of the cases, TypeScript can automatically infer the type predicate based on the body of the function. Previously, we had to explicitly annotate functions that served as type guards with a special return type syntax, 'parameterName is Type'.

With TypeScript 5.5, the compiler can now automatically infer these type predicates in many common scenarios, eliminating the need for manual annotations and reducing boilerplate code.

But, it does not work for more complex scenarios. In our case as well -

    const hasDataAndId = (value: unknown) => {
        return (
            typeof value === 'object' &&
            value !== null &&
            'data' in value &&
            typeof value.data === 'object' &&
            value.data !== null &&
            'id' in value.data &&
            typeof value.data.id === 'string'
        );
    };

Since the checks are more complex, TypeScript won't infer the type predicate here. So, we still need to explicitly annotate the return type as 'value is DataWithId'.

But, if we had a simpler function like this -

    const isString = (value: unknown) => {
        return typeof value === 'string';
    };

If you hover over 'isString', you will see that TypeScript has inferred the type as -

    const isString: (value: unknown) => value is string

So, here, TypeScript has automatically inferred the type predicate based on the function body.

It can work for a little bit more complex checks like -

    const isObjectWithData = (value: unknown) => {
        return typeof value === 'object' &&
                value !== null &&
                'data' in value;
    };

So, in this case too, the type will be automatically inferred as -

    const isObjectWithData: (value: unknown) => value is object & Record<"data", unknown>

But, if we go one level further like in our original 'hasDataAndId' function, TypeScript won't be able to infer the type predicate -

    
    const isObjectWithData = (value: unknown) => {
            return typeof value === 'object' &&
                    value !== null &&
                    'data' in value &&
                    value.data !== null;
    };

Now, TypeScript won't be able to infer the type predicate here -

    const isObjectWithData: (value: unknown) => boolean

So, remember that for more complex checks, you will still need to explicitly annotate the return type as a type predicate.