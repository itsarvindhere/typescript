Let's say we have a function that takes an array and returns an array with only the unique values - 

    const uniqueArray = (arr: any[]) => {
        return Array.from(new Set(arr));
    }

We can use it like this -

    const result1 = uniqueArray([1,1,2,3,4,4,5]); 
    const result2 = uniqueArray(['a', 'b', 'b', 'c', 'c', 'c']);

But there is one issue right now. Since this function is not generic, the return type is always inferred as 'any[]'. So both 'result1' and 'result2' will have the type 'any[]', which is not ideal.

Let's try to make it a generic function.

We can define a generic type parameter 'T' for the function like this -

    const uniqueArray = <T>(arr: any[]): T[] => {
        return Array.from(new Set(arr));
    }

Here, we are saying that the function 'uniqueArray' has a generic type parameter 'T', and it  returns an array of type 'T'.

Hmm... so, now, if we hover over 'result1' and 'result2', we will see that both are now inferred as 'unknown[]'. So, something has improved, but it's still not perfect.

The reason why we are getting 'unknown' is because while 'uniqueArray' is generic over 'T', we are not passing any information about 'T' when we call the function. The compiler has no way of knowing what 'T' should be. And as we saw in the previous lesson, if we do not provide a type for a generic parameter (and also no default type), it defaults to 'unknown'.

One way is to manually provide the type argument when calling the function, like this -

    const result1 = uniqueArray<number>([1,1,2,3,4,4,5]); 
    const result2 = uniqueArray<string>(['a', 'b', 'b', 'c', 'c', 'c']);

But, there is actually no relationship here between the type parameter 'T' and the function parameter 'arr'. So, we are forced to manually specify the type argument every time we call the function.

In fact, just to prove that point, we can even do this -

    const result1 = uniqueArray<string>([1,1,2,3,4,4,5]); 
    const result2 = uniqueArray<number>(['a', 'b', 'b', 'c', 'c', 'c']);

So, notice that even though we are passing an array of numbers to 'uniqueArray', we are telling the compiler that 'T' is 'string'. And TypeScript is perfectly fine with that. This is because there is no relationship between 'T' and the function parameter 'arr'.

So, we also need to tell TypeScript that the type of 'arr' is related to 'T'. We can do that by changing the type of 'arr' to 'T[]', like this -

    const uniqueArray = <T>(arr: T[]): T[] => {
        return Array.from(new Set(arr));
    }

And now, if we hover over 'result1' and 'result2', we will see that 'result1' is inferred as 'number[]' and 'result2' is inferred as 'string[]'. Perfect!

In fact, we don't even have to explicitly provide the type arguments anymore. TypeScript is able to infer the type arguments based on the arguments we pass to the function. This is due to 'type inference' -

    const result1 = uniqueArray([1,1,2,3,4,4,5]); 
    const result2 = uniqueArray(['a', 'b', 'b', 'c', 'c', 'c']);

So now, 'result1' is inferred as 'number[]' and 'result2' is inferred as 'string[]', just as we wanted!

But, if we do not explicitly provide a type argument, then we can do something like this -

    const result3 = uniqueArray([1,1,2,3,4,4,5, true]); 

And TypeScript will see that the array contains both 'number' and 'boolean' types, so it will infer 'T' as the union type 'number | boolean'. Therefore, 'result3' will be inferred as '(number | boolean)[]'. We may not want that.

So, if we want to avoid such cases, we can always explicitly provide the type argument when calling the function, like this -

    const result3 = uniqueArray<number>([1,1,2,3,4,4,5, true]);

This will now give a type error, because 'true' is not of type 'number'.

So, remember that if we pass a Type Argument explicitly, TypeScript will not try to infer it. It will just use the type we provided. But, if we do not provide a Type Argument, TypeScript will try to infer it based on the arguments we pass to the function, given that those arguments are related to the type parameter in some way.

Finally, we do not need to explicitly provide return type annotation here as well, because TypeScript can infer the return type based on the function implementation and the type parameter 'T'. So, we can simplify the function like this -

    const uniqueArray = <T>(arr: T[]) => {
        return Array.from(new Set(arr));
    }