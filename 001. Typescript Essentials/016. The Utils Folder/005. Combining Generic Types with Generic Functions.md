Let's see how we can combine generic types with generic functions in TypeScript.

Suppose, we have a function that returns an 'async' function and it takes a function as an input. This input function returns a Promise.

    type PromiseFunc = () => Promise<any>;

    const safeFunction = (func: PromiseFunc) => async () => {
        try {
            const result = await func();
            return result;
        } catch (e) {
            if (e instanceof Error) {
                return e
            }
            throw e;
        }
    }

So, far, so good. We have a function named 'safeFunction' that takes a function returning a Promise and returns an async function that handles results and errors.

Cool. 

Now, what if we call this function like -

    const func = safeFunction(async () => {
        if (Math.random() > 0.5) {
            throw new Error("Some error occurred");
        }
        return 123;
    });

Here, we are passing an async function that returns a number (123) or throws an error.

So, looking at this, what do you think the type of 'func' will be? 

If you thought it would be '() => Promise<number | Error>', you are wrong! Right now, it would be -

    () => Promise<any>

Similarly, if we try to get the result -

    const result = await func();

Then, the type of 'result' would be 'any' as well.

This is not ideal.

In fact, if we have a code like this -

    const func2 = safeFunction(() => {
        return Promise.resolve('Hello');
    });

Here, we are passing a function that returns a Promise<string>. But again, the type of 'func2' would be '() => Promise<any>' and the type of the result would be 'any'.

So, how can we fix this problem?

One thing we can see is that the input function to 'safeFunction' is typed as 'PromiseFunc' but right ow, 'PromiseFunc' is not generic. It simply returns 'Promise<any>'.

This is the first hint that we need to make 'PromiseFunc' generic.

Our 'PromiseFunc' type should be able to accept a type parameter that indicates the type of value the Promise resolves to.

So, we can say -

    type PromiseFunc<T> = () => Promise<T>;

This is now a generic type because it accepts a type parameter 'T'. But, is this enough?

Once we make the above change, we start seeing an error for this line -

    const safeFunction = (func: PromiseFunc) => async () => {...}

The error says -

    Generic type 'PromiseFunc<T>' requires 1 type argument(s).

And it makes sense because now 'PromiseFunc' is a generic type and it requires a type argument. But, the type is something that only be inferred from the input function. This means, not only do we need to make 'PromiseFunc' generic, but we also need to make 'safeFunction' generic.

So, we have to do -

    const safeFunction = <T>(func: PromiseFunc<T>) => async () => {...}

Now, we are saying that 'safeFunction' is a generic function that accepts a type parameter 'T'. The input function 'func' is of type 'PromiseFunc<T>', meaning it return a Promise that resolves to type 'T'.

And now, automatically, everything falls into place.

    const func = safeFunction(async () => {
        if (Math.random() > 0.5) {
            throw new Error("Some error occurred");
        }
        return 123;
    })

    type test1 = typeof func; // () => Promise<number | Error>
    const result = await func();
    type test2 = typeof result; // number | Error

    const func2 = safeFunction(() => {
        return Promise.resolve('Hello');
    });

    type test3 = typeof func2; // () => Promise<string | Error>
    const result2 = await func2();
    type test4 = typeof result2; // string | Error

And so, we are now using generic types with generic functions successfully!
