Let's say we have a utility function in our application -

    const createStringMap = () => {
        return new Map();
    }

This function creates and returns a new Map instance. However, the Map is not type-safe because it doesn't specify the types of keys and values it will hold. Right now, it will return a Map<any, any> which is not ideal in TypeScript.

What we want is that the user that uses this function can specify the type of the 'value' that the Map will hold, while the 'key' will always be of type 'string'.

So, we want to make this function a 'Generic Function' where the user can specify the type of the 'value' when they call the function. So, we should be able to use it like this -

    const numberMap = createStringMap<number>();
    const objMap = createStringMap<{ a: number }>();

Here, 'numberMap' should be of type Map<string, number> and 'objMap' should be of type Map<string, { a: number }>.

But right now, our function doesn't support this.

The first though that comes to mind is that since we have to add a Type Parameter to the function, what if we write -

    const createStringMap<T> = () => {
        return new Map<string, T>();
    }

Well, this will show an error because the syntax is incorrect. The correct syntax will be to add the type parameter after the function name like this -

    const createStringMap = <T>() => {
        return new Map<string, T>();
    }

And now, we have a generic function that works as expected. The user can specify the type of the 'value' when they call the function, and the 'key' will always be of type 'string'.

So, if we say -

    const numberMap = createStringMap<number>();

We cannot now do -

    numberMap.set("two", true);

This will show an error saying -

    Argument of type 'boolean' is not assignable to parameter of type 'number'

Similarly, if we have -

    const objMap = createStringMap<{ a: number }>();

We cannot write -

    objMap.set("bar", { b: "hello" });

This will show an error saying -

    Object literal may only specify known properties, and 'b' does not exist in type '{ a: number; }'.

So now, our function is a type-safe generic function that allows the user to specify the type of the 'value' while keeping the 'key' as 'string'.

If we are not using an arrow function, then the syntax will be like this -

    function createStringMap<T>() {
        return new Map<string, T>();
    }

# DEFAULT PARAMETER TYPES FOR GENERIC FUNCTIONS

Now, what happens if we do not specify any type when we call the function? For example -

    const defaultMap = createStringMap();

What do you think will be the type of 'defaultMap'?

Will it be Map<string, any> or Map<string, unknown>?

Well, the correct answer is that it will be Map<string, unknown>.

What if we want to ensure that if the user does not specify any type, then the 'value' type should default to 'string'? Well, as we learned in one of the previous sections, we can provide a default type for the type parameter like this -

    const createStringMap = <T = string>() => {
        return new Map<string, T>();
    }

So now, if we do not specify any type when calling the function -

    const defaultMap = createStringMap();

The type of 'defaultMap' will be Map<string, string>.