Let's now see how we can add constraints to type parameters in generic functions.

Remember that in case of generic types, we were able to add constraints to type parameters using the 'extends' keyword. The same applies to generic functions.

So, let's say we have -

    const UNKNOWN_CODE = 8000;

    const addCodeToError = <TError>(error: TError) => {
        return {
            ...error,
            code: error.code ?? UNKNOWN_CODE,
        };
    };

Here, we have a generic function 'addCodeToError' that takes an error object and adds a 'code' property to it if it doesn't already exist.

Now, right now, it will show an error where we try to access 'error.code' because TypeScript doesn't know if 'TError' has a 'code' property. What if we want to ensure that 'TError' always has a 'code' property?

That's a constraint we can add to the type parameter 'TError' using the 'extends' keyword.

    const addCodeToError = <TError extends { code?: number}>(error: TError) => {...}

Here, we are saying that 'TError' must be an object that might have a 'code' property of type 'number'. Now, TypeScript knows that 'error.code' is valid, and the error goes away.

Note that 'code' is optional here, so 'TError' can be any object, as long as it may or may not have a 'code' property.

Let's say we also want to ensure that 'TError' has a 'message' property of type 'string'.And this one will be a mandatory property so we can modify the constraint like this -

    const addCodeToError = <TError extends { message: string; code?: number}>(error: TError) => {...}

Now, we are telling TypeScript that 'TError' must have a 'message' property of type 'string' and may have a 'code' property of type 'number'.

And since we have added a constraint using 'extends', it also means we can have extra properties in 'TError'. The 'TError' is not restricted to just 'message' and 'code'. It can have any other properties as well. So we can call the function like this -

    const customErrorWithCode = addCodeToError({
        message: 'Oh No!',
        code: 123,
        filePath: './some/file/path',
    });

Here, we have an extra property 'filePath' in the error object, and it's perfectly valid.

This won't be possible if we use type annotation like this -

    const addCodeToError = (error: { message: string; code?: number}) => {...}

In this case, the 'error' parameter can only have 'message' and 'code' properties, and any extra properties will result in a TypeScript error.