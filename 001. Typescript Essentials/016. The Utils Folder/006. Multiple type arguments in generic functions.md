So far, we have been using generic functions with a single type argument. However, TypeScript allows us to define generic functions that accept multiple type arguments. This can be particularly useful when we want to work with multiple types in a single function.

We have done something similar with generic types, but now let's see how to implement this with functions.

Let's take the same example as the previous section -

    type PromiseFunc<T> = () => Promise<T>;

    const safeFunction = <T>(func: PromiseFunc<T>) => async () => {
        try {
            const result = await func();
            return result;
        } catch (e) {
            if (e instanceof Error) {
                return e
            }
            throw e;
        }
    }

Right now, the function that is passed to 'safeFunction' does not take any input as we can see from this type -

    type PromiseFunc<T> = () => Promise<T>;

What if our 'PromiseFunc' needs to take some input? Let's say it is like this -

    type PromiseFunc<TResult> = (...args: any[]) => Promise<TResult>;

So, it can take any number of arguments of 'any' type and return a Promise of type 'TResult'.

And similarly, now, our 'safeFunction' is like this -

    const safeFunction = <T>(func: PromiseFunc<T>) => async (...args: any[]) => {
        try {
            const result = await func();
            return result;
        } catch (e) {
            if (e instanceof Error) {
                return e
            }
            throw e;
        }
    }

So, it takes a function of type 'PromiseFunc<T>' and returns an async function that takes any number of arguments of 'any' type. The arguments that the inner function takes are the same as the arguments that the 'func' takes.

But the problem right now is that we are using 'any' type for the arguments. This means that we lose type safety for the arguments -

    const func = safeFunction((name: string) => {
        return Promise.resolve(`Hello ${name}`);
    });

So, here, we are passing a function that takes a 'string' argument. But since we are using 'any' type for the arguments in 'safeFunction', if we hover over 'func', we will see that ts type is - 

    const func: (...args: any[]) => Promise<string | Error>

So, clearly it is saying that the type of the argument is 'any[]' which is not what we want. We want it to be 'string' as that is what the function we passed takes.

Of course the arguments cannot always be of type 'string'. They can be of any type depending on the function that is passed to 'safeFunction'. So, we need a way to capture the types of the arguments of the function that is passed to 'safeFunction'. This hints at using generic type arguments again.

But, we are already using a generic type argument 'T' to capture the return type of the function. So, we need to use multiple type arguments here.

Can we use multiple type arguments in generic functions? Yes, we can! Just like in case of generic types, we just need to separate the type arguments with a comma.

First, we need to make our type 'PromiseFunc' accept two type arguments - one for the return type and one for the argument types -

    type PromiseFunc<TArgs, TResult> = (...args: TArgs) => Promise<TResult>;

Here, 'TArgs' is a tuple type that represents the types of the arguments that the function takes.

For example, if we have a function that takes a 'string' and a 'number' as arguments, then the type of 'TArgs' will be '[string, number]'. But right now, TypeScript does not know that 'TArgs' is a tuple type.

Right now, it will show an error -

    A rest parameter must be of an array type.

We have to explicitly tell TypeScript that 'TArgs' is a tuple type by constraining it to extend 'any[]' -

    type PromiseFunc<TArgs extends any[], TResult> = (...args: TArgs) => Promise<TResult>;

We could've also done -

    type PromiseFunc<TArgs, TResult> = (...args: TArgs[]) => Promise<TResult>;

But this would not have been correct because here, 'TArgs' is not constrained to be an array type. Here we are saying that 'TArgs' can be any type and we are using it as an array type. This would lead to incorrect inference of types. We will see more about this later.

Anyways, we can update our 'safeFunction' to accept two type arguments as well -

    const safeFunction = <TArgs, TResult>(func: PromiseFunc<TArgs, TResult>) => async (...args: TArgs) => {
        try {
            const result = await func(...args);
            return result;
        } catch (e) {
            if (e instanceof Error) {
                return e
            }
            throw e;
        }
    }

But now, there is another error saying -

    Type 'TArgs' does not satisfy the constraint 'any[]'

This time, it is for the type argument 'TArgs' in the generic function. We need to add the same constraint here as well -

    const safeFunction = <TArgs extends any[], TResult>(func: PromiseFunc<TArgs, TResult>) => async (...args: TArgs) => {
        try {
            const result = await func(...args);
            return result;
        } catch (e) {
            if (e instanceof Error) {
                return e
            }
            throw e;
        }
    }

And now, there are no errors!

Now, if we have -

    const func = safeFunction((name: string) => {
        return Promise.resolve(`Hello ${name}`);
    });

If you check the type of 'safeFunction', you will see that it is -

    const safeFunction: <[name: string], string>(func: PromiseFunc<[name: string], string>) => (...args: [name: string]) => Promise<string | Error>

Notice that the first type argument that 'safeFunction' is using is a tuple type '[name: string]'. This is because the function that we passed to 'safeFunction' takes a single argument of type 'string'. This is all thanks to the constraint that we added to 'TArgs' to extend 'any[]'.

If you hover over 'func', you will see that the type is -

    const func: (name: string) => Promise<string | Error>

And similarly, if we have -

    const result2 = await func('world');

Then, the type of 'result2' will be inferred as 'string | Error'.

So, this is how we can use multiple type arguments in generic functions in TypeScript!

# WHY DIDN'T WE USE TARGS[] INSTEAD OF CONSTRAINING TARGS TO EXTEND any[]?

If we had something like -

    type PromiseFunc<TArgs, TResult> = (...args: TArgs[]) => Promise<TResult>;

Here, 'TArgs' is not constrained to be an array type but we are using it to tell TypeScript that the function can take any number of arguments of type 'TArgs'. This would lead to incorrect inference of types.

So, our 'safeFunction' would look like -

    const func = safeFunction((name: string) => {
        return Promise.resolve(`Hello ${name}`);
    });

And now, if you hover over 'func', you will see that the type is -

    const func: (...args: string[]) => Promise<string | Error>

So, TypeScript is inferring the type of the argument as 'string[]' instead of 'string'. This means that 'func' can take any number of 'string' arguments which is not what we want. We know that we have written 'func' to take only one 'string' argument. But, just because of the way we have defined 'PromiseFunc', TypeScript is inferring the type incorrectly.

Let's again understand how TypeScript is inferring the type of 'TArgs extends any[]' correctly.

Let's say this is function that we pass to 'safeFunction' -

    const foo = async (x: number, y: string): Promise<boolean> => true;

So, we use it like  -

    const func = safeFunction(foo);

Now, typescript tries to infer the types of 'TArgs' and 'TResult' from the type of 'foo'.

    Type of foo -> (x: number, y: string) => Promise<boolean>
    Type of PromiseFunc -> (...args: TArgs) => Promise<TResult>;

So, it tries to resolve this -

    (...args: TArgs)  ==  (x: number, y: string)

The only solution that fits positionally is:

    TArgs = [number, string]
    TResult = boolean

Remember that TypeScript always infers the parameter lists as tuples, not as any[]. And this is something we saw in one of the previous sections where we used the 'Parameters' utility type. The 'Parameters' utility type also infers the parameter list as a tuple type.

TypeScript doesn’t “assume” 'TArgs' is a tuple — it infers it as a tuple because function parameter lists are inferred positionally, and (...args: TArgs) preserves that structure, while TArgs[] destroys it.

So, the bottom-line is -

    - TArgs extends any[] → “This is some array”
    - (...args: TArgs) → “Spread it as parameters”
    - Passing a real function → TypeScript infers a tuple
    - Using TArgs[] → Forces uniform array and destroys tuple info