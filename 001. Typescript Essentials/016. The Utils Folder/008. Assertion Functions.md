There’s a specific set of functions that throw an error if something unexpected happened. They’re called “assertion” functions.

As an example, Node.js has a dedicated function for this called assert.

    assert(someValue === 42);

In this example if someValue isn’t equal to 42, then assert will throw an AssertionError.

Assertions in JavaScript are often used to guard against improper types being passed in. For example,

    function multiply(x, y) {
        assert(typeof x === "number");
        assert(typeof y === "number");
        return x * y;
    }

But, in TypeScript, these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.

For that reason, TypeScript 3.7 introduced a new concept called “Assertion Signatures” which model these assertion functions.

In our TypeScript application, we can create our own assertion functions to help with type narrowing and ensuring certain conditions are met at runtime. For example, if we have two interfaces -

    interface User {
        id: string;
        name: string;
    }

    interface AdminUser extends User {
        roles: string[];
    }

We might have to check at various places that the 'user' is an 'Admin'. And for that, we might create a function like this:

    function assertIsAdminUser(user: User | AdminUser) {
        if (!("roles" in user)) {
            throw new Error("User is not an Admin");
        }
    }

So, this function checks if the 'user' has the 'roles' property. If not, it throws an error.

Let's say we are calling it like this -

    const handleRequest = (user: User | AdminUser) => {
        console.log(user);

        assertIsAdminUser(user); // Should narrow the type to AdminUser after this line

        console.log(user.roles); // ERROR! Property 'roles' does not exist on type 'User | AdminUser'.
    }

What do you think will be the type of 'user' in the first and second console.log statements?

If you thought that in the first console.log, 'user' would be of type 'User | AdminUser', and in the second console.log, it would be of type 'AdminUser', you are wrong!

Right now, TypeScript does not understand that the 'assertIsAdminUser' function is an assertion function. It just sees it as a regular function that might throw an error.

One thing that comes to mind is to use a 'Type Predicate' -

    function assertIsAdminUser(user: User | AdminUser): user is AdminUser {
        if (!("roles" in user)) {
            throw new Error("User is not an Admin");
        }
    }

But this will result in an error -

    A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.

Remember that 'Type Predicates' are only used for functions that return a boolean value. Since our function does not return anything (it either completes successfully or throws an error), we cannot use a type predicate here. Even if this function returned something other than a boolean, we would still not be able to use a type predicate. Because, Type Predicates are specifically designed for functions that return boolean values to indicate type narrowing.

So, how do we tell TypeScript that this function is an assertion function?

That's where we can use the 'asserts' keyword in the return type of the function.

So, we can say -

    function assertIsAdminUser(user: User | AdminUser): asserts user is AdminUser {
        if (!("roles" in user)) {
            throw new Error("User is not an Admin");
        }
    }

Here, we are telling TypeScript that if this function completes without throwing an error, then 'user' can be treated as an 'AdminUser'.

And now, if we look back at our 'handleRequest' function -

    const handleRequest = (user: User | AdminUser) => {
        console.log(user);

        assertIsAdminUser(user); // Now TypeScript knows that 'user' is an 'AdminUser' after this line

        console.log(user.roles); // No error! 'user' is now of type 'AdminUser'
    }

Now, TypeScript understands that after the call to 'assertIsAdminUser', 'user' is guaranteed to be an 'AdminUser', and we can safely access the 'roles' property without any errors.

But, just like 'Type Predicates', you need to be really careful while using assertion functions. If you mistakenly assert something that isn't true, you might end up with runtime errors that TypeScript can't catch for you. So, if we had -

    function assertIsAdminUser(user: User | AdminUser): asserts user is AdminUser {
        // Incorrect assertion
        if ("roles" in user) {
            throw new Error("User is not an Admin");
        }
    }

Here, we are incorrectly asserting that if 'roles' is in 'user', then 'user' is not an 'AdminUser'. This would lead to incorrect type narrowing and potential runtime errors.