Alright, let's dive into function overloading in TypeScript!

What is Function Overloading? In general programming terms, function overloading refers to the ability to create multiple functions with the same name but different parameters. TypeScript allows us to achieve this by defining multiple function signatures for a single function implementation.

Let's say we have a 'sum' function that either takes an object with the two values it has to add or it takes two separate numbers as parameters. We can define it like -

    function sum(valuesOrA: {a : number; b: number} | number, b?: number): number {
        if (typeof valuesOrA === 'object') {
            return valuesOrA.a + valuesOrA.b;
        }

        return valuesOrA + (b ?? 0);
    }

So, here, the 'sum' function can be called in two different ways -

    console.log(sum({ a: 5, b: 10 })); // Output: 15
    console.log(sum(5, 10));           // Output: 15

The first call passes an object with properties 'a' and 'b', while the second call passes two separate numbers.

In this way, this single 'sum' function can handle different types of input, making it versatile and easier to use in various scenarios.

But, there is one issue right now. We can still call it like this -

    sum({a: 1, b: 2}, 3); // This will not throw any error, but it's not a valid use case.

So, here, we are passing both an object and a number, which doesn't make sense for our 'sum' function.

In fact, we can also call it like -

    sum(1); // This will also not throw any error, but it's not a valid use case.

Here, we are passing only one number, which again doesn't make sense for our 'sum' function.

So ideally, we should we getting a warning if we try to call the function in an invalid way.

In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function.

So, what are the different ways we can call our 'sum function? We know that there are two ways -

    1. Passing an object with properties 'a' and 'b'.
    2. Passing two separate numbers.

So, we can define two function signatures before the actual implementation of the function like this -

    function sum(values: { a: number; b: number }): number;
    function sum(a: number, b: number): number;
    function sum(valuesOrA: { a: number; b: number } | number, b?: number): number {
        if (typeof valuesOrA === 'object') {
            return valuesOrA.a + valuesOrA.b;
        }

        return valuesOrA + (b ?? 0);
    }

And boom! Now, if we try to call the function in an invalid way, TypeScript will throw an error.

If we write -

    sum({ a: 1, b: 2 }, 3);

The error would be -

    Argument of type '{ a: number; b: number; }' is not assignable to parameter of type 'number'.

So, TypeScript sees that since we are passing two arguments, it should match the second overload signature, which expects two numbers. But since we are passing an object as the first argument, it throws an error.

Similarly, if we write -

    sum(1);

The error would be -

    Argument of type 'number' is not assignable to parameter of type '{ a: number; b: number; }'.

So, TypeScript sees that since we are passing one argument, it should match the first overload signature, which expects an object with properties 'a' and 'b'. But since we are passing a number, it throws an error.

# SOME IMPORTANT NOTES

The signatures that we write before the actual implementation of the function are called 'Overload Signatures'.

The actual implementation that we write after the overload signatures is called the 'Implementation Signature'. 

If there are overload signatures, only those get exposed to the callers of the function. The implementation signature is not visible to the callers. This means if we have -

    function sum(values: {a: number; b: number}): number;
    function sum(a: number, b: number): number;
    function sum(valuesOrA: {a : number; b: number} | number, b?: number): number {
        if (typeof valuesOrA === 'object') {
            return valuesOrA.a + valuesOrA.b;
        }

        return valuesOrA + (b ?? 0);
    }

Then, we cannot call -

    sum(1);

Even though this call matches the implementation signature, it does not match any of the overload signatures, so TypeScript will throw an error. That's because only the overload signatures are exposed to the outside world.

The 'Implementation Signature' should be compatible with the overload signatures. This means that the parameters and return type of the implementation signature should be able to handle all the cases defined in the overload signatures.

So, we cannot write -

    function fn(x: boolean): void;
    function fn(x: string): void; // ERROR
    function fn(x: boolean) {
        ...
    }

This will show an error for the overload signature where we are passing a string, because the implementation signature only accepts a boolean.

The correct way would be -

    function fn(x: boolean): void;
    function fn(x: string): void;
    function fn(x: boolean | string) {
        ...
    }

So here, the implementation signature accepts both boolean and string, which is compatible with both overload signatures.

The same is the case with return types. We cannot have -

    function fn(x: boolean): boolean;
    function fn(x: string): string; // ERROR
    function fn(x: boolean | string) {
        return true;
    }

Notice that here, the implementation signature returns a boolean, which is not compatible with the overload signature that expects a string.

## ALWAYS PREFER PARAMETERS WITH UNION TYPES INSTEAD OF OVERLOADS WHEN POSSIBLE

This is something that the official TypeScript documentation also suggests. If we can achieve the same functionality using parameters with union types, then we should prefer that over overloads.

For example, let's say we have a function that returns the length of a string or an array. We can define it using overloads like this -

    function len(s: string): number;
    function len(arr: any[]): number;
    function len(x: string | any[]): number {
        return x.length;
    }

So here, we have two overload signatures - one for strings and one for arrays.

There are correct -

    len(""); // OK
    len([0]); // OK

But, what about -

    len(Math.random() > 0.5 ? "hello" : [0]); // ERROR

Here, TypeScript will throw an error because it cannot determine which overload signature to use. The argument could be either a string or an array, and TypeScript cannot resolve this ambiguity. Remember that TypeScript can only resolve a function call to a single overload.

Here, because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function -

    function len(x: string | any[]): number {
        return x.length;
    }

And now, all the calls will be valid -

    len(""); // OK
    len([0]); // OK
    len(Math.random() > 0.5 ? "hello" : [0]); // OK

So, whenever possible, prefer using parameters with union types instead of overloads, as it leads to simpler and more maintainable code.

But, there are cases when overloads are necessary.

For example -

    function twoVals(a: number, b: number): boolean;
    function twoVals(a: string, b: string): boolean;
    function twoVals(a: number | string, b: number | string) {
        return true;
    }

Here, the 'twoVals' function can be called in two different ways -

    twoVals(1, 2);           // OK
    twoVals("hello", "world"); // OK

But, we cannot call it like -

    twoVals(1, "world"); // ERROR
    twoVals("hello", 2); // ERROR

We want to ensure that both parameters are of the same type - either both numbers or both strings.

So, here, TypeScript will throw an error because neither of the overload signatures match the arguments we are passing.

Here, if we had not used overloads, and just defined the function like -

    function twoVals(a: number | string, b: number | string) {
        return true;
    }

Then, all the calls would have been valid -

    twoVals(1, 2);           // OK
    twoVals("hello", "world"); // OK
    twoVals(1, "world");     // OK
    twoVals("hello", 2);     // OK

And if we wanted to restrict the function to only accept either two numbers or two strings, we would have had to write additional type checks inside the function body, which would have made the code more complex. So, this is one situation where overloads are useful.