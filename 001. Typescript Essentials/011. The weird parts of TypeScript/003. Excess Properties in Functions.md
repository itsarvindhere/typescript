Let's say we have an interface -

    interface User {
        id: number;
        name: string;
    }

And we have an array of objects with each object having a name only -

    const users = [
        {
            name: 'Arvind'
        },
        {
            name: 'John'
        }
    ];

This is quite common in real world applications where we have a list of users with only names and we generate the 'id' on the fly.

Let's say we have a function that adds an id to a user -

    const usersWithIds: User[] = users.map((user, index) => ({
        id: index,
        ...user,
        age: 30
    }));

Now, this function not only adds an 'id' to each user but also adds an extra property 'age'.

But still, even though we told TypeScript that the resulting array will be of type 'User[]', it doesn't complain about the extra property 'age'. Again, this is because of the way TypeScript handles excess properties in functions.

Right now, TypeScript is okay with this because all the required properties of the 'User' interface are present in the resulting objects. The extra property 'age' is simply ignored.

So, what can we do to fix it?

Well, one way would be to take out the function that we pass to 'map' and define it separately and then give it an explicit return type of 'User'. This way, TypeScript will enforce that the function returns an object that conforms to the 'User' interface.

    const addIdsToUsers = (user: { name: string }, index: number): User => ({
        id: index,
        ...user,
        age: 30 // ERROR
    });
    
    const usersWithIds: User[] = users.map(addIdsToUsers);

And now, we will start seeing an error on the 'age' property because it is not part of the 'User' interface.

But, again, we can break it. What if we have -

    const addIdsToUsers = (user: { name: string }, index: number): User => {
        const modifiedUser = {
            id: index,
            ...user,
            age: 30 // NO ERROR
        };
        return modifiedUser ;
    };

Here, all we did was create a new variable 'modifiedUser' and assigned the object to it. And now again, there is no error on the 'age' property. So, now TypeScript is not enforcing the return type of the function. The fix? Well, we again need to type this 'modifiedUser' variable explicitly as 'User'.

    const addIdsToUsers = (user: { name: string }, index: number): User => {
        const modifiedUser: User = {
            id: index,
            ...user,
            age: 30 // ERROR
        };
        return modifiedUser ;
    };

Now, what if we do not want to extract the function and want to keep it inline? In that case, we can use a 'satisfies' to tell TypeScript that we want to treat the object as a 'User'.

    const usersWithIds: User[] = users.map((user, index) => ({
        id: index,
        ...user,
        age: 30 // ERROR
    } satisfies User));

Or, we can add a return type to the inline function -

    const usersWithIds: User[] = users.map((user, index): User => ({
        id: index,
        ...user,
        age: 30 // ERROR
    }));

So, those are some ways we can make TypeScript enforce excess property checks in functions.