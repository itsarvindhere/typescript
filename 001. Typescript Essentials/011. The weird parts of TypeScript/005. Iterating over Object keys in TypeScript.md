What if we have an object in TypeScript and we want to print all its keys?

Let';s say we have an interface 'User': 

    interface User {
        id: number;
        name: string;
    }

And, we have a function that takes a 'User' object and prints it:

    function printUser(user: User) {
        console.log(user.id);
        console.log(user.name);
    }

Well, this will work. But, what if we have a lot of keys in the 'User' interface? It will be tedious to write 'console.log' for each key.

How do we iterate over the keys of the object in TypeScript?

Maybe, we can use a 'for...in' loop:

    function printUser(user: User) {
        for (let key in user) {
            console.log(user[key]);
        }
    }

But, surprisingly, this will show an error for 'user[key]'. The error will be:

    Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'User'.
        No index signature with a parameter of type 'string' was found on type 'User'.

Here, TypeScript is basically saying -

    Hold on â€” key is a string, but only 'id' and 'name' are valid keys for User.

And so, it is not allowing us to access 'user[key]'.

So, how do we fix this issue? Well, we know for sure that 'key' will only be 'id' or 'name'. So, we can use a type assertion to tell TypeScript that 'key' is actually a key of 'User':

    function printUser(user: User) {
        for (const key in user) {
            console.log(user[key as keyof User]);
        }
    }

Here, we are telling TypeScript that 'key' is actually a key of 'User'. So, there will be no error.

Another way would be to use 'Object.keys' -

    function printUser(user: User) {
        Object.keys(user).forEach(key => {
            console.log(user[key as keyof User]);
        });
    }

Another option would be to widen the type of the 'user' itself instead of type asserting 'key':

    function printUser(user: Record<string, any>) {
        for (const key in user) {
            console.log(user[key]);
        }
    }

So now, the 'user' is no longer of type 'User', but of type 'Record<string, any>'. So, there will be no error.

And it makes sense here because this method simply iterates over the keys of the object and prints them. It does not care about the actual type of the object. We are not doing anything that is specific to the 'User' type. So, we do not care what are the exact keys of the object. We just want to iterate over them.

We can also make this function generic:

    function printObject(obj: Record<string, any>) {
        for (const key in obj) {
            console.log(obj[key]);
        }
    }