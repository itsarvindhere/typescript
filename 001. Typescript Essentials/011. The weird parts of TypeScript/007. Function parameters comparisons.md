Let's say we have this code -

    type Event = 'click' | 'hover' | 'scroll';

    type CallbackType = unknown;

    const listenToEvent = (callback: CallbackType) => {};

    listenToEvent(() => {});
    listenToEvent((event) => {
        event
    });

    listenToEvent((event, x , y) => {
        event
        x
        y
    });

    listenToEvent((event, x , y, screenId) => {
        event
        x
        y
        screenId
    });

Here, we have a function 'listenToEvent' that takes a callback as a parameter. The callback can have varying numbers of parameters.

Now, the 'CallbackType' is defined as 'unknown'. This means that TypeScript does not have any information about the parameters of the callback function. As a result, we can pass in functions with any number of parameters, and TypeScript will not raise any errors.

So, how should we define the type of 'CallbackType' to ensure that the callback function can have varying numbers of parameters, but we still want to maintain some type safety?

One way that comes to mind is to write something like this -

    
    type CallbackType = ((event: Event) => void) | ((event: Event, x: number, y: number) => void) | ((event: Event, x: number, y: number, screenId: string) => void);

So, here, we are defining 'CallbackType' as a union of function types with different parameter lists. This way, TypeScript will allow us to pass in functions that match any of these signatures.

But, somehow, we still see errors in the code above. Why is that?

More specifically, the error shows up only for these -

    listenToEvent((event) => {
        event
    })

    listenToEvent((event, x , y) => {
        event
        x
        y
    })

If we only have -

    type CallbackType = ((event: Event) => void) 

The error now shows up for -

    listenToEvent((event, x , y) => {
        event
        x
        y
    })

    listenToEvent((event, x , y, screenId) => {
        event
        x
        y
        screenId
    })

Similarly, if we have -

    type CallbackType = ((event: Event, x: number, y: number) => void)

Now, the error only shows up for -

    listenToEvent((event, x , y, screenId) => {
        event
        x
        y
        screenId
    })

Finally, if we have -

    type CallbackType = ((event: Event, x: number, y: number, screenId: string) => void)

Then, there are no errors at all.

What is this sort of behavior? How is this comparison of function parameters happening in TypeScript?

The thing is, when we are implementing the function, the function does not have to pay attention to the extra parameters that are passed in.

The only time we have to pay attention to the parameters is when we are calling the 'callback' function inside the 'listenToEvent' function.

So, just because a function has to be called with certain parameters does not mean that the function itself has to implement all those parameters.

To understand this better, lets take a look at the 'map' function that is available on arrays -

    const numbers = [1, 2, 3];

    const strings = numbers.map((number) => { // only 1 parameter
        return number.toString();
    });

    const strings2 = numbers.map((number, index) => { // 2 parameters
        return `${index} - ${number.toString()}`;
    });

    const strings3 = numbers.map((number, index, array) => { // 3 parameters
        return `${index} - ${number.toString()} - ${array.length}`;
    });

So, the map function can call the callback function with 1, 2 or 3 parameters. But, the callback function itself does not have to implement all those parameters. If we look at the type of the callback inside the 'map' function -

    callbackfn: (value: number, index: number, array: number[])

We can see that the callback function is defined to take 3 parameters. But, when we are implementing the callback function, we can choose to only implement the first parameter, or the first two parameters, or all three parameters.
