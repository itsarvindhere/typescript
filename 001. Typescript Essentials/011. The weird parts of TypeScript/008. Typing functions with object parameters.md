Let's say we have this code -

    const logId = (obj: { id: string }) => {
        console.log(obj.id);
    }

    const logName = (obj: { name: string }) => {
        console.log(obj.name);
    }
    const loggers = [logId, logName];

    const logAll = (obj) => {
        loggers.forEach((func) => func(obj));
    }

    logAll({id: '1', name: 'Arvind'});

Here, we have two functions 'logId' and 'logName' that expect an object with a specific property. We then have an array of these functions and a 'logAll' function that takes an object and calls each function in the array with that object.

Now, for now, our 'obj' passed to 'logAll' is not typed so it implies 'any'. So, what type we should give to 'obj'? Well, maybe we can give it a union type where the object can have either 'id' or 'name' property -

    const logAll = (obj: { id: string } | { name: string }) => {
        loggers.forEach((func) => func(obj));
    }

But, this will show an error saying -

    Argument of type '{ id: string; } | { name: string; }' is not assignable to parameter of type '{ id: string; } & { name: string; }'.
        Type '{ id: string; }' is not assignable to type '{ id: string; } & { name: string; }'.
            Property 'name' is missing in type '{ id: string; }' but required in type '{ name: string; }'.

Basically, it is saying that the parameter type of 'func' is '{ id: string; } & { name: string; }' which means an object that has both 'id' and 'name' properties. But, our union type '{ id: string } | { name: string }' means an object that can have either 'id' or 'name' property. So, this is not assignable.

An interesting thing is that if you hover over the 'func' parameter inside the callback function, its time will be -

    (parameter) func: ((obj: {
        id: string;
    }) => void) | ((obj: {
        name: string;
    }) => void)

So, at this point, it is a union of two function types.

But, when you hover over 'func' when it is being called, its type will be -

    (parameter) func: (obj: {
        id: string;
    } & {
        name: string;
    }) => void

Now, instead of a union of two function types, it is a single function type that takes an object with both 'id' and 'name' properties.

This is because TypeScript is trying to find a common type that satisfies both function types in the union.

So, it means, the correct type will be -

    const logAll = (obj: { id: string; name: string }) => {
        loggers.forEach((func) => func(obj));
    }

Quite interesting, right?

In fact, if you remove any callback functions and directly try to call 'logId' or 'logName' with the union type, it will show the same error if we have -
   
    const logAll = (obj: { id: string } | { name: string }) => {
        logId(obj); // ERROR
        logName(obj); // ERROR
    }

So, here as well, it is trying to find a common type that satisfies both function types. But right now, we have a union type that does not satisfy both function types.

So, the correct type will be -

    const logAll = (obj: { id: string; name: string }) => {
        logId(obj); // No Error
        logName(obj); // No Error
    }