Let's say we have this piece of code -

    type PossibleErrors = SyntaxError | DOMException;

    const getUserFromLocalStorage = (id: string) => {
        const user = localStorage.getItem(id);
        if (!user) {
            return undefined;
        }

        return JSON.parse(user);
    }

    try {
        const user = getUserFromLocalStorage('123');
    } catch(e) {
        
    }

Here, we have a function 'getUserFromLocalStorage' that retrieves a user from local storage and parses it as JSON. The 'JSON.parse' method can throw a 'SyntaxError' if the string is not valid JSON. Additionally, accessing 'localStorage' can throw a 'DOMException' in certain scenarios, such as when the storage quota is exceeded.

In languages like Java, we can annotate functions to specify which exceptions they might throw -

    public User getUserFromLocalStorage(String id) throws SyntaxError, DOMException {
        // function implementation
    }

But in TypeScript, how do we annotate the errors that a function might throw?

Because right now, if you hover over the 'e' in the catch block, TypeScript infers its type as 'unknown'. This means we don't have any information about what kind of error it is, making it difficult to handle specific error types.

You might think that why not just use 'PossibleErrors' type in the catch block like this -

    catch(e: PossibleErrors) {

    }

But, surprisingly, TypeScript does not allow us to annotate the type of 'e' in the catch block. You will see an error message -

    Catch clause variable type annotation must be 'any' or 'unknown' if specified.

This means, we just cannot specify the type of errors in the catch block directly. All we can type 'e' as is 'unknown' or 'any'.

Well, what we can do is that we can define a return type for our 'getUserFromLocalStorage' function that either returns an object with a success result or an object with an error -

    type PossibleErrors = SyntaxError | DOMException;

    type FuncReturnType = 
        | {
            success: true,
            data: any
        } 
        | {
            success: false,
            error: PossibleErrors
        }

    const getUserFromLocalStorage = (id: string): FuncReturnType => {
        try {
            const user = localStorage.getItem(id);
            if (!user) {
                return {
                    success: true,
                    data: undefined
                };
            }

            return {
                success: true,
                data: JSON.parse(user)
            }

        } catch (error) {
            if (error instanceof DOMException) {
                return {
                    success: false,
                    error
                }
            };

            if (error instanceof SyntaxError) {
                return {
                    success: false,
                    error
                }
            }

            throw error;
        }
    }

So, now, our function 'getUserFromLocalStorage' returns an object that indicates whether the operation was successful or if there was an error, along with the relevant data or error information. This way, we can handle errors more gracefully without relying on the catch block's error type annotation.

Now, whoever calls this function can check the 'success' property to determine if the operation was successful or if there was an error, and handle it accordingly.

    
    const user = getUserFromLocalStorage('123');

    if (user.success) {
        console.log('User:', user.data);
    } else {
        console.error('Error occurred:', user.error);
    }

So, that's a way to annotate and handle errors thrown by a function in TypeScript! Either we can use narrowing in the catch block to determine the type of error, or we can design our functions to return a structured result that includes error information.