Let's say we have this code -

    let selectedId = 1;
    selectedId = '123'; // Error: Type 'string' is not assignable to type 'number'.

Maybe we do not want this behavior. We want the 'selectedId' variable to be able to hold any type of value. That is, it should evolve to hold any type of value.

Well, we can simply make one change here.

We can declare the variable without an initial value.

    let selectedId;
    selectedId = 1; // OK
    selectedId = '123'; // OK

And now, the variable can hold any type of value. If you hover over the variable, you will see that it is of type 'any'.

The interesting thing is that, after we set the value of the variable to a number, if you use this variable, it will be of type 'number'. Similarly, after we set the value of the variable to a string, if you use this variable, it will be of type 'string'.

    let selectedId;
    selectedId = 1; // OK

    selectedId.toFixed(1) // OK because selectedId is of type 'number' here
    
    selectedId = '123'; // OK

    selectedId.toUpperCase(); // OK because selectedId is of type 'string' here

This is a completely different behavior than when we explicitly set the type of the variable to 'any'. If we had used 'any' explicitly -

    let selectedId: any;
    selectedId = 1; // OK

    selectedId.toFixed(1) // selectedId is of type 'any' here
    
    selectedId = '123'; // OK

    selectedId.toUpperCase(); //  selectedId is of type 'any' here

Here, we can see that the variable is always of type 'any', no matter what value we assign to it. So, we can call any method on it, and TypeScript will not complain.

Basically, in this case, we are disabling type checking for this variable.

But, that is not the case when we do -

    let selectedId;
    selectedId = 1; // OK
    selectedId = '123'; // OK

In this case, the type checking still exists and you can verify it by trying to use a string method on the variable after assigning it a number value. TypeScript will complain that the method does not exist on type 'number'.

This is what we call as an 'Evolving any'. The variable starts with type 'any' but as we assign values to it, its type evolves to the type of the assigned value.

# ARRAYS

The evolving any is also there with array decalrations.

When we declare an array without an initial value -

    let items = [];

Initially, TypeScript infers the type of the array as 'any[]'.

But, when we start pushing values to the array, the type of the array evolves to the type of the values being pushed.

    let items = [];
    items.push(1);  // Type is number[]
    items.push('Hello'); // Type is (string | number)[]