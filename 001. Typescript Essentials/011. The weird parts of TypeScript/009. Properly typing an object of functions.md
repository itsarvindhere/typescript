In the last section, we saw how we can type the function parameters properly when the parameters are objects.

What about objects with functions?

Let's say we have this object -

    const obj = {
        string: (input: string) => input.toUpperCase(),
        number: (input: number) => input.toFixed(2),
        date: (input: Date) => input.toISOString(),
        boolean: (input: boolean) => input ? "YES" : "NO"
    }

And we have a function -

    const format = (input: string | number | boolean) => {
        const inputType = typeof input as 'string' | 'number' | 'boolean';
        const formatter = obj[inputType];

        return formatter(input);
    }

This function is supposed to take a string, number or boolean and return the formatted value using the 'obj' object.

The code seems fine as we are properly checking the type of input and then using that to get the right function from the 'obj' object and then calling it.

But, when we call 'formatter(input)' we are getting an error in the IDE -

    Argument of type 'string | number | boolean' is not assignable to parameter of type 'never'.
        Type 'string' is not assignable to type 'never'

Wait, what?

If we hover over the 'formatter' when we are calling it with 'input', we see its type is -

    const formatter: (input: never) => string

So, TypeScript thinks that the 'formatter' function takes a parameter of type 'never'.But, that is wrong, right? It should be taking either a string, number or boolean.

There does not seem to be any issue with the 'obj' as its type is inferred as -

    const obj: {
        string: (input: string) => string;
        number: (input: number) => string;
        boolean: (input: boolean) => "YES" | "NO";
    }

In fact, if you hover over the 'formatter' when it is assigned as value, you see its type is -

    const formatter: ((input: string) => string) | ((input: number) => string) | ((input: boolean) => "YES" | "NO")

So, here, the type of 'formatter' is a union of functions that take either a string, number or boolean.

So, why does the type change when we call it?

Well, as we saw in the previous section, when we have a union of function types and we try to call it, TypeScript tries to find a common type for the parameters that satisfies all the function types in the union.

In our case, we have a union of functions which is a type for 'formatter' variable -

    ((input: string) => string) | ((input: number) => string) | ((input: boolean) => "YES" | "NO")

So, TypeScript will try to find a common type for the 'input' parameter that satisfies all three function types. And this type will be an intersection like this -

    string & number & boolean

But, since there is no type that can be both string, number and boolean at the same time, the common type will be 'never'.

And that's why, when we call 'formatter(input)', the type of 'formatter' changes to -

    (input: never) => string

It is basically like saying -

    (input: string & number & boolean) => string

So, while our code works at runtime, TypeScript is not able to understand it properly and shows an error. Well, the fix for it is crazy - 

    return formatter(input as never);

Yep, you read it right. We have to assert the type of 'input' to be 'never'. And now, the error goes away.

We cannot say 'as any' because 'any' is not assignable to 'never'. Only 'never' is assignable to 'never'.

Of course, there is another way to fix it and it is to first check the type of input and then call the function -

    const format = (input: string | number | boolean) => {
        if (typeof input === 'string') {
            return obj.string(input);
        } else if (typeof input === 'number') {
            return obj.number(input);
        } else {
            return obj.boolean(input);
        }
    }

So, in this case, we do not have to worry about the type of 'formatter' as we are directly calling the functions from the 'obj' object by first checking the type of 'input'. But it is not as elegant as the previous solution as we have to manually check the type and call the right function.

So, from all of this, we can understand that when we have function types that are unions, we have to be careful when calling them as TypeScript will try to find a common type for the parameters that satisfies all the function types in the union. And this common type can sometimes be 'never' which can lead to confusing errors. Sometimes we will need to assert the type to 'never' to make the error go away.