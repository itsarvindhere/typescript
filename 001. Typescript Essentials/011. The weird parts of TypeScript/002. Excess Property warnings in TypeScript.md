Let's say we have an interface -

    interface FetchOptions {
        url: string;
        method?: string;
        headers?: Record<string, string>;
        body?: string;
    }

And we have an object -

    const options = {
        url: "https://api.example.com/data",
        method: "GET",
        headers: { "Content-Type": "application/json" },
        search: new URLSearchParams({
            limit: "10"
        })
    };

We have not typed it so we are letting TypeScript infer the type of this object. It infers the type as -

    const options: {
        url: string;
        method: string;
        headers: {
            "Content-Type": string;
        };
        search: URLSearchParams;
    }

Let's say we have a function which accepts an argument of type 'FetchOptions' -

    const myFetch = async (options: FetchOptions) => {};

What do you think will happen if we try to pass the 'options' object to this function?

    myFetch(options);

Well, we should see an error because the 'options' object has an extra property 'search' which is not defined in the 'FetchOptions' interface. But, somehow, we don't see any error! Somehow, TypeScript is okay with this.

Why is TypeScript not complaining about the extra property 'search'?

As we saw in case of an empty object type, there is a hierarchy of types in TypeScript. And in this hierarchy, an object type is considered to be a subtype of another object type if it has at least the same properties as the other type. This means that an object type can have extra properties and still be considered a subtype of another object type.

In our case, the type of the 'options' object has all the properties of the 'FetchOptions' interface and an extra property 'search'.

So, TypeScript considers it to be a subtype of 'FetchOptions' and allows it to be passed to the 'myFetch' function. Yes, it does not have 'body' property but that is okay because it is an optional property.

And that's why we don't see any error. Because, even though there is an extra property, this is still a valid subtype of 'FetchOptions' as it has all the required properties of 'FetchOptions'.

One way to fix this is to explicitly tell TypeScript that the options is of type 'FetchOptions' -

    const options: FetchOptions = {
        url: "https://api.example.com/data",
        method: "GET",
        headers: { "Content-Type": "application/json" },
        search: new URLSearchParams({ // ERROR
            limit: "10"
        })
    };

Now, we are explicitly telling TypeScript that the 'options' object is of type 'FetchOptions'. So, it will only allow the properties that are defined in the 'FetchOptions' interface and will show an error for any extra property.

Another way to fix it is to directly pass the object to the function -

    myFetch({
        url: "https://api.example.com/data",
        method: "GET",
        headers: { "Content-Type": "application/json" },
        search: new URLSearchParams({ // ERROR
            limit: "10"
        })
    });

If we do this, TypeScript will show an error for the extra property 'search' because it is not defined in the 'FetchOptions' interface and the method 'myFetch' expects an argument of type 'FetchOptions'.

And of course, if we want TypeScript to infer the type automatically but we still want to see an error for extra properties, we can use 'satisfies' -

    const options = {
        url: "https://api.example.com/data",
        method: "GET",
        headers: { "Content-Type": "application/json" },
        search: new URLSearchParams({ // ERROR
            limit: "10"
        })
    } satisfies FetchOptions;

The bottom-line is that Excess Property warnings are not present in Typescript by default. We can trigger them by using one of the above methods.