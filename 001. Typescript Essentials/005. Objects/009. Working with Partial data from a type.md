Sometimes, we have a type but we only want to use some of its properties.

For example, let's say we have an interface 'User' like this -

    interface User {
        id: string;
        name: string;
        email: string;
        role: string;
    }

And suppose, this is an interface we use throughout our application.

Let's say we have an api from which we fetch user details but it only returns us the email and the name of the users -

    const fetchUser = async (): Promise<User> => {
        const response = await fetch('/api/user');
        const user = await response.json();
        return user;
    }

Now, here, we are saying that our function returns a Promise which eventually resolves to a 'User' object. But, we only need some of the properties from the 'User' type, specifically 'email' and 'name'.

One way would be to create a new type that only includes the properties we need -

    interface UserResponse {
        name: string;
        email: string;
    }

    const fetchUser = async (): Promise<UserResponse> => {...}

Another way would be to use 'extends' -

    interface NameAndEmail {
        name: string;
        email: string;
    }

    interface User extends NameAndEmail {
        id: string;
        role: string;
    }

     const fetchUser = async (): Promise<NameAndEmail> => {...}

This will work, but there is one more way and that's to use 'Pick' utility type provided by TypeScript.

# PICK

The syntax is -

    Pick<Type, Keys>

So, when we use it, it will create a type by picking a set of properties 'Keys' from the 'Type'. 'Keys' can be string literal or a union of string literals.

So, in our case, we want to pick the 'name' and 'email' properties from our 'User' interface so we can write -

    Pick<User, 'name' | 'email'>

This returns a new type so we can write -

    type UserResponse = Pick<User, 'email' | 'name'>;

And now, it does the same thing as before.

If you hover over 'Pick', it will show -

    type Pick<T, K extends keyof T> = { [P in K]: T[P]; }

So, behind the scenes, this is what TypeScript is doing. It basically creates a new type by iterating over the keys 'K' and picking the corresponding properties from the original type 'T'.

In our case, we have 'email' and 'name' as the keys, so it creates a new type with just those properties from the 'User' type.

And so, that's the power of the 'Pick' utility type in TypeScript. It allows us to create new types by selecting specific properties from existing ones, making our code more flexible and easier to work with.

The benefit is that, let's say in future, we changed some type definition in our 'User' interface. For example, if we changed name to -

    name: {
        first: string;
        last: string;
    }

In that case, 'Pick' will automatically pick the new structure of the 'name' property, and our 'UserResponse' type will reflect that change without us having to modify it manually.

Do note that 'Pick' works for objects. It won't work for union types so, you cannot write -

    Pick<'a' | 'b', 'a'>

It makes sense because behind the scenes, 'Pick' is using the keys of the object type to create a new type. Since union types don't have keys in the same way objects do, 'Pick' can't operate on them.

If 'keyof' is used to a union type then it only returns the keys that are common between the types in the union. For example, if we have -

    type X = { type: string; foo: string } | { type: number, bar: string }

Here, there is a common 'type' property between the two types in the union. So, when we write -
    type CommonKeys = keyof X;

The type of 'CommonKeys' will simply be 'type' because it is the only key that is present in both types of the union.

That's why, if we say -

    type Keys = Pick<X, 'type' | 'foo'>

This will show an error because while 'type' is present in both types, 'foo' is not present in the second type.

There is a workaround for this. We can use some other Utility type for this same thing that works for union types but we will explore that later.
