Let's say we have this piece of code -

    const scores = {};

    scores.math = 95;
    scores.english = 90;
    scores.science = 85;

This looks like a valid code in JavaScript but in TypeScript, you will see errors in the IDE -

    Property 'math' does not exist on type '{}'.
    Property 'english' does not exist on type '{}'.
    Property 'science' does not exist on type '{}'.

That's because when we defined 'scores' object as an empty object, TypeScript infers its type as {} which means it is an object with no properties. That's why, when we try to access any property using the 'dot' notation, it gives us an error.

One way would be to use the 'square brackets' notation to define the properties dynamically:

    const scores = {};

    scores['math'] = 95;
    scores['english'] = 90;
    scores['science'] = 85;

This will no longer give us an error in TypeScript and it will add the properties to the object dynamically.

But, what if we do not want to change the code where we update the object? We just want to update the line where we define 'scores' object. Well, let's try to give it some type so that it can accept dynamic keys. Since we do not know the key names beforehand, we cannot say -

    const scores: {math?: number, english?: number, science?: number} = {};

What if we want to add more keys later? We cannot just keep updating the type definition every time we add a new subject.

# RECORD

Another way to define the type would be to use a 'Record' type -

    type Scores = Record<string, number>;
    const scores: Scores = {};

So, what is this 'Record' type?

Well, it was introduced in TypeScript 2.1 and it is one of the 'Utility Types' in Typescript that we will know more about later. Basically, for some common use cases, TypeScript offers some 'Utility Types' that can help us with common type transformations. The 'Record' type is one of them.

The syntax is -

    Record<Keys, Type>

It constructs an object whose property keys are 'Keys' and values are 'Type'. So, when we write -

    type Scores = Record<string, number>;
    const scores: Scores = {};

We are saying that 'scores' can have any number of properties, as long as the keys are strings and the values are numbers.

And this is one of the ways in which we can have dynamic keys.

# INDEX SIGNATURES

We can also use something called an 'index signature' to do the same thing. This is useful when we do not know all the names of a type's properties ahead of time, but we do know the shape of the values.

In our case, we do not know the name of the subjects beforehand, but we do know that the scores are all numbers. So we can define the type like this:

    type Scores = { [subject: string]: number };
    const scores: Scores = {};

This says that 'scores' can have any number of properties, as long as the 'subject' is a string and the value is a number.

Now, there are some interesting things to note with 'Index Signatures'. We cannot do this -

    type Scores = { [subject: string]: number; [grade: string]: number };

Because here, we are basically duplicating the index signatures. Both the index signatures mean the same thing that is, if the key is a string, the value should be a number.

But, we can do something like this -

    type Scores = { [subject: string]: number; [grade: number]: number };

This will not show any error but here again, there is one gotcha. We cannot write -

    type Scores = { [subject: string]: number; [grade: number]: string };

Note how the 'string' indexer will have a 'number' value but a 'number' indexer will have a 'string' value. The reason why this shows an error is because when we index with a 'number', JavaScript actually converts that number to a string before indexing into an object. It means, if we write -

    scores[0] = 100;

It actually is the same thing as  -

    scores['0'] = 100;

And that's why, when we use both 'number' and 'string' indexers, the type returned from a numeric indexer must always be a subtype of the type returned from a string indexer.

There is another gotcha with index signatures. If we have -

    type NumberDictionary = {
         [index: string]: number;
         length: number;
    }

This is fine because in our index signature we are saying that the object can have any number of properties with string keys and number values. So, even if we have a 'length' property, since it is following the same pattern as the index signature, it is allowed.

But, we cannot write -

    type NumberDictionary = {
         [index: string]: number;
         length: string; // ERROR
    }

This will show an error saying -

    Property 'length' of type 'string' is not assignable to 'string' index type 'number'.

One way to fix this is to have a union of types for the index signature like this -

    type NumberDictionary = {
         [index: string]: number | string;
         length: string;
    }

Now, we are saying that the object can have any number of properties with string keys and values that can be either numbers or strings. So, the 'length' property is allowed because it is a string, which is part of the union type.

Finally, we can use interfaces to achieve the same effect. For example:

    interface Scores {
         [index: string]: number;
    }