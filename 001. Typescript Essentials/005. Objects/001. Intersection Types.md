We have already seen the 'Union' of types which we do using the pipe (|) operator.

With a Union type, we create a type that can be one of several types.

What if, we have two object types and we want to create a new type that is a combined type of the two?

For example, if we have -

    type A = {
        a: string;
    }

    type B = {
        b: number;
    }

Let's say we want a third type 'C' which is a combination of 'A' and 'B', meaning it has 'a' and 'b' in it as the properties where 'a' is a string and 'b' is a number. 

And that is something we can do using 'Intersection Types'. We use an ampersand (&) to combine the two types.

    type C = A & B;

Now, if we have some object that is of type 'C', then it should have both 'a' and 'b' properties in it because none of the two are optional.

If we had a union type like A | B, it would've meant that the new object should have either 'a' or 'b' (or both) but not necessarily both.

So, we can say that an intersection type combines multiple types into one.

Let's say we have these two types -

    type User = {
        id: string;
        email: string;
        name: string;
        createdAt: Date;
    }

    type Product = {
        id: string;
        name: string;
        price: number;
        createdAt: Date;
    }

We can see that both these have some common properties like 'id' and 'createdAt'. So, we can extract these common properties into a base type and then use that base type in both 'User' and 'Product'.

Let's create a base type called 'BaseEntity' that has the common properties:

    type BaseEntity = {
        id: string;
        createdAt: Date;
    }

Now, we can use this 'BaseEntity' type in both 'User' and 'Product':

    type User = BaseEntity & {
        email: string;
        name: string;
    }

    type Product = BaseEntity & {
        name: string;
        price: number;
    }

This way, we have reduced duplication and made our code more maintainable.