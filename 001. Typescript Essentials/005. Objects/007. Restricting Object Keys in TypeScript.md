Let's say we have a type -

    type Environment = "development" | "production" | "staging";

And we have an object 'configurations' of type 'Configuration' -

    type Configurations = unknown;

    const configurations: Configurations = {
        development: {
            apiBaseUrl: "http://localhost:8080",
            timeout: 5000
        },
        production: {
            apiBaseUrl: "https://api.example.com",
            timeout: 10000
        },
        staging: {
            apiBaseUrl: "https://staging.example.com",
            timeout: 8000
        },
        notAllowed: {
            apiBaseUrl: "https://staging.example.com",
            timeout: 8000
        }
    }

At this point, 'Configuration' type is simply unknown. This means, when we define a 'configurations' object, we can add any keys we want without TypeScript complaining. What if we want to restrict the keys here? What if we only want the keys to be either 'development', 'production', or 'staging'?

One way is to manually create a type like this -

    type Configurations = {
        development: {
            apiBaseUrl: string;
            timeout: number;
        };
        production: {
            apiBaseUrl: string;
            timeout: number;
        };
        staging: {
            apiBaseUrl: string;
            timeout: number;
        };
    };

Well, this is too much of work. Imagine if we want to add one more type to 'Environment'. That will require us to update the 'Configurations' type as well. That is not a good approach.

Since all the keys should be of the same type - 'Environment', you might think that we can use 'index signature' here like this -

    type Configurations = {[key: Environment]: { apiBaseUrl: string; timeout: number }};

Well, this won't work because if you hover over the error shown in the IDE, it says -

    An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.

It is worth mentioning that only a few types are allowed for the index signature properties - string, number, and symbol. We can also have union types but only those union types that consist of these three only. We cannot have literal types or generic types. That's why we get the error above.

But, this error also suggests us that we should consider using something called 'Mapped types'. But, there is also another way to fix this error. Remember the 'Record' type that we discussed earlier? We can use it to achieve the same result.

# RECORD TYPE

A record type is a utility type in TypeScript that we can use when we want to create an object with keys of a specific type and values of a specific type. The syntax for a record type is as follows:

    Record<Keys, Type>

Where 'Keys' is the type of the keys and 'Type' is the type of the values. Since we know that we want the keys to be of type 'Environment' in our case, we can simply write -

    type Configurations = Record<Environment, {
        apiBaseUrl: string;
        timeout: number;
    }>;

    const configurations: Configurations = {
        ...
    };

So, it means that 'configurations' object will only allow objects where keys are of type 'Environment' and the values must match the specified shape. And since we also have a key named 'notAllowed', there will be an error in the IDE saying -

    Object literal may only specify known properties, and 'notAllowed' does not exist in type 'Configurations'.

# MAPPED TYPES

Mapped types have a similar syntax as index signatures. We can use a mapped type to apply some rules to all the properties of a type. Doesn't make much sense? Well, let's say we have -

    type User = {
        id: number;
        name: string;
        active: boolean;
    };

What if we want to make the properties of the User type optional? One way is to manually create a type like this -

    type UserOptional = {
        id?: number;
        name?: string;
        active?: boolean;
    };

But this is not a scalable solution. If we have a large type with many properties, it can be tedious to make each property optional individually. This is where mapped types come in handy.

We can use a mapped type to transform the properties of the User type like this -

    type UserOptional = {
        [K in keyof User]?: User[K];
    };

Let's break it down -

    1. keyof User -> gives all the keys of User that is, "id" | "name" | "active"
    2. K in keyof User -> iterates over each key in User
    3. User[K] -> gets the type of each property in User

There are actually some built-in mapped types in TypeScript but that's something we'll cover later.

Coming back to our initial problem, we fixed the issue with a 'Record' type. But, do you know that a 'Record' type is also one of the built-in 'Mapped Types' which are provided by TypeScript?

Behind the scenes, 'Record' is doing something like this -

    type Configurations = {
        [Env in Environment]: {
            apiBaseUrl: string;
            timeout: number;
        }
    }

So, here, 'Env in Environment' means to iterate over all the possible values of the 'Environment' type and create a corresponding property in the 'Configurations' type for each value.

This is just an overview of how mapped types work in TypeScript.