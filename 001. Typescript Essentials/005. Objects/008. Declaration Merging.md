In the section where we discussed the difference between Types and Interfaces, we understood that if we have two interfaces with the same name in the same scope, TypeScript will merge them into a single interface. 

This is known as 'Declaration Merging'.

Well, this can cause issues as well. Let's say we have this piece of code -

    interface Logger {
        log(message: string, level: number): void;
    }


    interface Logger {
        log(message: string): void;
    }

    const myLogger: Logger = {
        log: (message: string) => {
            console.log("Message is -> ", message);
        }
    };

Here, we are defining the interface 'Logger' two times. Both definitions have a 'log' method but while one takes a message and a level as arguments, the other takes only the message.

Then, we have an object of type 'Logger' which implements the second definition of the 'log' method.

So, if we try to call the log method like this -

    myLogger.log('Hello World'); 

This works fine.

But, what if we try -

    myLogger.log('Hello World', 10); 

Well, there is no error at all! Even though our 'myLogger' object only implements the second definition of the log method, TypeScript allows us to call it with both parameters.

If you hover over the 'myLogger' object, the type will be shown as -

    const myLogger: {
        log(message: string, level: number): void;
        log(message: string): void;
    }

So, even though our 'myLogger' object only implements the second definition of the log method, TypeScript allows us to call it with both parameters.

To understand it better, let's add a new property to each of the two interfaces -

    interface Logger {
        log(message: string, level: number): void;
        a: string;
    }


    interface Logger {
        log(message: string): void;
        b: string;
    }

    const myLogger: Logger = {
        log: (message: string) => {
            console.log("Message is -> ", message);
        }
    };

Both definitions have a 'log' method but one has a property 'a' and the other has a property 'b'. If you are not familiar with declaration merging then upon looking at the code above, you may think that 'b' is the only property that we have to worry about. However, due to declaration merging, both properties 'a' and 'b' are actually part of the 'Logger' interface. And that's why, TypeScript shows an error saying -

    Type '{ log: (message: string) => void; }' is missing the following properties from type 'Logger': a, b

So, both 'a' and 'b' are actually part of the 'Logger' interface that we need to implement in our 'myLogger' object.

So, if this is so confusing, why does TypeScript even allow declaration merging in the first place? The main reason is to provide flexibility and to enable a more modular approach to defining types. It allows developers to extend existing interfaces without having to modify the original definition, which can be particularly useful in large codebases or when working with third-party libraries. This is something we will explore further in the upcoming sections.