While having Intersection Types is quite useful, this is not the most effective way to create objects that inherit from other objects. There is a more effective way and that's using the 'interface' keyword instead of 'type'.

So, instead of writing -

    type BaseEntity = {
        id: string;
        createdAt: Date;
    }

We can write -

    interface BaseEntity {
        id: string;
        createdAt: Date;
    }

Notice how we have used the 'interface' keyword and there is no longer an equals to sign.

So, how do we create a 'User' interface which has some properties and also inherits the properties from 'BaseEntity'? While you may think that we can use ampersand (&) to achieve this, in interfaces, we use the 'extends' keyword.

Here's how we can do it:

    interface User extends BaseEntity {
        email: string;
        name: string;
    }

    interface Product extends BaseEntity {
        name: string;
        price: number;
    }

This way, 'User' and 'Product' interfaces inherit the properties from 'BaseEntity' and also have their own specific properties.

Do note that we can use an ampersand(&) between interfaces to create new types -

    type User = { email: string; name: string; } & BaseEntity;

But, we cannot do -

    interface User = { email: string; name: string; } & BaseEntity;

In general, interfaces are preferred to describe the shape of objects in TypeScript, as they provide a clear and concise way to define the structure of data. As we know, almost everything in JavaScript is an object and 'interface' is built to match their runtime behavior.

We are not limited to extending a single interface. We can also implement multiple interfaces in a single class or object. This allows for greater flexibility and reusability of code.

Let's say we have two different interfaces like this -

    interface WithId {
        id: string;
    }
        
    interface WithCreatedAt {
        createdAt: Date;
    }

We can now create interfaces that 'extend' both these interfaces -

    interface User extends WithId, WithCreatedAt {
        email: string;
        name: string;
    }

    interface Product extends WithId, WithCreatedAt {
        name: string;
        price: number;
    }

So, if you have worked with an object-oriented programming language before, you might find this approach familiar. By using interfaces, we can create a clear and organized structure for our objects, making it easier to manage and maintain our code.