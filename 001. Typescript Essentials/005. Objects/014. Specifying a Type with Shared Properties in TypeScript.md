Let's try an interesting problem.

Suppose, we have three interfaces - 

    interface User {
        id: string;
        name: string;
        age: number;
        imageId: string;
    };


    interface Organization {
        id: string;
        name: string;
        address: string;
        imageId: string;
    }

    interface Product {
        id: string;
        name: string;
        price: number;
        imageId: string;
    }

We can see that all these have some properties in common - 'id', 'name', and 'imageId'.

Let's say we have a method that fetches the image using the imageId -

    const getAvatarImage = (entity: unknown) => {
        return {
            url: `https://example.com/avatars/${entity.imageId}`,
            alt: `${entity.name} Avatar`
        }
    }

At this point, this will throw an error in the IDE because 'entity' is unknown. The problem here is that we want to give it a type that has all the common properties of all the three interfaces. We should not be able to access 'price', 'age', or 'address' since those are not common properties of the three interfaces.

That is, that type should be like -

    interface Entity {
        id: string;
        name: string;
        imageId: string;
    }

But, we do not want to manually create this interface. We have to use all the things we learnt so far.

There are various ways to do this. We can use 'Pick' here since we know that 'Pick' is not distributive which means when we pass it a Union type, it will pick the common properties. So, when we say -

    type Entity = Pick< User | Organization | Product, 'name' | 'imageId' | 'id'>;

We are saying that we want a type that has only the 'name', 'imageId', and 'id' properties from the the union type ' User | Organization | Product'.

We can also make it cleaner

    type UnionType = User | Organization | Product;
    type Entity = Pick<UnionType, keyof UnionType>;

Remember that when we use 'keyof' operator on a Union Type it will return all the 'common' properties among all the types in the union. In this case, it will return 'id', 'name', and 'imageId' as the common properties.

But, there is one way that is even simpler than all these and that is to just say -

    type Entity = User | Organization | Product;
    const getAvatarImage = (entity: Entity) => {...}

Wait, what?

How does it work?

Well, remember that when we say 'User | Organization | Product', we are creating a union type. This means we can safely say entity.name or entity.imageId without any TypeScript errors, because all three types in the union have those properties.

But, if we want to use other properties like 'age' or 'address', we will get a TypeScript error because those properties are not guaranteed to exist on all types in the union. So, for those properties, we have to explicitly narrow down the type using a type guard or a type assertion.