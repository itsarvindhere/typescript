Let's say we have three types -

    type User = {
        id: string;
        name: string;
        age: number;
        imageId: string;
    }

    type Organization = {
        id: string;
        name: string;
        address: string;
        imageId: string;
    }

    type Product = {
        id: string;
        name: string;
        price: number;
        imageId: string;
    }

Now, we see that we have three types, all with three properties in common - id, name, and imageId. What if, we have a type that is a union of these three types?

    type Entity = User | Organization | Product;

So, Entity will be like this -

    type Entity = {
        id: string;
        name: string;
        age: number;
        imageId: string;
    } | {
        id: string;
        name: string;
        address: string;
        imageId: string;
    } | {
        id: string;
        name: string;
        price: number;
        imageId: string;
    }

It is the union of all three types, which means it can represent any one of them.

Now, what if we want the 'Entity' type but without the 'id' property? That is, we want something like -

    type EntityWithoutId = {
        name: string;
        age: number;
        imageId: string;
    } | {
        name: string;
        address: string;
        imageId: string;
    } | {
        name: string;
        price: number;
        imageId: string;
    }

Well, why not use 'Omit here, right? Let's try that -

    type EntityWithoutId = Omit<Entity, 'id'>;

Interestingly, when we hover over 'EntityWithoutId', we see that the type is -

    type EntityWithoutId = {
        name: string;
        imageId: string;
    }

Wait, what? Isn't it supposed to include the other properties as well? And that's one thing to keep in mind with 'Omit'.

It does not behave the same with Union types(even if it is a union of object types) as it does with normal object types.

We know that behind the scenes, Omit is -

    type Omit<T, K extends keyof any> = { [P in Exclude<keyof T, K>]: T[P]; }

Ignore 'Exclude' for now. Inside it, we use 'keyof T'.

In our case, 'T' is a union of object types, so 'keyof T' should ideally give us all the keys from all the object types in the union. However, what actually happens is that 'keyof T' gives us the keys that are common across all object types in the union. That's how 'keyof' works with unions. And that's the reason why when we use 'Omit' on the union type, it only returns a type which has the common keys from all the union types except for 'id'.

This means that 'Omit' is not 'Distributive' over union types. This means that it does not apply to each member of the union individually, but rather to the union as a whole. As a result, we only get the common keys from all the types in the union, rather than the keys from each individual type.

And the same is the case with 'Pick'. If you write -

    type EntityWithPrice = Pick<Entity, 'price'>;

This will show an error saying -

    Type '"price"' does not satisfy the constraint '"id" | "name" | "imageId"'

This means, Pick allows us to select only from three properties - 'id', 'name', and 'imageId' - which are common across all object types in the union.

What if we do not use 'keyof' in case of unions? Let's try to create a 'DistributiveOmit' type -

    type DistributiveOmit<T, K extends PropertyKey> = T extends any ? Omit<T, K>: never;

This is sort of confusing at first but we will get in more detail when we learn about generics.