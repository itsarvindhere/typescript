In the last section, we learnt about 'Partial' utility type which allows us to make all properties of a type optional.

What if we have an opposite case of that? That is, we want to make all the properties of a type Optional.

Let's say we have -

    interface Coordinates {
        x?: number;
        y?: number;
    }

What if we want to use this interface somewhere but we want to make all its properties as required?

Well, there is a utility type called 'Required' in TypeScript which can make all properties of a type required.

Its syntax is simply -

    Required<Type>

It creates a new type which has all the properties of 'Type' but they are set to required. So, all we need to do is wrap our 'Coordinates' interface inside 'Required' -

    type CoordinatesRequired = Required<Coordinates>;

Now, 'CoordinatesRequired' will have all properties as required.

Behind the scenes, it does this -

    type Required<T> = { [P in keyof T]-?: T[P]; }

It means, it takes all properties of 'T' and makes them required by removing the optional modifier (the '?'). Notice that little minus sign (-) before the question mark. It is removing the optionality from the properties.

It is worth mentioning that 'Required' only works on the top level of the object. If there are nested properties, they will not be affected by the 'Required' utility type.

This means, if we have -

    interface User {
        id: number;
        name: string;
        address?: {
            street?: string;
            city: string;
        };
    }

    type UserRequired = Required<User>;

Here, 'UserRequired' will be -

    {
        id: number;
        name: string;
        address: {
            street?: string;
            city: string;
        };
    }

So, as we can see, the nested properties are not affected by the 'Required' utility type. This is one thing worth noting when using this utility type.