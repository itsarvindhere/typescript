In the last section, we learned about the 'Pick' utility type in TypeScript, which allows us to create new types by selecting specific properties from existing ones.

What if, we have to select all but some?

Let's say we have an interface -

    interface Person {
        id: string;
        name: string;
        email: string;
        age: number;
    }

We have a function 'addProduct' -

    const addProduct = (productInfo: Product) => {
        // Implementation for adding a product
    }

The thing is, when we add a new product, we do not pass an 'id'. It is generally generated automatically. So, how can we have a type that has all the properties of 'Product' except for 'id'?

# OMIT

Well, one way is to again use interfaces and extends keyword. But, like 'Pick', we have an opposite of that named 'Omit'. 

As the name suggests, 'Omit' allows us to create a new type by omitting certain properties from an existing type.

The syntax is -

    Omit<Type, Keys>

This will create a type by picking all the properties from 'Type' and removing the specified 'Keys'. In our case, we can say -

    type ProductWithoutId = Omit<Product, 'id'>;

And now we can use this new type in our function:

    type ProductWithoutId = Omit<Product, 'id'>;

    const addProduct = (productInfo: ProductWithoutId) => {
        // Implementation for adding a product
    }

Behind the scenes, Omit does this -

    type Omit<T, K extends keyof any> = { [P in Exclude<keyof T, K>]: T[P]; }

It creates a new type by picking all properties from the original type 'T' and excluding the ones specified in 'K'

This in turn uses 'Exclude' which is also a utility type but we will not go into its details here.

# A QUIRK OF OMIT

One interesting thing to note is that in 'Omit', it is possible to pass keys that do not even exist in the original type. For example:

We could do -

    type ProductWithoutId = Omit<Product, 'asdasdasd'>;

This will not throw any error at all.

But, we cannot do the opposite of this with Pick. That is, we cannot pick any non-existent keys from the original type.

    type NonExistentKey = Pick<Product, 'nonExistentKey'>;

This will throw an error -

    Type '"nonExistentKey"' does not satisfy the constraint 'keyof Product'

So, you need to be a bit careful when using 'Omit' because it won't show any error if you omit a non-existent key. You might misspell a key and it will not be caught by the compiler.