Let's say we want to access the specific values of an 'as const' object.

Suppose, we have -

    export const programModeEnumMap = {
        GROUP: 'group',
        ANNOUNCEMENT: 'announcement',
        ONE_ON_ONE: 'one_on_one',
        SELF_DIRECTED: 'self_directed',
        PLANNED_ONE_ON_ONE: 'planned_one_on_one',
        PLANNED_SELF_DIRECTED: 'planned_self_directed',
    }

    type ProgramModeMap = typeof programModeEnumMap;
    type Group = unknown;

At this point, 'Group' is just an 'unknown' type. We want to derive the type of 'group' from the 'programModeEnumMap' object. In this way, if we change the value in the object, the type will automatically reflect that change.

Ideally, we want to do something like this -

    type Group = 'group';

Now, before we do this, let's say we simply want to get the value of the 'GROUP' key from the 'programModeEnumMap' object. How do we do that in plain JavaScript?

Well, as we know, we simply do -

    const groupValue = programModeEnumMap['GROUP'];

And this also ensures that if we change the value of the 'GROUP' key in the 'programModeEnumMap' object, the 'groupValue' variable will automatically reflect that change.

Well, the same is the case with TypeScript types as well. Since we have the type of the 'programModeEnumMap' object as 'ProgramModeMap', we can simply do -

    type Group = ProgramModeMap['GROUP'];

Yes, it is that simple!

Anyways, if you hover over the 'Group' type, you will see that it is now of type 'group' -

    type GroupMode = "group";

Remember that since we had an 'as const' assertion on the 'programModeEnumMap' object, the values are treated as literal types. If we did not have the 'as const' assertion, the values would be treated as general string types, and the 'Group' type would be 'string' instead of 'group'.

We can do it in one line as well -

    type Group = typeof programModeEnumMap['GROUP'];

There is actually a name for such types in TypeScript. These are called 'Indexed Access Types'. We can use an indexed access type to look up a specific property on another type. Remember that you can only use 'Types' with indexed access types, not 'Values'.

So, we cannot say -

    const groupString = 'GROUP';
    type Group = ProgramModeMap[groupString]; // This will throw an error

We can use type aliases. For example -

    type GroupType = 'GROUP';
    type Mode = ProgramModeMap[GroupType];

Another thing to note is that with object values, we can also use dot notation to access the specific value -

    const groupValue = programModeEnumMap.GROUP;

But, in case of object types, we cannot use dot notation. We have to use the bracket notation as shown above.

All of this opens up a lot of possibilities. 

Let's say we want to create a type that represents the 'Planned' modes only. We can ofcourse do that like this -

    type PlannedMode = ProgramModeMap['PLANNED_ONE_ON_ONE'] | ProgramModeMap['PLANNED_SELF_DIRECTED'];

Now, if you hover over 'PlannedMode' type, the type will be -

    type PlannedMode = "planned_one_on_one" | "planned_self_directed"

Since the indexing type (whatever is inside the brackets) is simply a type, it means we can pass anything between the brackets which is a type or returns a type. And that includes a union type as well. So, we can do -

    type PlannedMode = ProgramModeMap['PLANNED_ONE_ON_ONE' | 'PLANNED_SELF_DIRECTED'];

And this will give us the same result as above.

We can even use 'keyof' operator to get all the keys of the 'ProgramModeMap' type and use that as the indexing type -

    type AllModes = ProgramModeMap[keyof ProgramModeMap];

This works because as we know, 'keyof' returns a union of all the keys in the object type.

Now, if you hover over 'AllModes' type, the type will be -

    type AllModes = "group" | "announcement" | "one_on_one" | "self_directed" | "planned_one_on_one" | "planned_self_directed"

This is really powerful as it allows us to derive types directly from values, ensuring that our types always stay in sync with our values.

If we try to use an indexing type that does not exist in the object type, TypeScript will throw an error. For example -

    type InvalidMode = ProgramModeMap['INVALID_KEY'];

This throws an error saying -

    Property 'INVALID_KEY' does not exist on type '{ readonly GROUP: "group"; readonly ANNOUNCEMENT: "announcement"; readonly ONE_ON_ONE: "one_on_one"; readonly SELF_DIRECTED: "self_directed"; readonly PLANNED_ONE_ON_ONE: "planned_one_on_one"; readonly PLANNED_SELF_DIRECTED: "planned_self_directed"; }'.