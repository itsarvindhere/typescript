So, since we know that there are some things in TypeScript that can be used both as values and types, can we have the same name for both a value and a type?

Let's say we have an object -

    export const Logger = {
        log: (message: string) => {
            console.log(message);
        },

        error: (message: string) => {
            console.error(message);
        },

        warn: (message: string) => {
            console.warn(message);
        },

        info: (message: string) => {
            console.info(message);
        }
    }

And in the same file, we have -

    export type Logger = typeof Logger;

So, we are exporting two things with the same name - 'Logger'. One is a value (the object) and the other is a type (the type of the object).

Now, what if we have a different file where we want to use both the value and the type?

    import {Logger} from './main';

    const myApp = (logger: Logger) => {
        logger.log('App started');
        logger.info('App is running');
        logger.warn('App might have some issues');
        logger.error('App encountered an error');
    }

    myApp(Logger);

What would happen in this case? Do we get an error because we are using the same name for both a value and a type? Or does TypeScript handle this gracefully?

Well, we get no errors at all! TypeScript is smart enough to know that when we are using 'Logger' in the type position (as a type annotation for the 'logger' parameter), it refers to the type. And when we are using 'Logger' in the value position (as an argument to the 'myApp' function), it refers to the value.

In fact, if you hover over the imported 'Logger' in the second file, you'll see that it is shown like this -

    (alias) type Logger = {
        log: (message: string) => void;
        error: (message: string) => void;
        warn: (message: string) => void;
        info: (message: string) => void;
    }
    (alias) const Logger: {
        log: (message: string) => void;
        error: (message: string) => void;
        warn: (message: string) => void;
        info: (message: string) => void;
    }

This means, the imported 'Logger' can be used both as a type and as a value, and TypeScript will understand the context in which it is being used.

That's pretty cool, right? This feature allows us to have cleaner and more intuitive code, as we can use the same name for related values and types without any confusion.