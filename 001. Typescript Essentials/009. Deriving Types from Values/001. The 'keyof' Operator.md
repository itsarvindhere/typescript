The real magic of TypeScript happens when we start deriving types from other types or values.

One of the most common ways to do this is using the 'keyof' operator in TypeScript.

Let's say we have an interface -

    interface FormValues {
        name: string;
        email: string;
        password: string;
    }

And let's say we have an object -

    const inputs: Record<'name' | 'email' | 'password', {
        initialValue: string;
        label: string
    }> = {
        name: {
            initialValue: '',
            label: 'Name'
        },
        email: {
            initialValue: '',
            label: 'Email'
        },
        password: {
            initialValue: '',
            label: 'Password'
        }
    };

Here, we have an object 'inputs' that has keys 'name', 'email', and 'password'. These keys correspond to the properties of the 'FormValues' interface.

Now, if you think about it, we are repeating ourselves. We are defining the keys 'name', 'email', and 'password' in two different places - once in the 'FormValues' interface and once in the 'inputs' object.

Basically, we want the 'inputs' object to conform to the keys of the 'FormValues' interface. Right now, the issue is that if in future, we add or remove a property from the 'FormValues' interface, we will have to remember to update the 'inputs' object as well. This can lead to bugs and inconsistencies in our code.

And that's where the 'keyof' operator comes in handy.

All we want is to say that the keys of the object 'inputs' should be one of the keys of the 'FormValues' interface.

As the name suggests, we can use 'keyof' operator to get the keys of an Object type. Remember that it works with an 'Object' type, not with an 'Object' value. This means, if we had an object like -

    const obj = {
        name: 'John',
        age: 30
    };

We cannot say - 

    type ObjKeys = keyof obj;

This will throw an error saying -

    'obj' refers to a value, but is being used as a type here.

Anyways, coming back to our initial example, after using 'keyof' operator, we can now safely add or remove properties from the 'FormValues' interface without worrying about updating the 'inputs' object. The type of 'inputs' object will automatically update to reflect the changes in the 'FormValues' interface. That's the benefit of using 'keyof' operator.