So far, we saw how we can derive types from values using the 'typeof' operator. We also saw how we can use the 'keyof' operator to get the keys of an object as a union type.

What about classes? Can we have a class and then derive types from it?

For example, let's say we have a class -

    class CanvasNode {
        x = 0;
        y = 0;

        move(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }

So, this class simply has two properties 'x' and 'y', and a method 'move'.

Let's say we have a method -

    const positionFromCanvasNode = (node) => {
        return {
            x : node.x,
            y : node.y
        }
    }

At this point, we will get an IDE error for 'node' since we haven't specified its type so its type is 'any'.

So, how can we tell TypeScript that the 'node' parameter is of type 'CanvasNode'?

You might think that we can use 'typeof' operator here like this -

    const positionFromCanvasNode = (node: typeof CanvasNode) => {
        return {
            x : node.x,
            y : node.y
        }
    }

But, if we do this an hover over 'node' then you will see that its type is -

    {
        new (): CanvasNode;
    }

So, somehow, the 'typeof' operator when used with classes gives us the type of the class constructor function and not the instance of the class.

Well, if you think about it, it makes sense here because by saying 'typeof CanvasNode', we are not referring to an instance of the class but the class itself. And in itself, behind the a class is just a special function that can be called with the 'new' keyword to create instances. 

You can actually verify the same if you write -

    const canvasNodeInstance = new CanvasNode();
    type CanvasNodeInstanceType = typeof canvasNodeInstance;

Here, if you hover over 'CanvasNodeInstanceType', you will see that its type is 'CanvasNode' which is the type of the instance of the class.

So, 'typeof' operator when used with classes gives us the type of the class constructor function and not the instance of the class.

So, how can we get the type of the instance of the class?

Well, since we now know that the type of the instance of class 'CanvasNode' is 'CanvasNode', we can simply use the class name itself as a type.

Well, it is pretty straightforward. We can use the class name itself as a type. So, we can do this -

    const positionFromCanvasNode = (node: CanvasNode) => {
        return {
            x : node.x,
            y : node.y
        }
    }

This is quite interesting because it means we can use classes are not values but also as types. We cannot do this with plain objects. For example, if we have an object like this -

    const canvasNode = {
        x: 0,
        y: 0,
        move(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }

We cannot use 'canvasNode' as a type. If we try to do this -

    const positionFromCanvasNode = (node: canvasNode) => {
        return {
            x : node.x,
            y : node.y
        }
    }

This will result in an error -

    'CanvasNode' refers to a value, but is being used as a type here. Did you mean 'typeof CanvasNode'?

And in this case, we will have to use 'typeof' operator to get the type of the object.

So, these are some interesting things to note about classes in TypeScript. We can use classes as both values and types. When we use the class name itself, we are referring to the type of the instance of the class. And when we use 'typeof' operator with the class name, we are referring to the type of the class constructor function.

This same thing also happens with 'Enums' in TypeScript. We can use the enum name itself as a type to refer to the type of the enum values.

For example, we can have - 

    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT"
    }

    function move(direction: Direction) {
        console.log(direction);
    }

Here, we are using the enum name 'Direction' as a type for the 'direction' parameter of the 'move' function. This means that the 'direction' parameter can only take one of the values defined in the 'Direction' enum.

What if we try to use 'typeof' operator with the enum name like this -

    function move(direction: typeof Direction) {
        console.log(direction);
    }

In this case, the type of 'direction' parameter will be -

    {
        readonly Up: Direction.Up;
        readonly Down: Direction.Down;
        readonly Left: Direction.Left;
        readonly Right: Direction.Right;
    }

So, when we use 'typeof' operator with the enum name, we get the type of the enum object itself which has properties for each enum member. And when we use the enum name itself as a type, we get a union type of all the enum member values.

Pretty interesting, right?