In the last section, we learned about the 'keyof' operator which lets us derive types from Object types. Now, in that section, we saw the limitation of using the 'keyof' operator. This operator only works with Object types, not with Object values.

Let's say we have -

    const configurations = {
        development: {
            apiBaseUrl: "http://localhost:3000",
            timeout: 5000
        },
        production: {
            apiBaseUrl: "https://api.example.com",
            timeout: 10000
        },
        staging: {
            apiBaseUrl: "https://staging-api.example.com",
            timeout: 8000
        }
    };

    type Environment = 'development' | 'production' | 'staging';

Notice how we are repeating our environment names in both the 'configurations' object and the 'Environment' type. This is not ideal because if we add a new environment to the 'configurations' object, we also have to remember to update the 'Environment' type. This can lead to bugs if we forget to do so.

We cannot write -

    type Environment = keyof configurations;

This throws an error -

    'configurations' refers to a value, but is being used as a type here. Did you mean 'typeof configurations'?

Now, this error message also tells us what we can use to fix this issue - the 'typeof' operator.

So, what is this 'typeof' operator?

As the name suggests, this operator simply gives us the type of a value. So, if we write -

    type ConfigurationsType = typeof configurations;

You will see that this 'ConfigurationsType' will be inferred as -

    {
        development: {
            apiBaseUrl: string;
            timeout: number;
        };
        production: {
            apiBaseUrl: string;
            timeout: number;
        };
        staging: {
            apiBaseUrl: string;
            timeout: number;
        };
    }

And now that we have a type, it means we can now use the 'keyof' operator on it -

    type Environment = keyof ConfigurationsType;

We can even do it in one line -

    type Environment = keyof typeof configurations;

And now, the type 'Environment' will be correctly inferred as -

    type Environment = 'development' | 'production' | 'staging';

Isn't it great? Now, if we add a new environment to the 'configurations' object, the 'Environment' type will automatically be updated.

Remember that you cannot go around writing 'typeof' anywhere in your TypeScript code. TypeScript actually limits the sorts of expressions you can use 'typeof' on.

Specifically, it’s only legal to use typeof on identifiers (i.e. variable names) or their properties. This helps avoid the confusing trap of writing code you think is executing, but isn’t.

For example, we cannot write -

    type x = typeof "Hello World";

This will throw an error in the IDE saying -

    Identifier expected.

But, the bottom-line is that whenever you want to get the type of a value, you can use the 'typeof' operator. This is extremely useful when you want to use any utility type but that type requires you to pass another type to it. In such cases, you can use the 'typeof' operator to get the type of a value and then pass that type to the utility type.

For example, we have a 'ReturnType' utility type that takes a function type and gives us the return type of that function. So, if we have a function -

    function getUser() {
        return {
            id: 1,
            name: "John Doe"
        };
    }

We cannot directly write -

    type User = ReturnType<getUser>;

This will throw an error -

    'getUser' refers to a value, but is being used as a type here. Did you mean 'typeof getUser'?

So, like before, we can use the 'typeof' operator to get the type of the 'getUser' function and then pass that type to the 'ReturnType' utility type -

    type User = ReturnType<typeof getUser>;