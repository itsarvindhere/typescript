In the last section, we saw how to derive specific types from an 'as const' object using 'Indexed Access Types'.

Now, what if we have an 'as const' array instead?

Let's say we have -

    export const programModes = [
        'group',
        'announcement',
        'one_on_one',
        'self_directed',
        'planned_one_on_one',
        'planned_self_directed',
    ] as const;

What if we want all the possible values of the 'programModes' array as a union type?

First, let's see what the type of 'programModes' is -

    type ProgramModes = typeof programModes;

We will see that it returns a type as a readonly tuple -

    type ProgramModes = readonly ["group", "announcement", "one_on_one", "self_directed", "planned_one_on_one", "planned_self_directed"]

So, let's say we want a type 'GroupMode' which has the same type as the first element of the 'programModes' array.

Well, if you think about it, with simple arrays, we can use the index to access a specific element. For example -

    const groupMode = programModes[0];

Can we do the same with types?

Yes, we can! We can use the index to access a specific element of the tuple type.

Since 'ProgramModes' is a tuple, we can access the first element using index '0' -

    type GroupMode = ProgramModes[0];

And now, it will return the type as 'group' -

    type GroupMode = "group";

That's great. Now, what if we want all the possible values of the 'programModes' array as a union type?

One way to do that would be to do -

    type ProgramModeUnion = ProgramModes[0] | ProgramModes[1] | ProgramModes[2] | ProgramModes[3] | ProgramModes[4] | ProgramModes[5];

And it will return the type as -

    type ProgramModeUnion = "group" | "announcement" | "one_on_one" | "self_directed" | "planned_one_on_one" | "planned_self_directed";

We can also write -

    type ProgramModeUnion = ProgramModes[0 | 1 | 2 | 3 | 4 | 5];

This works because remember the indexing type (whatever is inside the brackets) is simply a type, it means we can pass anything between the brackets which is a type or returns a type. And that includes a union type as well.

But still, this is not a scalable solution. What if in future we add more values to the 'programModes' array? We will have to keep updating the 'ProgramModeUnion' type as well. Similarly, what if we remove some values from the 'programModes' array? We will have to keep updating the 'ProgramModeUnion' type as well. Or, what if these modes are coming from some external source and we don't know how many values will be there in the array?

Well, there is an elegant solution to this problem as well.

This solution uses the 'number' type. So, we can say -

    type ProgramModeUnion = ProgramModes[number];

Wait, what? How does this work?

Well, remember that in TypeScript, the 'number' type represents all possible numeric values. So, when we use 'number' as the index type, it means we are accessing all possible indices of the tuple.

And that's how we can create a union type from an 'as const' array.