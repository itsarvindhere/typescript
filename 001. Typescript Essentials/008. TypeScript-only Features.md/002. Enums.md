'Enums' are yet another feature that TypeScript has but not JavaScript. So, it is a feature that is added to JavaScript by TypeScript.

If you have worked with other programming languages like Java, you might be familiar with the concept of Enums.

An 'Enum' represents a group of constants (unchangeable variables). Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.

Let's take an example - 

    const LogLevel = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };

    function log(options: {globalLogLevel: number, level: number, message: string}) {
        if (options.level >= options.globalLogLevel) {
            console.log(options.message);
        }
    }

Here, we have a 'LogLevel' object which defines different log levels. We can use these log levels to set the log level in our 'log' function. Our 'log' function takes an object with three properties - 'globalLogLevel', 'level', and 'message'. If the 'level' is greater than or equal to the 'globalLogLevel', it logs the message to the console.

So, we can call it like this -

    log({
        globalLogLevel: LogLevel.INFO, 
        level: LogLevel.DEBUG, 
        message: 'This is a debug message' 
    }); // Won't be logged

    log({
        globalLogLevel: LogLevel.INFO,
        level: LogLevel.ERROR,
        message: 'This is an error message'
    }); // Will be logged

All good so far. But, since we have defined the type of 'globalLogLevel' and 'level' as 'number', we can pass any number to these properties. For example -

    log({
        globalLogLevel: 5, // Invalid log level
        level: 10, // Invalid log level
        message: 'This is an invalid log level message'
    }); // Will be logged

This is not an expected behavior. We want to restrict the values of 'globalLogLevel' and 'level' to only the values defined in the 'LogLevel' object. So, what should be the type of 'globalLogLevel' and 'level'?

And this is a good use case where we can use Enums.

An Enum is defined using the 'enum' keyword. Let's define an enum for our log levels -

    enum LogLevel {
        DEBUG,
        INFO,
        WARN,
        ERROR
    }

Notice how we did not give any values to the enum members. By default, enums are numeric and auto-incremented from 0. So, 'LogLevel.DEBUG' will be 0, 'LogLevel.INFO' will be 1, 'LogLevel.WARN' will be 2, and 'LogLevel.ERROR' will be 3.

And now, we can tell TypeScript that our 'globalLogLevel' and 'level' properties should be of type 'LogLevel' -

    function log(options: { globalLogLevel: LogLevel, level: LogLevel, message: string }) {
        if (options.level >= options.globalLogLevel) {
            console.log(options.message);
        }
    }

Now, if we try to pass any number other than the values defined in the 'LogLevel' enum, TypeScript will throw an error. If you hover over 'globalLogLevel' or 'level', you will see that their type is 'LogLevel' which is like this -

    LogLevel.DEBUG | LogLevel.INFO | LogLevel.WARN | LogLevel.ERROR

This means, the only valid values for 'globalLogLevel' and 'level' are 'LogLevel.DEBUG', 'LogLevel.INFO', 'LogLevel.WARN', and 'LogLevel.ERROR'. Any other value will result in a type error.

We can also set values for our enum members. For example -

    enum LogLevel {
        DEBUG = 1,
        INFO = 2,
        WARN = 3,
        ERROR = 4
    }

Since enum values are auto-incremented, if we set a value for one member, the subsequent members will be auto-incremented from that value. So, we can also write -

    enum LogLevel {
        DEBUG = 1,
        INFO, 
        WARN,
        ERROR
    }

Now, 'LogLevel.DEBUG' will be 1, 'LogLevel.INFO' will be 2, 'LogLevel.WARN' will be 3, and 'LogLevel.ERROR' will be 4.

# STRING ENUMS

Now, Enum values are not limited to just 'numbers'. We can also have 'string' enums. For example, we have this code -

    enum Method {
        GET = 'GET',
        POST = 'POST',
        PUT = 'PUT',
        DELETE = 'DELETE',
    };

    const request = (url: string, method: Method) => {
        //
    };

Here, we have defined a 'Method' enum which has four members - 'GET', 'POST', 'PUT', and 'DELETE'. Each member is assigned a string value. So, this is a 'string' enum because the values of the enum members are strings. And we can call our 'request' function like this -

    request('https://example.com', Method.GET); // Valid
    request('https://example.com', Method.POST); // Valid

This forces us to use only the values defined in the 'Method' enum. If we try to pass any other string, TypeScript will throw an error. For example -

    request('https://example.com', 'PATCH'); // Error

In fact, even if we try to use the string value of an enum member directly, TypeScript will throw an error. For example -

    request('https://example.com', 'GET'); // Error - Argument of type '"GET"' is not assignable to parameter of type 'Method'
 
 So, this forces us to use the enum members instead of their values directly, which is a good thing.

# HETEROGENEOUS ENUMS

In TypeScript, it is possible to have an enum where some members are numeric and some are string. This is called a 'heterogeneous' enum. For example -

    enum BooleanLikeHeterogeneousEnum {
        No = 0,
        Yes = 'YES',
    }

But, TypeScript does not recommend using heterogeneous enums. The official website says -

    Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.

# CONST ENUMS

So, how are enums transpiled to JavaScript? Enums are transpiled to an object in JavaScript. Let's say we have this enum -

    enum LogLevel {
        DEBUG,
        INFO,
        WARN,
        ERROR
    }

If you run the 'tsc' command to transpile this code to JavaScript, you will get the following output -

    "use strict";
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
        LogLevel[LogLevel["INFO"] = 1] = "INFO";
        LogLevel[LogLevel["WARN"] = 2] = "WARN";
        LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    })(LogLevel || (LogLevel = {}));

Woah! What is going on here? Well, here, we are creating an object called 'LogLevel' and adding properties to it. But, it is quite interesting how we add properties to this object here. Let's take one line -

    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";

Here, what we are doing is, first, we are creating a property called 'DEBUG' on the 'LogLevel' object and assigning it the value of 0. Then, we are creating another property with the key as the value of 'LogLevel["DEBUG"]' (which is 0) and assigning it the value of 'DEBUG'. So, after this line, our 'LogLevel' object will look like this -

    {
        DEBUG: 0,
        0: "DEBUG"
    }

So basically, JavaScript is creating a bi-directional mapping between the enum member names and their values. So, the resulting object in JavaScript will be -

    {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        0: "DEBUG",
        1: "INFO",
        2: "WARN",
        3: "ERROR"
    }

Note that this is not the case with string enums. String enums do not have a bi-directional mapping. For example, if we have this string enum -

    enum Method {
        GET = 'GET',
        POST = 'POST',
        PUT = 'PUT',
        DELETE = 'DELETE',
    };

Then, the transpiled JavaScript code will look like this -

    "var Method;
    (function (Method) {
        Method["GET"] = "GET";
        Method["POST"] = "POST";
        Method["PUT"] = "PUT";
        Method["DELETE"] = "DELETE";
    })(Method || (Method = {}));

So, the resulting object in JavaScript will be -

    {
        GET: "GET",
        POST: "POST",
        PUT: "PUT",
        DELETE: "DELETE"
    }

In most cases, these kind of enums are a perfectly valid solution.

However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use const enums. Const enums are defined using the const modifier on our enums:

    const enum LogLevel {
        DEBUG,
        INFO,
        WARN,
        ERROR
    }

Well, now, if you look at the transpiled JavaScript code, you will see that there is no object created for the enum. Wait, what?

Unlike regular enums, const enums are completely removed during compilation. So, what happens when we use these const enums in our code? Maybe we have a variable like this -

    let defaultLogLevel: LogLevel = LogLevel.DEBUG;

You will see that in the compiled JavaScript code, all we get is -

    var defaultLogLevel = 0 /* LogLevel.DEBUG */;

So, TypeScript simply replaces the enum member with its value. This is called 'inlining'. This results in smaller code and better performance.

TypeScript const enums are generally not recommended, especially in library code or shared codebases where the compiler's behavior cannot be guaranteed. The TypeScript documentation advises against using const enums in shared codebases because their behavior depends on the specific TypeScript compiler used. If different parts of a project use different compilers or configurations, inconsistencies can arise.

# OBJECTS VS ENUMS

We know that in TypeScript, we can use 'as const' to create an object with read-only properties. For example -

    const LogLevel = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    } as const;

So, why not use this approach instead of enums? There is just one extra step here as we will need to create a Type which is a union of the values of the object. We can do this using 'typeof' and 'keyof' operators. For example -

    type LogLevel = typeof LogLevel[keyof typeof LogLevel];

This means the type of 'LogLevel' is a union of the values of the 'LogLevel' object. So, the type will be -

    0 | 1 | 2 | 3

And now, we can use this 'LogLevel' type in our 'log' function. For example -

    function log(options: { globalLogLevel: LogLevel, level: LogLevel, message: string }) {
        if (options.level >= options.globalLogLevel) {
            console.log(options.message);
        }
    }

    log({ globalLogLevel: LogLevel.DEBUG, level: LogLevel.INFO, message: 'This is a debug message' }); // Valid

The biggest argument in favour of this format over TypeScript’s enum is that it keeps your codebase aligned with the state of JavaScript. So, it is easier to understand for JavaScript developers. Also, it avoids some of the pitfalls of enums, such as the extra generated code and the bi-directional mapping.