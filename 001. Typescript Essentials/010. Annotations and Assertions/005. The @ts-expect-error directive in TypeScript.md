In the last lesson, we explored the '@ts-ignore' directive in TypeScript, which allows developers to suppress specific TypeScript errors on the following line of code. While this can be useful in certain scenarios, it is important to use it judiciously, as it can potentially hide genuine issues in the code.

In TypeScript 3.9, a new directive was introduced named '@ts-expect-error'.

When we add '@ts-expect-error' comment above a line of code, we are indicating to the TypeScript compiler that we expect an error to occur on that line. If no error occurs, the compiler will raise an error, alerting us that our expectation was incorrect.

You might think, why would we want to do this?

Let's say we have a function in TypeScript that adds two numbers together:

        const add = (a: number, b: number): number => {
            return a + b;
        }

We have nice annotations here, and if we try to call this function with incorrect types, TypeScript will raise an error.

What if we want to write some unit tests to ensure that our function behaves as expected when given incorrect types?

Let's say we write some unit test that has -

    console.log(add(1, '2'));

We know that this is not a valid call to the 'add' function, and we expect TypeScript to raise an error here. But, we know that we are expecting this error because this is a failing test case. So, we can suppress this error using the '@ts-expect-error' directive:

        // @ts-expect-error
        console.log(add(1, '2'));

Using this, we are basically telling TypeScript that we expect an error on the next line.

Now, if there is a code that does not raise an error, TypeScript will raise an error indicating that our expectation was incorrect.

So, if we go back to the example we used in the last lesson:

        const handleFormData = (e: SubmitEvent) => {
            e.preventDefault();
            
            // @ts-ignore
            const data = new FormData(e.target);
            const value = Object.fromEntries(data.entries());
        
            return value;
        }

We can actually replace '@ts-ignore' with '@ts-expect-error':

        const handleFormData = (e: SubmitEvent) => {
            e.preventDefault();
            
            // @ts-expect-error
            const data = new FormData(e.target);
            const value = Object.fromEntries(data.entries());
        
            return value;
        }

Because here, we are expecting a type error to occur on the next line but we know that in runtime it will work just fine. So, we can use '@ts-expect-error' here to suppress the error.

So, which one to use - '@ts-ignore' or '@ts-expect-error'?

The main difference is that when we use '@ts-expect-error,' if there is no error on the next line, TypeScript will raise an error indicating that our expectation was incorrect. That is not the case with '@ts-ignore'.

Just like the '@ts-ignore' directive, the '@ts-expect-error' directive should be used sparingly and only when absolutely necessary. Most of the time, you will see it being used in unit tests to indicate that a certain line of code is expected to raise an error. But in general, it is a good practice to avoid using it unless you have a very good reason to do so.