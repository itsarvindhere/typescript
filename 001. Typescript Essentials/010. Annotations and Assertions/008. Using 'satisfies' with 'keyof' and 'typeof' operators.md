Let's say we have this code -

    const configurations = {
        development: {
            apiBaseUrl: "https://dev.api.example.com",
            timeout: 5000,
        },
        production: {
            apiBaseUrl: "https://api.example.com",
            timeout: 3000,
        },
        staging: {
            apiBaseUrl: "https://staging.api.example.com",
            timeout: 4000,
            notAllowed: true // This should cause an error
        }
    }

Here, we have an object 'configurations' with different environment configurations. Now, we have not explicitly defined the type for 'configurations', so TypeScript infers it. But, we want to make sure that each configuration adheres to a specific structure. Basically, we want to ensure that each configuration has 'apiBaseUrl' and 'timeout' properties, and no extra properties.

One way to do it is to define the type for configurations like this -

    const configurations: Record<string, { apiBaseUrl: string; timeout: number }> = {...}

So, we are saying that 'configurations' is a record where keys are strings and values are objects with 'apiBaseUrl' and 'timeout' properties.

This will now show an error for the 'staging' configuration because it has an extra property 'notAllowed'.

Let's say we have a type that is a union of the keys of 'configurations' -

    type ConfigKeys = keyof typeof configurations;

After we make our change to add the type annotation to 'configurations', 'ConfigKeys' will be inferred as 'string' because we used 'Record<string, ...>'. This is wrong because we wanted 'ConfigKeys' to be a union of the actual keys of 'configurations', which are 'development', 'production', and 'staging'.

So, how do we fix it now?

If we remove this type annotation, we will not get an error for the 'staging' configuration. But, the 'ConfigKeys' will get inferred correctly as -

    type ConfigKeys = "development" | "production" | "staging"

So basically, here, we want TypeScript to infer the type of 'configurations' but also ensure that it adheres to a specific structure. And well, all of this points to the 'satisfies' operator. Yes, we can use it here.

    const configurations= {
        development: {
            apiBaseUrl: "https://dev.api.example.com",
            timeout: 5000,
        },
        production: {
            apiBaseUrl: "https://api.example.com",
            timeout: 3000,
        },
        staging: {
            apiBaseUrl: "https://staging.api.example.com",
            timeout: 4000,
            notAllowed: true
        }
    } satisfies Record<string, { apiBaseUrl: string; timeout: number; }>;

So, we are saying that 'configurations' should satisfy the type 'Record<string, { apiBaseUrl: string; timeout: number; }>'.

This will now show an error for the 'staging' configuration because it has an extra property 'notAllowed'.

And this won't affect the inference of 'configurations'. So, now 'ConfigKeys' will be correctly inferred as -

    type ConfigKeys = "development" | "production" | "staging"