We can use annotations in Typescript to explicitly declare the type of a variable. However, there are cases where annotations are not necessary because TypeScript can infer the type automatically.

So, when is annotation too much?

Let's say we have this piece of code -

    const isProblemOrSolution = (filename: string): boolean => {
        const splitFileName: string[] = filename.split('.');

        const finalIndex: number = splitFileName.length - 1;

        const extension: string | undefined = splitFileName[finalIndex];

        const isProblem: boolean = extension === 'problem';

        const isSolution: boolean = extension === 'solution';

        return isProblem || isSolution;
    }

At first glance, it looks fine. We have annotated every variable with its type. But if we look closely, we can see that some of these annotations are unnecessary.

There are some parts of this code that do not even need explicit annotations because TypeScript can infer the types automatically.

What if we had this code instead - 

    const isProblemOrSolution = (filename: string) => {

        const splitFileName = filename.split('.');

        const finalIndex = splitFileName.length - 1;

        const extension = splitFileName[finalIndex];

        const isProblem = extension === 'problem';

        const isSolution = extension === 'solution';

        return isProblem || isSolution;
    }

So now, we have removed the unnecessary annotations. The code is still type-safe, and it is more concise and easier to read.

In the previous example, our function had a type -

    (filename: string): boolean

And even after we remove all the unnecessary annotations, the function still has the same type -

    (filename: string): boolean

This pretty much means that all the annotations that we previously had (which we removed now) were unnecessary.

We can now see that the necessary annotations in the example above are the ones that cannot be inferred automatically by TypeScript. That is, the type of the function parameters. We were able to remove the return type annotation because TypeScript can infer it automatically.

There is no need to write -

    const splitFileName: string[] = filename.split('.');

Since we already told TypeScript that 'filename' is a string, it can automatically infer that 'splitFileName' is an array of strings because if we use 'split' on a string, it will always return an array of strings.

And the same is the case for other lines of code as well.

Let's take another example. Let's say we have this object -

    const users: {
        name: string;
    }[] = [
        {
            name: 'Arvind'
        },
        {
            name: 'John'
        }
    ];

So, it is an array of objects, and each object has a 'name' property of type string.

Now, let's say we want to take each user and add an 'id' property to it. We can do that like this -

    const usersWithIds: {
        id: number;
        name: string;
    }[] = users.map((
        user: {
            name: string
        },
        index: number
    ) => ({
        ...user,
        id: index
    }
    ));

So, here, we are saying that 'usersWithIds' is an array of objects, and each object has an 'id' property of type number and a 'name' property of type string.

If you notice, we are using the 'map' function on the 'users' array. Right now, we are explicitly annotating the type of 'user' and 'index' parameters of the callback function that we are passing to the 'map' function.

But, do we even need that? If you think of it, TypeScript already knows that 'users' is an array of objects with a 'name' property of type string. So, it knows that if we iterate over the 'users' array, each item will be an object with a 'name' property of type string.

There is no need to explicitly annotate the type of 'user' parameter. Similarly, TypeScript also knows that the 'index' parameter will always be a number because it is the index of the array.

So, we can simply write -

    const usersWithIds: {
        id: number;
        name: string;
    }[] = users.map((user,index) => ({
        ...user,
        id: index
    }));

This is much cleaner and easier to read.

In fact, we can even remove the annotation for 'users' because TypeScript can infer that it is an array of objects with a 'name' property of type string from the initial value that we assigned to it.

    const users = [
        {
            name: 'Arvind'
        },
        {
            name: 'John'
        }
    ];

Similarly, we can also remove the annotation for 'usersWithIds' because TypeScript can infer that it is an array of objects with an 'id' property of type number and a 'name' property of type string from the return value of the 'map' function.

    const usersWithIds = users.map((user,index) => ({
        ...user,
        id: index
    }));

Now, sometimes it is a good idea to keep some annotations even if they are not necessary. For example, if we have a complex object type, it is a good idea to keep the annotation for that object type to make it clear what the structure of the object is. Otherwise, someone can accidentally change the structure of the object without realizing it.

The same is the case above with 'users' and 'usersWithIds'. It is a good idea to keep the annotations for these variables to make it clear what the structure of the objects in the array is.

Now, this is a personal preference. Some people prefer to keep the annotations even if they are not necessary (e.g. for objects or function return types), while others prefer to remove unnecessary annotations. There is no right or wrong answer here. It is up to you to decide what works best for you and your team.