Sometimes we have information about the type of a value that TypeScript can’t know about.

Let's say we have this piece of code -

    const handleFormData = (e: SubmitEvent) => {
        e.preventDefault();
        const data = new FormData(e.target);
        const value = Object.fromEntries(data.entries());
        return value;
    }

Right now, your IDE will show an error for the 'e.target' part. You will see an error saying -

    Argument of type 'EventTarget | null' is not assignable to parameter of type 'HTMLFormElement | undefined'.
        Type 'null' is not assignable to type 'HTMLFormElement | undefined'

From this, we can see that TypeScript infers the type of 'e.target' to be 'EventTarget | null'. But, the 'FormData' constructor expects an argument of type 'HTMLFormElement | undefined'. So, TypeScript is complaining that the inferred type is not compatible with the expected type.

So, here, TypeScript cannot infer the type of 'e.target' correctly. We know that 'e.target' will always be an 'HTMLFormElement' in this case because this function will only be called when a form is submitted. But TypeScript cannot know that. TypeScript only knows that this 'e.target' can be any 'EventTarget' or 'null'.

So, how do we tell TypeScript that we know better?

Well, we can use something called 'Type Assertion'.

We can tell TypeScript that we know that 'e.target' is an 'HTMLFormElement' by using the 'as' keyword.

    const handleFormData = (e: SubmitEvent) => {
        e.preventDefault();
        const data = new FormData(e.target as HTMLFormElement); <== HERE
        const value = Object.fromEntries(data.entries());
        return value;
    }

And now, the error is gone!

So, using Type Assertion, we can provide additional information to TypeScript about the types in our code.

Like the type annotations, the type assertions are not present in the compiled JavaScript code. They are only used by TypeScript during the type checking phase.

# THINGS TO NOTE ABOUT TYPE ASSERTIONS

Type Assertions do come with a caveat. If we assert a type that is not correct, TypeScript will not be able to catch that error. In that case, we will get a runtime error instead of a compile-time error. So, we should use type assertions only when we are sure about the type of a value.

Moreover, we cannot just randomly convert one type to another using type assertions.

So, if we have -

    const x = 'hello' as number;

This is not a valid type assertion. TypeScript will throw an error saying -

    Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.

Remember that TypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions as above.

# AS ANY

Let's go back to our initial example.

    const handleFormData = (e: SubmitEvent) => {
        e.preventDefault();
        const data = new FormData(e.target);
        const value = Object.fromEntries(data.entries());
        return value;
    }

What if we have no idea about the type of 'e.target' and we just want to tell TypeScript to ignore the type checking for this particular value?

That's where the 'as any' type assertion comes in.

As we know already, the 'any' type is a special type in TypeScript that disables all type checking. So, when we use 'as any', we are telling TypeScript to treat the value as having the 'any' type, which means that TypeScript will not perform any type checking on that value.

So, we can modify our code like this -

    const handleFormData = (e: SubmitEvent) => {
        e.preventDefault();
        const data = new FormData(e.target as any); <== HERE
        const value = Object.fromEntries(data.entries());
        return value;
    }

But, if you know the type of the value, it is always better to use a more specific type assertion instead of 'as any'. Using 'as any' should be the last resort when you have no other option.

One more place where you will see 'as any' is when you want to allow complex coercions which TypeScript does not allow directly.

    const a = expr as any as SomeOtherType;

Here, we are first converting 'expr' to 'any' and then to 'SomeOtherType'. This way, we can bypass the type checking for the intermediate step.

But again, this also means you can do something like -

    const x = 'hello' as any as number;

And TypeScript will not complain. So, use this with caution.

    Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
        Type 'undefined' is not assignable to type 'string'

So, somehow TypeScript has forgotten that we already checked for the existence of 'searchParams.name' in the 'if' condition.

The reason why TypeScript is doing this is because even though we checked for the existence of 'searchParams.name' in the 'if' condition, there is still possibility that 'searchParams.name' can be modified to 'undefined' inside the 'if' block before it is used in the filter function. TypeScript is being cautious here and is not making any assumptions about the value of 'searchParams.name' inside the if block.

Because, what if we had -

    if (searchParams.name) {
        searchParams.name = undefined;
        return users.filter(user => user.name.includes(searchParams.name));
    }

In this case, even though we checked for the existence of 'searchParams.name' in the 'if' condition, it is still possible that 'searchParams.name' can be 'undefined' inside the 'if' block because we explicitly set it to 'undefined'.

# FIRST OPTION

So, how do we fix this issue? Well, we have seen this code in one of the sections before and at that time, we simply create a new variable to hold the value of 'searchParams.name' and use that variable inside the filter function.

    const findUsersByName = (
        searchParams: { name ?: string },
        users: {
            id: string,
            name: string;
        }[]
    ) => {
        const name = searchParams.name;
        if (name) {
            return users.filter(user => user.name.includes(name));
        }

        return users;
    };

So, here, we created a new variable 'name' to hold the value of 'searchParams.name'. After the if check, TypeScript knows that 'name' cannot be 'undefined' inside the if block because we have already checked for its existence. So, there is no error now.

# SECOND OPTION

But, we can also fix this issue using a 'Non-Null Assertion'.

A 'Non-Null Assertion' is a special type assertion that tells TypeScript that we are sure that a value is not 'null' or 'undefined'.

    if (searchParams.name) {
        return users.filter(user => user.name.includes(searchParams.name as string));
    }

So, here, we are using the 'as' keyword to assert that 'searchParams.name' is of type 'string'. This way, we are telling TypeScript that we are sure that 'searchParams.name' is not 'undefined' inside the if block.

# THIRD OPTION

There is also a third way to fix this issue.

We can  use something called a 'Non-Null Assertion Operator'. This is a simply an exclamation mark '!' that we can place after a value to tell TypeScript that we are sure that the value is not 'null' or 'undefined'.

    if (searchParams.name) {
        return users.filter(user => user.name!.includes(searchParams.name!)); <== HERE
    }

Now, we should use the 'Non-Null Assertion Operator' only when we are absolutely sure that the value is not 'null' or 'undefined'. If we use it on a value that can be 'null' or 'undefined', we will get a runtime error.