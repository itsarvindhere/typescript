In TypeScript version 4.9, a new operator called the 'satisfies' operator was introduced.

Let's say that we have the following piece of code -

    type Color = string | {
        r: number;
        g: number;
        b: number;
    };

    const config: Record<string, Color> = {
        foreground: {
            r: 255,
            g: 255,
            b: 255
        },
        background: {
            r: 0,
            g: 0,
            b: 0
        },
        border: 'transparent'
    };

All good so far. We have a type alias 'Color' which can either be a string or an object with three properties 'r', 'g' and 'b' of type number. We then have a constant 'config' which is a record with string keys and values of type 'Color'.

Now, what if we want to convert the 'border' property's value to uppercase? Well, at first glance it looks like we can surely do that because the value assigned to 'border' is indeed a string - 

    config.border.toUpperCase();

But, this will show an error in the IDE saying -

    Property 'toUpperCase' does not exist on type 'Color'.
        Property 'toUpperCase' does not exist on type '{ r: number; g: number; b: number; }'.

Since the type 'Color' can also be an object with properties 'r', 'g' and 'b', TypeScript is not allowing us to call the 'toUpperCase' method on it. Remember that we have a union type here. So, we can only use the methods and properties that are common to all the types in the union. Since 'toUpperCase' is not a method on the object type, we get this error.

We can also not do -

    config.foreground.r

That'as because 'foreground' is also of type 'Color' and TypeScript does not know if it is a string or an object at this point. So, 'r' property might not even exist.

One way to fix this would be to use a type assertion to tell TypeScript that we are sure that 'border' is a string and 'foreground' is an object with 'r', 'g', and 'b' properties -
    
    (config.border as string).toUpperCase();
    (config.foreground as { r: number; g: number; b: number }).r;

Another issue is that if we try to access a property that does not exist- 

    config.primary
    config.secondary

There won't be any error even though we have not defined these properties in the 'config' object. This is because the type of 'config' is 'Record<string, Color>' which means it can have any string as a key and the value will be of type 'Color'. So, TypeScript assumes that these properties might exist at runtime.

Well, one way to fix all the issues is to remove the type annotation from the 'config' object - 

    const config = {
        foreground: {
            r: 255,
            g: 255,
            b: 255
        },
        background: {
            r: 0,
            g: 0,
            b: 0
        },
        border: 'transparent'
    };

If you hover over 'config', you will see that TypeScript has inferred the type of 'config' as -

    const config: {
        foreground: {
            r: number;
            g: number;
            b: number;
        };
        background: {
            r: number;
            g: number;
            b: number;
        };
        border: string;
    };

But, the issue here is that we can manually add some property to the 'config' object which is not of type 'Color'. Or, we can edit the value of an existing property to something that is not of type 'Color' -

    const config = {
        foreground: {
            r: 255,
            g: 255 <== We removed the 'b' property
        },
        background: {
            g: 0, <== We removed the 'r' property
            b: 0
        },
        border: 'transparent',
        primary: 1234 // This should not be allowed
    };

So, what we want is to have the type safety of the 'Record<string, Color>' type while also having the benefits of type inference.

And that's where we can use the new 'satisfies' operator to solve all of these issues. So, what does this operator do? We use it like this -

    const config = {
        foreground: {
            r: 255,
            g: 255,
            b: 255
        },
        background: {
            r: 0,
            g: 0,
            b: 0
        },
        border: 'transparent'
    } satisfies Record<string, Color>;

Here, we are saying that the object on the left side of the 'satisfies' operator should satisfy the type on the right side.

So, even now, if you hover over 'config', you will see that TypeScript has inferred the type of 'config' as -

    const config: {
        foreground: {
            r: number;
            g: number;
            b: number;
        };
        background: {
            r: number;
            g: number;
            b: number;
        };
        border: string;
    };

This means, it is still inferring the type of 'config' based on the values we have assigned to it. But, this 'satisfies' operator is also ensuring that the type of 'config' satisfies the 'Record<string, Color>' type. So, if we try to add a property that is not of type 'Color' or if we try to update a property to something that is not of type 'Color', we will get an error.