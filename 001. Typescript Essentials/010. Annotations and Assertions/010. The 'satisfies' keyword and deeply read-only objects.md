Let's say we have this object -

    const routes = {
        '/': {
            component: 'Home'
        },
        '/about': {
            component: 'About',
            search: "?foo=bar" // Should not be allowed
        }
    }

Here, the 'routes' object is inferred to be of type:

    {
        '/': { component: string };
        '/about': { component: string; search: string };
    }

But, we want to ensure that the 'search' property is not allowed in a route. Right now, there won't be any error because TypeScript is inferring the type of 'routes' based on the provided values.

So, how do we ensure that the 'routes' object conforms to a specific type where 'search' is not allowed? We also ant to make sure that the 'routes' object type is always inferred by TypeScript. Well, we can use the 'satisfies' keyword.

    const routes = {
        '/': {
            component: 'Home'
        },
        '/about': {
            component: 'About',
            search: "?foo=bar"
        }
    } satisfies Record<string, { component: string }>;

Now, the 'routes' object is checked against the type 'Record<string, { component: string }>', which means that each property of 'routes' must be an object with a 'component' property of type string. If we try to add a 'search' property, TypeScript will throw an error as expected.

What if we have this code -

    routes['/'].component = 'About';

So, here, we are changing the 'component' property of the '/' route to 'About'. This is allowed because the type of 'routes' is inferred to be mutable.

But, we want to ensure that the 'routes' object is deeply read-only, meaning that we cannot change any property of the object or its nested objects.

Well, as we already know, we can make an object deeply read-only using the 'as const' assertion.

But, how do we use it here because we are already using the 'satisfies' keyword?

Do we use it like this -

    const routes = {
        '/': {
            component: 'Home'
        },
        '/about': {
            component: 'About',
            search: "?foo=bar"
        }
    } satisfies Record<string, { component: string }> as const;

Well, this will not work and we will see an error -

    A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.

This basically means that right now, we are trying to apply the 'as const' assertion to the result of the 'satisfies' expression, which is not allowed.

We want it to be applied to the object literal itself.

So, what if we write -

    const routes = {
        '/': {
            component: 'Home'
        },
        '/about': {
            component: 'About',
            search: "?foo=bar"
        }
    } as const satisfies Record<string, { component: string }>;

This will work.

So now, the 'routes' object is deeply read-only and also satisfies the type 'Record<string, { component: string }>'. The type will be inferred by TypeScript as -

    const routes: {
        readonly '/': {
            readonly component: "Home";
        };
        readonly '/about': {
            readonly component: "About";
        };
    }

And that's what we want.

This is how we can use the 'satisfies' keyword along with 'as const' to create deeply read-only objects that conform to a specific type. Pretty interesting, right?