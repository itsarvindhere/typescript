Let's come back to the 'Shape' class example that we had earlier. So, we have -

    class Shape {
        #x: number;
        #y: number;

        constructor(x: number, y: number) {
            this.#x = x;
            this.#y = y;
        }

        get position(): { x: number; y: number } {
            return {
                x: this.#x,
                y: this.#y
            }
        }

        set position(position: { x: number; y: number }) {
            if (position.x >= 0) {
                this.#x = position.x;
            } else {
                throw new Error("X coordinate cannot be negative");
            }

            if (position.y >= 0) {
                this.#y = position.y;
            } else {
                throw new Error("Y coordinate cannot be negative");
            }
        }

        move(x: number, y: number) {
            this.#x = x;
            this.#y = y;
        }
    }

What if we have a type that defines the structure of a Shape? Something like this -

    type IShape = {
        position: { x: number; y: number };
        move(x: number, y: number): void;
    }

How to tell TypeScript that our class 'Shape' adheres to the structure defined by the type 'IShape'?

We can use the 'implements' keyword -

    class Shape implements IShape {
        #x: number;
        #y: number;

        constructor(x: number, y: number) {
            this.#x = x;
            this.#y = y;
        }

        get position(): { x: number; y: number } {
            return {
                x: this.#x,
                y: this.#y
            }
        }

        set position(position: { x: number; y: number }) {
            if (position.x >= 0) {
                this.#x = position.x;
            } else {
                throw new Error("X coordinate cannot be negative");
            }

            if (position.y >= 0) {
                this.#y = position.y;
            } else {
                throw new Error("Y coordinate cannot be negative");
            }
        }

        move(x: number, y: number) {
            this.#x = x;
            this.#y = y;
        }
    }

In object-oriented programming languages, we use 'interfaces' to define the structure of a class. In TypeScript, we can also use the 'interface' keyword to define an interface -

    interface IShape {
        position: { x: number; y: number };
        move(x: number, y: number): void;
    }

The benefit now is that if we forget to implement any property or method defined in the interface 'IShape', TypeScript will throw an error.

For example, let's say we did not implement a 'move' method in the 'Shape' class. Then, TypeScript will throw an error like this -

    Class 'Shape' incorrectly implements interface 'IShape'.
        Property 'move' is missing in type 'Shape' but required in type 'IShape'.

And it is not just the methods that we need to implement, we also need to implement the properties defined in the interface. For example -

    interface IShape {
        position: { x: number; y: number };
        move(x: number, y: number): void;
        color: string; // New property added
    }

In this case, if we do not implement the 'color' property in the 'Shape' class, TypeScript will throw an error like this -

    Class 'Shape' incorrectly implements interface 'IShape'.
        Property 'color' is missing in type 'Shape' but required in type 'IShape'.

So, we have to define a property named 'color' in the 'Shape' class to adhere to the structure defined by the interface 'IShape'.

So, we can say that interfaces are a way to enforce a contract on the structure of a class.