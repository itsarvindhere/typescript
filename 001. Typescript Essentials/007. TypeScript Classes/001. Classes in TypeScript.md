We know that in JavaScript we can have 'classes'. We create a class using the 'class' keyword. A class is a blueprint for creating objects with pre-defined properties and methods.

TypeScript builds on this concept and adds various features to make working with classes more robust and type-safe.

For example -

    class CanvasNode {
        readonly x: number;
        readonly y: number;
    }

To create a new instance of this class, we use the 'new' keyword -

    let node = new CanvasNode();

Since 'x' and 'y' are marked as 'readonly', we cannot change their values after the object is created. If we try to do so, TypeScript will throw an error -

    node.x = 10; // Error: Cannot assign to 'x' because it is a read-only property.

Now, what if we want to set the values of 'x' and 'y' when we create the object? 

Well, one way is to have a 'constructor' function inside the class. A constructor is a special method that is called when an object is instantiated. It can be used to initialize properties of the class.

So, we can write -

    class CanvasNode {
        readonly x: number;
        readonly y: number;

        constructor() {
            this.x = 10;
            this.y = 20;
        }
    }

But, there is also a way to do this without explicitly defining a constructor. We can simply write -

    class CanvasNode {
        readonly x: number = 10;
        readonly y: number = 20;
    }

# CLASS METHODS

Let's say we need to have a method named 'move' on the class 'CanvasNode' that updates the 'x' and 'y' coordinates of the node. We can define it like this -

    class CanvasNode {
        x: number = 10;
        y: number = 20;

        move(newX: number, newY: number): void {
            this.x = newX;
            this.y = newY;
        }
    }

And now, when we create an instance of 'CanvasNode', we can call the 'move' method to update its position -

    let node = new CanvasNode();
    node.move(30, 40);

    console.log(node.x); // 30
    console.log(node.y); // 40

We can also create a variable 'move' which is an arrow function -

    class CanvasNode {
        x: number = 10;
        y: number = 20;

        move = (newX: number, newY: number): void => {
            this.x = newX;
            this.y = newY;
        }
    }

But generally, it's better to use the method syntax unless you specifically need the arrow function behavior. Otherwise, there might be some issue with 'this' context when you try to call the method from outside the class.

# CREATING CONSTRUCTORS THAT TAKE PARAMETERS

What if we want to initialize some of the properties of the class when we create an instance of it? In our case, when we create a 'CanvasNode', we might want to specify its initial 'x' and 'y' coordinates.

We can do that by creating a constructor method that accepts parameters -

    class CanvasNode {
        x: number;
        y: number;

        constructor(x: number, y: number) {
            this.x = x;
            this.y = y;
        }

        move(newX: number, newY: number): void {
            this.x = newX;
            this.y = newY;
        }
    }

Now, we can create a new 'CanvasNode' and specify its initial position -

    let node = new CanvasNode(10, 20);

    console.log(node.x); // 10
    console.log(node.y); // 20

What if we want the constructor parameters to be optional? We can do that by providing default values for the parameters -

    class CanvasNode {
        x: number;
        y: number;

        constructor(x: number = 0, y: number = 0) {
            this.x = x;
            this.y = y;
        }

        move(newX: number, newY: number): void {
            this.x = newX;
            this.y = newY;
        }
    }

Now, if we create a 'CanvasNode' without any arguments, it will default to (0, 0).

We could've also used the question mark (?) to make the parameters optional -

    class CanvasNode {
        x: number;
        y: number;

        constructor(x?: number, y?: number) {
            this.x = x ?? 0; // If x is undefined, default to 0
            this.y = y ?? 0; // If y is undefined, default to 0
        }

        move(newX: number, newY: number): void {
            this.x = newX;
            this.y = newY;
        }
    }