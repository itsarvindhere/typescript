Like in other object-oriented programming languages, TypeScript also supports class inheritance. This allows you to create a new class that is based on an existing class, inheriting its properties and methods while adding new ones or modifying existing ones.

Let's say our 'CanvasNode' gets a new property named 'viewMode' -

    type ViewMode = 'hidden' | 'visible' | 'selected';

    class CanvasNode {
        #x: number; 
        #y: number;
        #viewMode: ViewMode;

        constructor(x: number, y: number, viewMode: ViewMode) {
            this.#x = x;
            this.#y = y;
            this.#viewMode = viewMode;
        }

        get position(): { x: number; y: number } {
            return {
                x: this.#x,
                y: this.#y
            }
        }

        set position(position: { x: number; y: number }) {
            if (position.x >= 0) {
                this.#x = position.x;
            } else {
                throw new Error("X coordinate cannot be negative");
            }

            if (position.y >= 0) {
                this.#y = position.y;
            } else {
                throw new Error("Y coordinate cannot be negative");
            }
        }

        hide() {
            this.#viewMode = 'hidden';
        }

        get isHidden() {
            return this.#viewMode === 'hidden';
        }

        get isVisible() {
            return this.#viewMode === 'visible';
        }

        get isSelected() {
            return this.#viewMode === 'selected';
        }
    }

So, while our class was previously just a simple node with x and y coordinates, it now has a 'viewMode' property that can be 'hidden', 'visible', or 'selected'. It also has methods to hide the node and check its current view mode.

What if in some parts of our application, we use this class just for normal shapes that have 'x' and 'y' coordinates, and in other parts, we use it for shapes that can also be 'hidden', 'visible', or 'selected'?

It would be better to extract the 'viewMode' functionality into a separate class and everything else into a base class. Then, we can create a new class that inherits from the base class and adds the 'viewMode' functionality.

We can do that in TypeScript.

Let's create our base class that only deals with 'x' and 'y' -

    class Shape {
        #x: number; 
        #y: number;

        constructor(x: number, y: number) {
            this.#x = x;
            this.#y = y;
        }

        get position(): { x: number; y: number } {
            return {
                x: this.#x,
                y: this.#y
            }
        }

        set position(position: { x: number; y: number }) {
            if (position.x >= 0) {
                this.#x = position.x;
            } else {
                throw new Error("X coordinate cannot be negative");
            }

            if (position.y >= 0) {
                this.#y = position.y;
            } else {
                throw new Error("Y coordinate cannot be negative");
            }
        }
    }

So, this is our base class that only deals with 'x' and 'y' coordinates.

Now, let's create a new class that extends this base class and adds the 'viewMode' functionality -

    class CanvasNode extends Shape {
        #viewMode: ViewMode;

        constructor(x: number, y: number, viewMode: ViewMode) {
            super(x, y);
            this.#viewMode = viewMode;
        }

        hide() {
            this.#viewMode = 'hidden';
        }

        get isHidden() {
            return this.#viewMode === 'hidden';
        }

        get isVisible() {
            return this.#viewMode === 'visible';
        }

        get isSelected() {
            return this.#viewMode === 'selected';
        }
    }

Since the class 'CanvasNode' extends the class 'Shape', it inherits all its properties and methods.

Remember that if we have a 'constructor' in the derived class, we need to call 'super()' before using 'this'. The 'super()' function calls the constructor of the base class. And Since the constructor of the base class expects two parameters, we need to pass those parameters when calling 'super()'.

Now, we can create instances of both classes -

    const shape = new Shape(10, 20);
    console.log(shape.position); // { x: 10, y: 20 }
    shape.position = { x: 15, y: 25 }; // Valid
    console.log(shape.position); // { x: 15, y: 25 }

    const node = new CanvasNode(30, 40, 'visible');
    console.log(node.position); // { x: 30, y: 40 }
    node.position = { x: 35, y: 45 }; // Valid
    console.log(node.position); // { x: 35, y: 45 }
    console.log(node.isVisible); // true
    node.hide();
    console.log(node.isHidden); // true