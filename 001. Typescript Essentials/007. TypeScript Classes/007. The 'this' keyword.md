We know how interesting the 'this' keyword is in JavaScript. In TypeScript, it behaves the same way as in JavaScript. That is kind of expected since TypeScript is not supposed to change the runtime behavior of JavaScript.

As we know, inside a function, the 'this' keyword refers to the object that is executing the current function. In a method of a class, 'this' refers to the instance of the class.

Sometimes, we may not want this behavior so we can use things like 'arrow functions' or 'bind' to change the context of 'this'.

Suppose we have these two functions -

    function add(): number {
        return this.x + this.y;
    };

    const setValues  = (x: number, y: number) => {
        this.x = x;
        this.y = y;
    }

And we have an object defined like this -

    
    const calculator = {
        x: 0,
        y: 0,
        add,
        setValues
    };

So, this object has two properties 'x' and 'y' and two methods 'add' and 'setValues'. The method 'add' adds the values of 'x' and 'y' and returns the result. The method 'setValues' sets the values of 'x' and 'y'.

What happens when we call -

    calculator.setValues(10, 20);
    console.log(calculator.add());

While we expect the output to be 30, we instead get 0. But why?

The reason is that 'setValues' is an arrow function. Always remember that an arrow function does not have its own 'this'. Instead, it captures the 'this' value of the enclosing context at the time it is created. In this case, the enclosing context is the global scope (or module scope in TypeScript). So, when we call 'setValues', it sets the properties 'x' and 'y' on the global object (or module object) instead of the 'calculator' object.

But, the 'add' method is a normal function. So, when we call 'add', the 'this' inside 'add' refers to the 'calculator' object. Since the properties 'x' and 'y' of the 'calculator' object are still 0, the result is 0.

If the 'add' function was also an arrow function like this -

    const add  = () : number => {
        return this.x + this.y;
    };

Then, when we call 'add', the 'this' inside 'add' would also refer to the global object (or module object). So, it would add the properties 'x' and 'y' of the global object (or module object) which were set by the 'setValues' method. In this case, the output would be 30 as expected.

But, that is not what we want here. We want the 'add' and 'setValues' methods to operate on the 'calculator' object.

Normally, it is recommended not to use arrow functions as methods in an object or a class. Instead, we can use normal functions -

    function add(): number {
        return this.x + this.y;
    };

    function setValues(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

And now, when we call -

    calculator.setValues(10, 20);
    console.log(calculator.add());

We get the expected output of 30.

But, that's something we fixed for JavaScript. What about TypeScript?

Still, in the IDE, we will see an error for the 'this' keyword that we have used inside the functions 'add' and 'setValues'. The error will be -

    'this' implicitly has type 'any' because it does not have a type annotation.

So, how do we fix this error? How do we type 'this'?

Well, as it turns out, TypeScript allows us to explicitly type the 'this' keyword.

In TypeScript, in a method or function definition, an initial parameter named 'this' has special meaning in TypeScript. So, if we have a function or method in TypeScript like -

    function add(this, x, y): number {
        return this.x + this.y;
    };

Then, when it is compiled to JavaScript, the 'this' parameter is removed. So, the compiled JavaScript will look like -

    function add(x, y) {
        return this.x + this.y;
    };

This means, we can actually add a 'this' parameter to our functions and methods in TypeScript to type the 'this' keyword.

So, we can update our functions like this -

    function add(this: { x: number; y: number }): number {
        return this.x + this.y;
    };

    function setValues(this: { x: number; y: number }, x: number, y: number) {
        this.x = x;
        this.y = y;
    }

Now, there won't be any error for the type of 'this' keyword.

Remember that you cannot do this on arrow functions in TypeScript. In case of arrow functions, there is no 'this' parameter. If you try to add a 'this' parameter to an arrow function, you will get an error like -

    An arrow function cannot have a 'this' parameter