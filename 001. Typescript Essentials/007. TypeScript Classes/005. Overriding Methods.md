In the derived classes, we can actually override the methods of the base class. We do this by defining a method in the derived class with the same name as the method in the base class.

For example, let's say we have a base class  'Animal' with a method 'makeSound', and we want to create derived classes 'Dog' and 'Cat' that override this method:

    class Animal {
        makeSound() {
            console.log("Some generic animal sound");
        }
    }

    class Dog extends Animal {
        makeSound() {
            console.log("Woof! Woof!");
        }
    }

    class Cat extends Animal {
        makeSound() {
            console.log("Meow! Meow!");
        }
    }

Notice how both 'Dog' and 'Cat' classes have their own implementation of the 'makeSound' method. When we call this method on instances of these classes, the overridden methods will be executed instead of the base class method.

    const myDog = new Dog();
    myDog.makeSound(); // Output: Woof! Woof!

    const myCat = new Cat();
    myCat.makeSound(); // Output: Meow! Meow!

# PROTECTED ACCESS MODIFIER

And since we are talking about base and derived classes here, let's also talk about the 'protected' access modifier. The 'protected' access modifier allows a member to be accessible within its class and by derived class instances. This is useful when you want to allow derived classes to access certain members of the base class, but you don't want those members to be accessible from outside the class hierarchy.

For example, let's say we have a base class 'Person' with a protected member 'name', and we want to create a derived class 'Employee' that can access this member:

    class Person {
        protected name: string;

        constructor(name: string) {
            this.name = name;
        }

        getName() {
            return this.name;
        }
    }

    class Employee extends Person {
        private employeeId: number;

        constructor(name: string, employeeId: number) {
            super(name);
            this.employeeId = employeeId;
        }

        getEmployeeDetails() {
            return `Name: ${this.name}, Employee ID: ${this.employeeId}`;
        }
    }

Here, the 'name' member is protected, so it can be accessed within the 'Person' class and the 'Employee' class, but not from outside these classes.

    const emp = new Employee("Alice", 123);
    console.log(emp.getEmployeeDetails()); // Output: Name: Alice, Employee ID: 123
    
    // console.log(emp.name); // Error: Property 'name' is protected and only accessible within class 'Person' and its subclasses.

This is different from 'private' because if the name was 'private' inside the 'Person' class, then even the 'Employee' class would not be able to access it.

And it is not just the properties that can be protected, methods can also be protected. This allows derived classes to override protected methods of the base class.

    class Person {
        protected name: string;

        constructor(name: string) {
            this.name = name;
        }

        protected getName() {
            return this.name;
        }
    }

    class Employee extends Person {
        private employeeId: number;

        constructor(name: string, employeeId: number) {
            super(name);
            this.employeeId = employeeId;
        }

        getEmployeeDetails() {
            return `Name: ${this.getName()}, Employee ID: ${this.employeeId}`;
        }
    }

So, can we override a protected method in the derived class? Yes, we can. Here's how:

    class Person {
        protected name: string;

        constructor(name: string) {
            this.name = name;
        }

        protected getName() {
            return this.name;
        }
    }

    class Employee extends Person {
        private employeeId: number;

        constructor(name: string, employeeId: number) {
            super(name);
            this.employeeId = employeeId;
        }

        // Overriding the protected method
        protected getName() {
            return `Employee Name: ${this.name}`;
        }

        getEmployeeDetails() {
            return `${this.getName()}, Employee ID: ${this.employeeId}`;
        }
    }

# noImplicitOverride

There is a configuration option in TypeScript called 'noImplicitOverride'. When this option is enabled, TypeScript will require you to explicitly mark methods in derived classes that override methods in the base class with the 'override' keyword. This helps to catch errors where you might accidentally create a new method instead of overriding an existing one.

Now, after we enable it in our tsconfig.json file, we need to add the 'override' keyword to the overridden method in the 'Employee' class:

    class Person {
        protected name: string;

        constructor(name: string) {
            this.name = name;
        }

        protected getName() {
            return this.name;
        }
    }

    class Employee extends Person {
        private employeeId: number;

        constructor(name: string, employeeId: number) {
            super(name);
            this.employeeId = employeeId;
        }

        // Overriding the protected method
        override protected getName() {
            return `Employee Name: ${this.name}`;
        }

        getEmployeeDetails() {
            return `${this.getName()}, Employee ID: ${this.employeeId}`;
        }
    }

If we do not add this keyword, TypeScript will give us an error indicating that we are trying to override a method without explicitly marking it as an override -

    This member must have an 'override' modifier because it overrides a member in the base class 'Person'

This is quite useful because it helps to ensure that our intentions are clear and that we are not accidentally creating new methods when we mean to override existing ones. Because what if we change the name of the method in our BaseClass? If we are not explicitly telling TypeScript that we are overriding a method, it will not catch this error and we might end up with unexpected behavior in our code.

For example, if we change the name of 'getName' to 'fetchName' -

    class Person {
        protected name: string;

        constructor(name: string) {
            this.name = name;
        }

        protected fetchName() { // Changed from getName to fetchName
            return this.name;
        }
    }

    class Employee extends Person {
        private employeeId: number;

        constructor(name: string, employeeId: number) {
            super(name);
            this.employeeId = employeeId;
        }

        // Overriding the protected method
        override protected getName() { // Error: This member cannot have an 'override' modifier because it is not declared in the base class 'Person'.
            return `Employee Name: ${this.name}`;
        }

        getEmployeeDetails() {
            return `${this.getName()}, Employee ID: ${this.employeeId}`;
        }
    }

Now, we will get an error because 'getName' is no longer a method in the base class 'Person', and we are trying to override a method that does not exist. This helps us catch the error early and fix it before it causes any issues in our code.

If we did not have the 'noImplicitOverride' option enabled, we would not get any error, and the 'getName' method in the 'Employee' class would simply be treated as a new method, which could lead to unexpected behavior when we try to call it.