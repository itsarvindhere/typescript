Let's take another interesting example of mapped types by transforming a discriminated union into a union.

Let's say we have -

    type Fruit = 
    | { name: 'apple'; color: 'red' }
    | { name: 'banana'; color: 'yellow' }
    | { name: 'grape'; color: 'purple' }
    | { name: 'orange'; color: 'orange' };

Here, 'Fruit' is a discriminated union where each object has a 'name' and a 'color'. Now, suppose we want to transform this union into a union like this -

    "apple:red" | "banana:yellow" | "grape:purple" | "orange:orange"

Well, it sounds like a small challenge as previous challenges.

First, let's try to map over each member of the union -

    type FruitInfo = {
      [F in Fruit]: string;
    };

Well, we will get an error here because the keys have to be of type 'string | number | symbol'. And as we learnt before, we can use key remapping to solve this problem.

    type FruitInfo = {
      [F in Fruit as F['name']]: string;
    };

If we hover over 'FruitInfo', we will see -

    type FruitInfo = {
        apple: string;
        banana: string;
        grape: string;
        orange: string;
    }

Alright, now we want to create the values in the format "name:color". We can do that by using template literal types.

    type TransformedFruit = {
        [F in Fruit as F['name']]: `${F['name']}:${F['color']}`
    }

Here, we are using template literal types to create the desired format for each fruit.

So, we will get -

    type TransformedFruit = {
        apple: "apple:red";
        banana: "banana:yellow";
        grape: "grape:purple";
        orange: "orange:orange";
    }

And now comes the final piece of the puzzle. We want to convert this object type into a union of its values. We can achieve this by using the 'keyof' operator along with indexed access types.

    type FruitUnion = TransformedFruit[Fruit['name']];

Remember that if we access some property of a union type, TypeScript will give us a union of the values of that property from each member of the union. That's why in this case, 'Fruit['name']' gives us the union of all fruit names -

    Fruit['name'] => "apple" | "banana" | "grape" | "orange

So, we can pass this union of names to 'TransformedFruit' to get the union of corresponding values.

And this will give us -

    type FruitUnion = "apple:red" | "banana:yellow" | "grape:purple" | "orange:orange"

And if we want to do it in one go, we can combine all the steps together -

    type TransformedFruit = {
        [F in Fruit as F['name']]: `${F['name']}:${F['color']}`
    }[Fruit['name']];

And well, that's it!

So, to summarize, we transformed a discriminated union into a union of formatted strings by using mapped types, key remapping, template literal types, and indexed access types.