Alright, let's take another example where this time, instead of starting with a union type, we start with an object type.

Let's say we have -

    interface Attributes {
        firstName: string;
        lastName: string;
        age: number;
    }

Now, we want to create an object such that the key is the key of the 'Attributes' type, and the value is a function that returns the type of that key in 'Attributes'. That is -

    {
        firstName: () => string;
        lastName: () => string;
        age: () => number;
    }

Remember that we know how to get the keys of an object type using 'keyof'. And sine 'keyof' gives us a union type, we also know in the previous example how to iterate over a union type using mapped types.

Finally, if we know the key of an object, we know that we can use Index Access to get the type of that key in the object.

So, let's combine these two concepts together -

    type AttributeGetters = {
        [K in keyof Attributes]: () => Attributes[K];
    }

Here, we are iterating over each key 'K' in the keys of 'Attributes', and for each key, we are creating a function that returns the type of that key in 'Attributes' using Index Access.

In this way, we get -

    {
        firstName: () => string;
        lastName: () => string;
        age: () => number;
    }

Isn't this powerful? The mapped types are one of the most powerful features in TypeScript that allow us to create new types based on existing ones with ease.