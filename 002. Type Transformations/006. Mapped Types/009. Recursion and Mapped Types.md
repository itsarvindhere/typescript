Let's try a problem.

Let's say we have an object type which has nested properties -

    type MyType = {
        a: string;
        b: number;
        c: {
            d: string;
            e: {
                f: string;
                g: {
                    h: string;
                    i: string;
                }[];
            };
        };
    };

Here, we can see that property 'c' is an object which has a property 'e' which is also an object which has a property 'g' which is an array of objects.

Now, the task is that we want to make all the properties optional, including the nested properties.

That is, we want something like -

    type MyTypeOptional = {
        a?: string;
        b?: number;
        c?: {
            d?: string;
            e?: {
                f?: string;
                g?: {
                    h?: string;
                    i?: string;
                }[];
            };
        };
    };

Now, we know that to make the properties of an object type optional, we can use the 'Partial' utility type. But 'Partial' only works on the first level of properties and does not go deep into nested objects.

    type MyTypePartial = Partial<MyType>;

This will give us -

    type MyTypePartial = {
        a?: string | undefined;
        b?: number | undefined;
        c?: {
            d: string;
            e: {
                f: string;
                g: {
                    h: string;
                    i: string;
                }[];
            };
        } | undefined;
    }

Notice that the properties inside 'c' are still required. So, it only works on the first level.

What if we want to make all the properties optional, including the nested ones?

Let's talk about Recursion and Mapped Types to solve this problem.

What is Recursion in TypeScript?

In general programming, recursion is a technique where a function calls itself in order to solve a problem. In TypeScript, we can use recursion in type definitions as well.

Basically, this is what we want to do -

    1. Go over each property of the object type.
    2. If this property is itself an object type, then we want to apply the same logic to that property (i.e., make its properties optional as well).
    3. If not, then just make this property optional.

We can actually do this by calling our own type inside its definition, which is the essence of recursion -

    type DeepPartial<T> = {
        [K in keyof T]?: DeepPartial<T[K]>;
    }

This gives us -

    type MyTypePartial = {
        a?: string | undefined;
        b?: number | undefined;
        c?: {
            d?: string | undefined;
            e?: {
                f?: string | undefined;
                g?: ({
                    h?: string | undefined;
                    i?: string | undefined;
                } | undefined)[] | undefined;
            } | undefined;
        } | undefined;
    }

So, what happened here?

First, we defined a generic type 'DeepPartial' which takes a type parameter 'T'.

Then, we used a mapped type to iterate over each property 'K' in 'T' using 'keyof T'.

For each property 'K', we made it optional using the '?' modifier.

Then, we recursively applied 'DeepPartial' to 'T[K]'.

You might ask that what happens when 'T[K]' is not an object type? For example, when it's a string or number?

To answer this, what will happen if we have -

    type Test1<T> = {
        [K in keyof T]?: T[K]
    }

    type X = Test1<string>;

What do you think will be the type of 'X'?

Well, it will be -

    type X = string;

So, TypeScript will just return the original type.

This is how TypeScript is designed to work. You can read more here - https://github.com/microsoft/TypeScript/pull/12447

In this pull request, you will see that it says -

    A mapped type of the form { [P in keyof T]: X }, where T is some type parameter, is said to be an isomorphic mapped type because it produces a type with the same shape as T. With this PR we make instantiations of isomorphic mapped types distributive over union types. For example, when { [P in keyof T]: X } is instantiated with A | B for T, we produce { [P in keyof A]: X } | { [P in keyof B]: X }.
    
    Furthermore, when a primitive type is substituted for T in an isomorphic mapped type, we simply produce that primitive type. For example, when { [P in keyof T]: X } is instantiated with A | undefined for T, we produce { [P in keyof A]: X } | undefined.

Notice the last line - When a primitive type is substituted for T in an isomorphic mapped type, we simply produce that primitive type.

So, when we do 'DeepPartial<string>', it will just return 'string'.

So coming back to our original problem, when we do 'DeepPartial<T[K]>', if 'T[K]' is a primitive type like string or number, it will just return that type. If it's an object type, it will recursively apply 'DeepPartial' to it.

Alright so looks like we are done right?

Well, there is one problem. If you notice, we get the type as -


    type MyTypePartial = {
        a?: string | undefined;
        b?: number | undefined;
        c?: {
            d?: string | undefined;
            e?: {
                f?: string | undefined;
                g?: ({
                    h?: string | undefined;
                    i?: string | undefined;
                } | undefined)[] | undefined;
            } | undefined;
        } | undefined;
    }

If you see, it also make 'g' an array that can accept 'undefined' as an element. But this is not what we want. We still want 'g' to be an array of objects, but the objects inside should have optional properties.

So, how do we fix this?

Well, it looks like we have to check if the property of the object on which we want to apply 'DeepPartial' is an array. If it is an array, then we have to handle it differently.

We can do -

    type DeepPartial<T> = {
        [K in keyof T]?: T[K] extends Array<infer U> ? Array<DeepPartial<U>> : DeepPartial<T[K]>;
    }

Let's break it down.

When we pass 'MyType' to 'DeepPartial', it will iterate over each property.

When it reaches property 'g', it will check if it extends 'Array<infer U>'. Since 'g' is indeed an array, this condition will be true.

So, instead of calling 'DeepPartial<T[K]>', it will call 'Array<DeepPartial<U>>', where 'U' is the type of the elements inside the array.

So, instead of making 'g' an array that can accept 'undefined' as an element, it will make 'g' an array of objects where the properties of those objects are optional.

Yes, this is slightly complex to grasp at first, but with practice, you will get the hang of it.

So basically, this is what we did -

    1. We defined a generic type 'DeepPartial' which takes a type parameter 'T'.
    2. We used a mapped type to iterate over each property 'K' in 'T' using 'keyof T'.
    3. For each property 'K', we made it optional using the '?' modifier.
    4. We checked if 'T[K]' extends 'Array<infer U>'.
        - If true, we returned 'Array<DeepPartial<U>>'.
        - If false, we returned 'DeepPartial<T[K]>'.

Here we used 'infer' because we wanted to extract the type of the elements inside the array. 'infer U' allows us to do that. So if we know the type of the elements inside the array, we can apply 'DeepPartial' to that type.