Alright, in the last section, we learnt all about the Conditional Types in TypeScript and the 'infer' keyword.

Now, it is time to learn about Mapped Types.

As the name suggests, Mapped Types allow us to create new types by transforming existing ones. They are particularly useful when we want to create a new type based on an existing type or a union of types.

Let's start with a simple example.

Let's say we have a union type -

    type Route = "/" | "/about" | "/admin" | "/admin/users";

We want to create an object from this Union Type such that the keys and the values are both the same as the union members. That is, our object will look like -

    {
      "/": "/";
      "/about": "/about";
      "/admin": "/admin";
      "/admin/users": "/admin/users";
    }

The first approach is to manually create the object type like this -

    type RouteObject = {
      "/": "/";
      "/about": "/about";
      "/admin": "/admin";
      "/admin/users": "/admin/users";
    };

But the issue here is that if we add a new route to the Route union type, we will have to manually update the RouteObject type as well. This is not scalable and can lead to errors.

Well, here we can use the 'Mapped Types' to automate this process.

The solution is pretty straightforward. We can use the following syntax -

    type ObjectRoute = { 
        [R in Route]: R
    }

What just happened here?

Here, we are using a mapped type to iterate over each member of the 'Route' union type. The syntax [R in Route] means "for each 'R' in the union type Route". For each 'R', we are creating a key-value pair where both the key and the value are 'R'.

And that's how we can create an object type from a union type using Mapped Types in TypeScript!