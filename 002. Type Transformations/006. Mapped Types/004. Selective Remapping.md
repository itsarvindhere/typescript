Alright, let's take a slightly more complex example. Imagine we have a type -

    interface Example {
        name: string;
        age: number;
        id: string;
        organizationId: string;
        groupId: string;
    }

We want to create an object but that object will have the keys as only those keys from 'Example' that contain "id" or "Id". That is, we should get -

    {
        id: string;
        organizationId: string;
        groupId: string;
    }

So, how to conditionally pick only those keys that contain "id" or "Id"?

Well, as you might have guessed, we can use 'Mapped Types' along with 'Conditional Types' to achieve this.

We know that if we only had to get all the keys from 'Example', we could do -

    type AllKeys = {
        [K in keyof Example]: Example[K];
    }

But now, we want to make sure that we only pick those keys that contain "id" or "Id". We can use the 'extends' keyword to check if the key contains "id" or "Id".

We know that in conditional types we can use template literal types to check for substrings. Suppose if we wanted to create a helper type which should check if a string contains "id" or "Id" and based on that return us the Type itself or never.

We could do something like this -

    type CheckForId<T> = T extends `${string}${'id' | 'Id'}${string}` ? T : never;

Well, we can use this helper type inside our mapped type to filter out the keys.

Remember that in mapped types, we can use the 'as' keyword to remap keys.

But, what if a key is remapped as 'never'?

Let's try that -

    type X = {
        [K in keyof Example as never]: Example[K];
    }

Well, if you hover over 'X', you'll see that it is an empty object type {}. This means that if we remap a key to 'never', it effectively removes that key from the resulting type.

And this is a very important observation!

So, this is what we observed so far -

    1. We can use template literal types in conditional types to check if a string contains a certain substring.
    2. In mapped types, we can use the 'as' keyword to remap keys.
    3. If we remap a key to 'never', it removes that key from

So, let's use these observations to create our desired type -

    type CheckForId<T> = T extends `${string}${'id' | 'Id'}${string}` ? T : never;

    type IdKeysOnly = {
        [K in keyof Example as CheckForId<K>]: Example[K];
    }

Here, we are iterating over each key 'K' in 'Example', and using our 'CheckForId' type to check if 'K' contains "id" or "Id". If it does, we keep the key as is; otherwise, it gets remapped to 'never' and thus removed.

And boom! Now, if you hover over 'IdKeysOnly', you'll see that it gives you the desired type -

    {
        id: string;
        organizationId: string;
        groupId: string;
    }

We can do all this in one type without needing a separate helper type as well -

    type IdKeysOnly = {
        [K in keyof Example as K extends `${string}${'id' | 'Id'}${string}` ? K : never]: Example[K];
    }

But sometimes, breaking it down into smaller helper types makes it more readable.