In the last example, we took ab object type and used a mapped type to create a new type with the same keys but different value types.

But, a lot of the time, we want to transform the keys themselves. For example, if we take the same example as before -

    interface Attributes {
        firstName: string;
        lastName: string;
        age: number;
    }

What if we want ab object like this -

    {
        getFirstName: () => string;
        getLastName: () => string;
        getAge: () => number;
    }

Notice that here, we've prefixed each key with "get". Moreover, the first letter of each key has been capitalized.

So, how do we change the keys in a mapped type? Well, we can do that using the 'as' keyword.

    type AttributeGetter = {
        [K in keyof Attributes as `get${K}`]: () => Attributes[K];
    }

here, we are saying that for each key K in the keys of Attributes, we want to create a new key by transforming K into 'get${K}'. The value type remains the same as before. This gives us -

    type AttributeGetter = {
        getfirstName: () => string;
        getlastName: () => string;
        getage: () => number;
    }

But as we can see, there is still one missing piece - the first letter of each key is not capitalized. To achieve that, we can use the 'Capitalize' utility type provided by TypeScript.

    type AttributeGetter = {
        [K in keyof Attributes as `get${Capitalize<K>}`]: () => Attributes[K];
    }

Here, we are using 'Capitalize<K>' to transform the first letter of each key K to uppercase. This gives us the final desired type -

    type AttributeGetter = {
        getFirstName: () => string;
        getLastName: () => string;
        getAge: () => number;
    }