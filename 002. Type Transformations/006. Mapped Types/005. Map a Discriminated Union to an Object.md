Let's now look at 'Discriminated Unions' and how we can map them to an object type using mapped types in TypeScript.


Let's say we have -

    type Route = 
        | {
            route: "/";
            search: {
                page: string;
                perPage: string
            };
        }
        | { route: "/about", search: {} }
        | { route: "/admin", search: {} }
        | { route: "/admin/users", search: {} }

This is a discriminated union where each type in the union has a common property 'route' that acts as a discriminator.

Now, we want to create an object which is something like -

    {
        "/": { page: string; perPage: string };
        "/about": {};
        "/admin": {};
        "/admin/users": {};
    }

Essentially, we want to map each 'route' to its corresponding 'search' type.

# FIRST SOLUTION

First, we need to think of how we can take the 'route' property and use it as a key in our resulting object type. Well, since we already have our object type and we know that each union member has a 'route' property, we can use a mapped type along with an indexed access type to achieve this.

    type RoutesObject = {
        [R in Route['route']]: string;
    }

For now, let's just map each route to a string type to see how this works.

If you hover over 'RoutesObject', you'll see that TypeScript has created an object type with keys as the routes and values as string -

    type RoutesObject = {
        "/": string;
        "/about": string;
        "/admin": string;
        "/admin/users": string;
    }

The next step is to think of how we can access the 'search' property for each route.

Remember, right now, we have 'R' which is each route string. We also have the 'Route' union type. How can we 'Extract' the 'search' property for each route?

Well, as we know, we can use the 'Extract' utility type for this. The 'Extract' type allows us to extract types from a union that are assignable to a specific type. Since each member of the union has a 'route' property, we can use 'Extract' to get the specific member of the union that matches the current route 'R'.

That is -
    
    Extract<Routes, { route: R}>

Here, 'Extract' will go through each member of the 'Route' union and check if it matches the condition '{ route: R }'. If it does, that member is included in the resulting type; otherwise, it's excluded. Remember that 'R' here is each route string.

So, in case of R = "/", 'Extract<Route, { route: "/" }>' will give us -

    {
        route: "/";
        search: {
            page: string;
            perPage: string
        };
    }

So, 'Extract' will give us an object. Now, from this object, we need to access the 'search' property. We can do this using indexed access types.

So, putting all this together, we get -

    type RoutesObject = {
        [R in Route['route']]: Extract<Route, { route: R }>['search'];
    }

And this gives us -

    type RoutesObject = {
        "/": {
            page: string;
            perPage: string;
        };
        "/about": {};
        "/admin": {};
        "/admin/users": {};
    }

But, this solution is a bit verbose.

# SECOND SOLUTION

So, this is what we did -

    type RoutesObject = {
        [R in Route['route']]: Extract<Route, { route: R }>['search'];
    }

The reason why we had to use 'Extract' is because 'R' is just a string type, and the reason is that we specifically iterated over 'Route['route']'.

What if we iterate over each object instead?

That is, what if we do -

    R in Route

In that case, since 'R' will be each object in the union, we can directly access the 'search' property without needing to use 'Extract'.

    type RoutesObject = {
        [R in Route]: R['search'];
    }

Well, we see an error here -

    Type 'Route' is not assignable to type 'string | number | symbol'.
    Type '{ route: "/"; search: { page: string; perPage: string; }; }' is not assignable to type 'string | number | symbol'

If you think about it, it makes sense because here, 'R' is each object in the union, and object types cannot be used as keys in an object type. But in our case, we just want the 'route' property of each object to be the key.

So, why not use key remapping here for that? 

    type RoutesObject = {
        [R in Route as R['route']]: R['search'];
    }

And boom! That's it!

This is much cleaner and easier to understand than our first solution. This example shows how powerful the mapped types can be when combined with discriminated unions, indexed access types and key remapping.

This also shows that it is not always necessary that the thing we are iterating over in a mapped type has to be string | number | symbol type. We can always remap it to something else using key remapping.