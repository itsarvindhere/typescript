Let's take a similar example as the previous one. 

Let's say we have -

    interface FruitMap {
        apple: "red";
        banana: "yellow";
        grape: "purple";
        orange: "orange";
    }

We want to create a type called 'TransformedFruit' that gives us a union of template literal types like this-

    type TransformedFruit = "orange:orange" | "apple:red" | "banana:yellow" | "grape:purple"

Basically, we want to transform each key-value pair in the 'FruitMap' object into a template literal type of the form "key:value" and then create a union of all these template literal types.

Let's start with the first step which is to create a mapped type that transforms each key-value pair into the desired template literal type.

    type TransformedFruit = {
        [K in keyof FruitMap]: `${K}:${FruitMap[K]}`
    }

Here, we are using a mapped type to iterate over each key in the 'FruitMap' interface. For each key (K), we create a template literal type '${K}:${FruitMap[K]}' which combines the key and its corresponding value.

So, we get -

    type TransformedFruit = {
        apple: "apple:red";
        banana: "banana:yellow";
        grape: "grape:purple";
        orange: "orange:orange";
    }

And now, from this, we just want a union of all the values. And this is something we did in the previous example where we re-indexed the mapped type with 'keyof' to get a union of all the values.

So, we can do -

    type TransformedFruit = {
        [K in keyof FruitMap]: `${K}:${FruitMap[K]}`
    }[keyof FruitMap];

To make it simpler to read, we can break it down into two steps -

    type MappedFruit = {
        [K in keyof FruitMap]: `${K}:${FruitMap[K]}`
    };

    type TransformedFruit = MappedFruit[keyof FruitMap];

And that's it. Once again, it shows how powerful TypeScript's mapped types can be when it comes to transforming types in creative ways!