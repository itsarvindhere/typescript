Well, there is one gotcha with conditional types in typescript.

Let's say we have a union type like this:

    type Fruit = "apple" | "banana" | "orange";

And we want to create a type that only includes "apple" and "banana". We might try to do something like this:

    type AppleOrBanana = Fruit extends "apple" | "banana" ? Fruit : never;

At first glance, we might expect 'AppleOrBanana' to be equivalent to "apple" | "banana". But, if you hover over 'AppleOrBanana', you'll see that it actually resolves to -

    type AppleOrBanana = never

Wait, what?

# DISTRIBUTIVITY IN CONDITIONAL TYPES

There is a concept called 'Distributive Conditional Types' in TypeScript.

As per the official documentation:

    When conditional types act on a generic type, they become distributive when given a union type.
    
For example, take the following:

    type ToArray<T> = T extends any ? T[] : never;

Gere, we have  a conditional type 'ToArray' that takes a type 'Type' and checks if it extends 'any'. If it does, it returns an array of that type; otherwise, it returns 'never'.

    type StrArrOrNumArr = ToArray<string | number>;

Now, you might have expected that we will get -

    type StrArrOrNumArr = (string | number)[]

But, if you hover over 'StrArrOrNumArr', you'll see that it actually resolves to -

    type StrArrOrNumArr = string[] | number[]

So, instead of getting an array that can contain both strings and numbers, we get a union of two separate array types: one for strings and one for numbers.

Now, what happens here is that TypeScript distributes the conditional type over each member of the union type. So, it evaluates 'ToArray<string>' and 'ToArray<number>' separately, resulting in 'string[] | number[]'.

Remember that this happens only when the conditional type is applied to a generic type parameter. If you apply it directly to a union type, it won't distribute.

If you do not want this distributive behavior, you can surround each side of the extends keyword with square brackets -

    type ToArrayNonDistributive<T> = [T] extends [any] ? T[] : never;

In this case, if you do -

    type StrArrOrNumArrNonDistributive = ToArrayNonDistributive<string | number>;

You will get -

    type StrArrOrNumArrNonDistributive = (string | number)[]

So here, by wrapping 'T' in square brackets, we prevent TypeScript from distributing the conditional type over the union members.

# OUR EXAMPLE

Now, one thing that you will notice in our example is that we are not passing any type parameter to the conditional type. So, we are not doing -
    
    type AppleOrBanana<T> = T extends "apple" | "banana" ? T : never;

    type Fruit = "apple" | "banana" | "orange";
    type Result = AppleOrBanana<Fruit>;

In this case, we would get -

    type Result = "apple" | "banana"

But, in our original example, we are not using a type parameter. Instead, we are directly using the union type 'Fruit' in the conditional type -

    type AppleOrBanana = Fruit extends "apple" | "banana" ? Fruit : never;

And here, we are getting -

    type AppleOrBanana = never;

Remember that distributive conditional types only work when the conditional type is applied to a generic type parameter. Since we are not using a type parameter in our original example, TypeScript does not distribute the conditional type over the union members, and hence we get 'never' as the result.

In our case, the conditional type checks if the entire union type 'Fruit' (which is "apple" | "banana" | "orange") extends "apple" | "banana". Since it does not (because of the "orange" member), the result is 'never'.

And we can prove this if we remove "orange" from the 'Fruit' type:

    type Fruit = "apple" | "banana";

    type AppleOrBanana = Fruit extends "apple" | "banana" ? Fruit : never;

In this case, 'AppleOrBanana' will correctly resolve to "apple" | "banana" because now the entire union type 'Fruit' does extend "apple" | "banana".

Similarly, if we have a single member union type:

    type Fruit = "apple";

    type AppleOrBanana = Fruit extends "apple" | "banana" ? Fruit : never;

In this case, 'AppleOrBanana' will resolve to "apple" because the entire union type 'Fruit' (which is just "apple") does extend "apple" | "banana".

And that's how distributivity in conditional types works in TypeScript!

This is a very important concept to understand when working with conditional types, as it can lead to unexpected results if you're not aware of how it operates.

There is a really weird solution if you do not want to use a type parameter. You can wrap the type in a tuple to prevent distributivity:

    type AppleOrBanana = Fruit extends infer T 
    ? T extends "apple" | "banana" 
        ? T 
        : never 
    : never;

Here, we are using 'infer' to create a type variable 'T' that represents the entire 'Fruit' type. Then, we check if 'T' extends "apple" | "banana". If it does, we return 'T'; otherwise, we return 'never'.

Now it works because now 'T' is in a generic context, and TypeScript will distribute the conditional type over the union members of 'T'.