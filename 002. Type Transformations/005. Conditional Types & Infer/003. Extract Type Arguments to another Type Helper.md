Let's do something interesting.

Suppose, we have an interface -

    interface MyComplexInterface<Event, Context, Name, Point> {
        getEvent: () => Event;
        getContext: () => Context;
        getName: () => Name;
        getPoint: () => Point;
    }

    type Example = MyComplexInterface<
        "click",
        "window",
        "my-event",
        { x: 12; y: 14}
    >

We have a generic interface with 4 type parameters - 'Event', 'Context', 'Name', and 'Point'. Each of these type parameters is used as the return type of a method in the interface.

Then, we have a type alias named 'Example' which is of type 'MyComplexInterface' with the type arguments - '"click"', '"window"', '"my-event"', and '{ x: 12; y: 14}'.

Now, what we want is to create a Type Helper named 'GetPoint' which takes a type parameter 'T' and if 'T' is of type 'MyComplexInterface' with some type arguments, we want to extract the fourth type argument (i.e., 'Point') and return it. If 'T' is not of type 'MyComplexInterface', we want to return 'never'.

So, let's say we have -

    type GetPoint<T> = unknown;

We should be able to use 'GetPoint' like this -

    type P1 = GetPoint<Example>; // { x: 12; y: 14 }
    type P2 = GetPoint<MyComplexInterface<number, string, boolean, Date>>; // Date
    type P3 = GetPoint<string>; // never
    type P4 = GetPoint<{}>; // never

How do we implement 'GetPoint' such that it extracts the return type of the 'getPoint' method from the interface type passed to it? In simpler words, we want the fourth type parameter of the interface type which is 'Point'.

Well, one way is to use Indexed Access Types along with Conditional Types -

    type GetPoint<T> = T extends MyComplexInterface<any, any, any, any> 
        ? ReturnType<T['getPoint']> 
        : never;

Here, we are checking if 'T' extends 'MyComplexInterface' with all type parameters as 'any'. If it does, we use Indexed Access Types to access the 'getPoint' method of 'T' and then use the built-in 'ReturnType' utility type to extract the return type of that method. If 'T' does not extend 'MyComplexInterface', we return 'never'.

But, as we learned in the previous example, we can use the 'infer' keyword to make this extraction more elegant -

    type GetPoint<T> = T extends MyComplexInterface<any, any, any, infer TPoint> 
        ? TPoint 
        : never;

Here, we are using 'infer TPoint' to infer the fourth type parameter of 'MyComplexInterface' when 'T' extends it. If 'T' does extend 'MyComplexInterface', we return the inferred type 'TPoint'. If it doesn't, we return 'never'.

Here, the benefit of this approach is that we do not have to know the name of the method ('getPoint') to extract the type. We are directly inferring the type parameter from the interface type itself.

If we had used the first approach with Indexed Access Types, we would have to know the name of the method to extract the type. Even with that, what if in the future, the method name changes? We would have to change our 'GetPoint' type helper as well otherwise TypeScript would complain. But with the 'infer' approach, we are directly inferring the type parameter from the interface type itself, making it more robust to changes in method names.
