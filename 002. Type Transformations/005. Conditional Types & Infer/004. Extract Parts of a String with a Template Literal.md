Let's take a look at how we can extract parts of a string using TypeScript's template literal types combined with conditional types and the 'infer' keyword.

Suppose, we have a type which is a tuple with literal string types representing names -

    type Name = [
        "John Cena",
        "Matt Hardy",
        "Jeff Hardy",
        "The Undertaker",
        "Kane"
    ];

Here, we have a tuple type 'Name' that contains several string literals representing names.

Now, we want to create a Type Helper named 'GetSurname' to which, if we pass a full name string, it will extract and return the surname part of that name. If the name does not have a surname or is not a string at all, it should return 'never'.

For example we should be able to use it like -

    type Surname1 = GetSurname<Name[0]>; // Expected to be "Cena"
    type Surname2 = GetSurname<Name[4]>; // Expected to be never
    type Surname3 = GetSurname<Name[1]>; // Expected to be "Hardy"

To achieve this, we can define the 'GetSurname' type helper using conditional types and template literal types.

We know that if our Type Helper accepts a type 'T', then that 'T' should have a specific structure. We can define this structure using a template literal type like this -

    `${string} ${string}`

Now, we want to ensure that our type 'T' adheres to this structure. If it does, we can use the 'infer' keyword to extract the surname part. Here's how we can implement the 'GetSurname' type helper -

    type GetSurname<T> = T extends `${infer TFirstName} ${infer TSurname}` ? TSurname : never;

Notice how we used the 'infer' keyword to create a new type variable 'TSurname' that captures the part of the string after the space. In this way, if 'T' matches the pattern of having a first name and a surname separated by a space, 'TSurname' will hold the surname part. This shows how powerful 'infer' can be.