In the previous section, we learnt all about the 'Type Helper' pattern in TypeScript. We saw how we can create reusable type transformations that can be applied to different types. 

However, sometimes we may want to add some conditional logic to our type helpers to make them more flexible and powerful.

Take the regular functions as an example. Yes, they can take some parameters and return something but that 'something' can also be different based on some conditions.

Can we do something like that in case of Type Helpers as well? Well, we can.

Let's say we have a Type Helper -

    type YouSayGoodbyeAndISayHello = unknown;

Right now, we have not defined any logic inside this Type Helper. It is just a placeholder.

We want to use it in such a way that if we pass it a literal string type "Hello", it should return "Goodbye" and if we pass it "Goodbye", it should return "Hello".

Something like -

    type X = YouSayGoodbyeAndISayHello<"Hello">; // should return "Goodbye"
    type Y = YouSayGoodbyeAndISayHello<"Goodbye">; // should return"Hello"

So, how do we do that?

Here, we have a condition. We have to first check if the input type is "Hello" or "Goodbye" and then return the corresponding output type.

I am sure you know what ternary operators are in regular programming languages. They allow us to write conditional logic in a concise way.

For example in TypeScript/JavaScript, we can write -

    const result = condition ? valueIfTrue : valueIfFalse;

We can use a similar syntax in our Type Helper using 'Conditional Types'.

Okay, but what condition should be write? Let's say our type helper takes a type parameter 'T'.

How to check if 'T' is "Hello"? Well, we can use the 'extends' keyword to check if 'T' extends "Hello". Because if we pass "Hello" as 'T', then 'T' will indeed extend "Hello". But if we pass "Goodbye", then 'T' will not extend "Hello".

So, we can write -

    type YouSayGoodbyeAndISayHello<T> = T extends "Hello" ? "Goodbye" : "Hello";

Here, we are checking if 'T' extends "Hello". If it does, we return "Goodbye". Otherwise, we return "Hello".

So, now if we use this Type Helper -

    type X = YouSayGoodbyeAndISayHello<"Hello">; // "Goodbye"
    type Y = YouSayGoodbyeAndISayHello<"Goodbye">; // "Hello"

And now, we have created a 'Conditional Type' that can return different types based on the input type.

# REFINING THE EXAMPLE

So far, even if we pass any random string type, it will return "Hello". For example -

    type Z = YouSayGoodbyeAndISayHello<"RandomString">; // "Hello"

But, what if we want to ensure that if any other string than "Hello" or "Goodbye" is passed, it should return 'never'?

Looks like our single ternary condition is not enough. We need to add another condition to check if 'T' is "Goodbye".

Just like we can have nested if-else statements in regular programming, we can also have nested conditional types.

    type YouSayGoodbyeAndISayHello<T> = T extends "Hello" | "Goodbye" ? (T extends "Hello" ? "Goodbye" : "Hello") : never;

It looks pretty complex but let's break it down.

First, we are checking if 'T' extends either "Hello" or "Goodbye". If it does, we proceed to the next condition. If it doesn't, we return 'never'.

Then, inside the true branch of the first condition, we have another condition. We check if 'T' extends "Hello". If it does, we return "Goodbye". Otherwise, we return "Hello".

This is really powerful because now we can handle multiple conditions and return different types based on the input type.

We can write it in a cleaner way by using parentheses and indentation to improve readability -  

    type YouSayGoodbyeAndISayHello<T> = T extends "Hello" | "Goodbye"
        ? (T extends "Hello" ? "Goodbye" : "Hello") 
        : never;