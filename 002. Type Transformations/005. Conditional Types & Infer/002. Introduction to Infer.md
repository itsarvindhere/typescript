Let's say we want to create a Type Helper which takes the type passed to it and if that type is an object type with a 'data' property in it, we return the type of that 'data' property. If the type passed does not have a 'data' property, we want to return 'never'.

For example, if we have a Helper Type named 'GetDataValue', we want it to work like this:

    type A = GetDataValue<{ data: string }>; // string
    type B = GetDataValue<{ data: number[] }>; // number[]
    type C = GetDataValue<{ data: { name: 'John'} }>; // { name: 'John' }
    type D = GetDataValue<{ data: { name: 'John', age: 30 } }>; // { name: 'John', age: 30 }

So, notice how in each of the above examples, the type returned is the type of the 'data' property of the object type passed to 'GetDataValue'. If the type passed does not have a 'data' property, we want to return 'never'.

Well, based on our knowledge of Conditional Types, it should be pretty easy to do because we just want to check if 'T' is an object type which has a 'data' property in it. If it does, we return the type of that property using indexed access types. If it doesn't, we return 'never'.

We can do -

    type GetDataValue<T> = T extends { data: any} ? T['data'] : never;

Here, we are checking if 'T' extends an object type with a 'data' property of type 'any'. If it does, we return the type of that property using 'T['data']'. If it doesn't, we return 'never'.

It works fine.

This extraction of types is such a common pattern that TypeScript provides a way to do this more elegantly using the 'infer' keyword.

We can write -

    type GetDataValue<T> = T extends { data: infer TData} ? TData : never;

As the name suggests, using 'infer' allows us to infer a type within a Conditional Type. Here, we are saying that if 'T' extends an object type with a 'data' property, we want to infer the type of that property and name it 'TData'. Then, we can use 'TData' in the true branch of the Conditional Type to return the inferred type.

Remember that this 'TData' type is only available within the 'true' branch of the Conditional Type. If 'T' does not extend the object type with a 'data' property, we cannot access 'TData' in the 'false' branch. If you try to do that, TypeScript will give you an error saying that 'TData' is not defined.

The 'infer' keyword is very powerful and a lot of built-in utility types in TypeScript use it under the hood to extract types. For example, the built-in 'ReturnType' utility type uses 'infer' to extract the return type of a function type -

    type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

Here, we can see that 'infer R' is used to infer the return type of the function type 'T'. If 'T' is a function type, we return the inferred return type 'R'. If 'T' is not a function type, we return 'any'.

The same is the case for the 'Parameters' utility type which extracts the parameter types of a function type -

    type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

Notice how in this case, we are using 'infer P' to infer the parameter types of the function type 'T'. If 'T' is a function type, we return the inferred parameter types 'P' as a tuple type. If 'T' is not a function type, we return 'never'.