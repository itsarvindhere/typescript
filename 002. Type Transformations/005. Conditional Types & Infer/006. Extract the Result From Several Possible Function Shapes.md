So far, we have been using conditional types to extract the return type from a single function shape. However, in real-world scenarios, functions can have multiple overloads or shapes.

Let's say we have -

    const parser1 = {
        parse: () => 1
    };

    const parser2 = () => "123";

    const parse3 = {
        extract: () => true
    }

So here, we have three different "parsers" with different shapes. We want to create a type that can extract the return type from any of these shapes.

Let's call it 'GetParserResult'.

So, we want something like -

    type Result1 = GetParserResult<typeof parser1>; // expected to be number
    type Result2 = GetParserResult<typeof parser2>; // expected to be string
    type Result3 = GetParserResult<typeof parse3>; // expected to be boolean

Well, we can define 'GetParserResult' using conditional types and the 'infer' keyword to handle multiple function shapes. Our function can have one of the two shapes: either an object with a method or a standalone function.

So, we can define 'GetParserResult' like this -

    type GetParserResult<T> = T extends () => infer R ? R
        : T extends { [key: string]: () => infer R } ? R : never;

Here, we first check if 'T' is a standalone function. If it is, we infer its return type 'R'. If not, we check if 'T' is an object with any method that returns a value, and we infer that return type 'R'. If neither condition is met, we return 'never'.

There is another way to do this and that is use a Union type to check for 'T' -

    type GetParserResult<T> = T extends (() => infer R) | { [key: string]: () => infer R } 
        ? R : never;

Here, we are checking if 'T' extends either a standalone function or an object with a method, and we infer the return type 'R' accordingly. In this way, we do not have to check for both shapes separately.