Let's say we have a type helper like this -

    type Maybe<T> = T | null | undefined;

Here, we have a type helper 'Maybe' that can take any type 'T' and transform it into a union type that includes 'null' and 'undefined'. This is useful when you want to indicate that a value can either be of type 'T' or it can be absent (i.e., 'null' or 'undefined').

So, we can use it like this -

    type a = Maybe<null>; // x is of type null | undefined
    type b = Maybe<undefined>; // x1 is of type null | undefined
    type c = Maybe<string>; // y is of type string | null | undefined
    type d = Maybe<number>; // z is of type number | null | undefined

But, what if we want to constrain the type 'T' such that it cannot be 'null' or 'undefined'?

So, if we write -
    
    type a = Maybe<null>;
    type b = Maybe<undefined>;

This should ideally result in a type error, indicating that 'null' and 'undefined' are not valid types for 'T'.

There is a very interesting way in TypeScript to do this and that is to use an empty object type '{}' as a constraint for 'T'.

That is -

    type Maybe<T extends {}> = T | null | undefined;

And all of a sudden, if we try to use 'null' or 'undefined' as type arguments for 'T', TypeScript will throw an error -

    type a = Maybe<null>; // Error: Type 'null' does not satisfy the constraint '{}'.
    type b = Maybe<undefined>; // Error: Type 'undefined' does not satisfy the constraint '{}'.
    type c = Maybe<string>; // Valid
    type d = Maybe<number>; // Valid

But, what is going on here?

How are 'string' and 'number' satisfying the constraint '{}', while 'null' and 'undefined' are not?

In fact, even if we have -

    type e = Maybe<{}>; // Valid
    type f = Maybe<object>; // Valid
    type g = Maybe<any>; // Valid
    type h = Maybe<never>; // Valid
    type i = Maybe<(...args: any[]) => any>; // Valid

All of these are valid!

Only null and undefined are not valid!

Why is that?

TypeScript does structural comparisons when it checks if one thing is assignable to another. 

For example, if we have -

    type Maybe<T extends { wow: boolean; }> = T | null | undefined;

We can not only do -

    type Example = Maybe<{ wow: true }>; // Valid

But, we can also do -

    type Example2 = Maybe<{ wow: boolean; extraProp: string }>; // Valid

Notice how the second example has an extra property 'extraProp', yet it still satisfies the constraint '{ wow: boolean; }'.

This is how the structural comparison works in TypeScript. It does not care about the exact shape of the type, as long as it has at least the properties defined in the constraint.

In TypeScript's type system, '{}' represents the set of values that have the 'base object properties' that all JavaScript values (except null/undefined) inherit from 'Object.prototype.' Since primitives like strings and numbers can have methods called on them ("hello".toUpperCase()), TypeScript considers them to extend {}.

On the other hand, 'null' and 'undefined' do not have any properties or methods, and thus they do not satisfy the constraint '{}'.