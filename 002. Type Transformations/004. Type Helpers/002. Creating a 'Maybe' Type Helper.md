Let's go one step further now.

What if instead of returning what we pass, we want to return a type that represents either the type that we passed or null or undefined?

That is, if we have a Type Helper named 'Maybe', we should be able to do -

    type A = Maybe<string>; // string | null | undefined
    type B = Maybe<number>; // number | null | undefined

So, how do we do this?

Again, we can use the same syntax as before.

    type Maybe<T> = T | null | undefined;

Here, we created a type 'Maybe' that takes a type parameter 'T' and returns a union type of 'T', 'null', and 'undefined'.

So, whatever we pass to 'Maybe', it will use that and replace 'T' with the passed type, and return the union type.