Let's try something different. Here, we want to create a type helper that only accepts non-empty arrays.

So, if we have a type -

    type NonEmptyArray<T> = T;

We want to ensure that 'T' can only be an array type that has at least one element.

That is, if we use it like -

    type x = NonEmptyArray<[]>; // This should cause a TypeScript error
    type y = NonEmptyArray<[1]>; // This should be valid
    type z = NonEmptyArray<[1, 2, 3]>; // This should also be valid

So, how can we do this?

We know that there is a 'tuple' type in TypeScript that can represent arrays with a fixed number of elements. We can leverage this to enforce our constraint. Since we want to make sure that there is at least one element in the array, we can define our type helper like this -

    type NonEmptyArray<T extends [any]> = T;

So, what happens after we make this change?

    type x = NonEmptyArray<[]>; // ERROR

Since we said that 'T' must extend '[any]', an empty array '[]' does not satisfy this constraint, leading to a TypeScript error.

But there is one problem now -

    type y = NonEmptyArray<[1]>; // VALID
    type z = NonEmptyArray<[1, 2, 3]>; // ALSO ERROR!!! BUT WHY?

Here, even though we wanted 'z' to be valid, it is causing an error.

And if you think about it, it makes sense.

Right now, we are telling TypeScript that 'T' must extend '[any]', which means 'T' can only be a tuple with exactly one element. But, we want 'T' to be a tuple with at least one element, which means it can have one or more elements.

Remember what we did in case of functions as constraints? We used spread operator syntax to tell TypeScript that there can be zero or more parameters to a function. We can use the same idea here.

So, we can redefine our type helper like this -

    type NonEmptyArray<T extends [any, ...any]> = T;

Here, we are telling TypeScript that 'T' must extend a tuple type that has at least one element (the first 'any') followed by zero or more elements (the '...any').

And now, if we check our examples again -

    type x = NonEmptyArray<[]>; // ERROR
    type y = NonEmptyArray<[1]>; // VALID
    type z = NonEmptyArray<[1, 2, 3]>; // ALSO VALID!!!

This is how we can constrain type helpers to only accept non-empty arrays!

Now, let's do something slightly different.

We want to create a Type Helper that takes a type and returns an array type with at least one element of that type.

That is -

    type NonEmptyArrayOf<T> = T;

We should be able to use it like this -

    type a = NonEmptyArrayOf<string>; // This should be equivalent to [string, ...string[]]
    type b = NonEmptyArrayOf<number>; // This should be equivalent to [number, ...number[]]

So, how can we define this type helper?

Well, that is pretty straightforward. We can define it like this -

    type NonEmptyArrayOf<T> = [T, ...T[]];

Here, we are defining a tuple type that has at least one element of type 'T' (the first 'T') followed by zero or more elements of type 'T' (the '...T[]').

So, this is how we can create type helpers that are constrained to non-empty arrays!