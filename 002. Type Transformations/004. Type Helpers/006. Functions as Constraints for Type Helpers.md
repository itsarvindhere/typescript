In one of the previous sections where is understood the 'extends' keyword, we used it in our Helper Types to create constraints for generic types. This is particularly useful when we want to ensure that a type passed to a type helper meets certain criteria.

Now, let's take an example which is similar to that scenario.

What if, we have a Type Helper which should only accept function types as its generic argument?

For example, if we have -

    type GetParametersAndReturnType<T> = {
        params: Parameters<T>;
        returnType: ReturnType<T>;
    }

This is a type helper that extracts the parameters and return type of a function type 'T'. However, right now, TypeScript will show an error for the type 'T' saying -

    Type 'T' does not satisfy the constraint '(...args: any) => any'.

Here, TypeScript is telling us that even though we are passing 'T' to the built-in utility types 'Parameters' and 'ReturnType', it cannot guarantee that 'T' is a function type. It is throwing an error here because 'Parameters' and 'ReturnType' are only valid for function types.

So, how do we constraint 'T' to be a function type?

The answer can be easily found if we try to see the definition of 'Parameters' utility type -

    type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

Here, notice how 'T' is constrained to be a function type using the 'extends' keyword.

The same is the case with 'ReturnType' utility type as well -

    type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

So, we can do the same in our type helper as well -

    type GetParametersAndReturnType<T extends (...args: any) => any> = {
        params: Parameters<T>;
        returnType: ReturnType<T>;
    }

And boom! The error is gone.

Here, we are saying that the generic type 'T' must be a function type that takes any number of arguments (even no arguments) of any type and returns any type. This way, we ensure that 'T' is always a function type, and we can safely use 'Parameters' and 'ReturnType' on it without any errors.

Remember that (...args: any) means a function that can take any number (or zero) of arguments of any type.

So now, we can use this type helper like this -

    type Func = (a: number, b: string) => boolean;

    type Result = GetParametersAndReturnType<Func>;

Here, the type 'Result' will be -

    type Result = {
        params: [a: number, b: string];
        returnType: boolean;
    }

But, we cannot use this type helper with non-function types anymore. For example, if we try to do this -

    type Invalid = GetParametersAndReturnType<string>;

We will get an error saying -

    Type 'string' does not satisfy the constraint '(...args: any) => any'

So, this is how we can use Functions as Constraints for Type Helpers in TypeScript!