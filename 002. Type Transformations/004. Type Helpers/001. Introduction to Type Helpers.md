In TypeScript, sometimes, the built-in utility types are not enough to express certain type transformations or manipulations.

In such cases, what if we can create our own type helpers to achieve the desired type transformations?

Type Helpers are sometimes also referred to as Type Utilities or Utility Types or Helper types. These are all interchangeable terms. The main idea is that these are custom types that help in transforming or manipulating other types in TypeScript.

And to understand how we can create our own Type Helpers, let's take a pretty straightforward example.

What if we want to create a Type Helper that takes a type as its argument and gives us the same type back. Let's maybe call it 'ReturnWhatIsPassed'.

So, we want something that can do -

    ReturnWhatIsPassed<string>  // should resolve to string
    ReturnWhatIsPassed<number>  // should resolve to number
    ReturnWhatIsPassed<boolean> // should resolve to boolean

So, how do we create it?

Now, in programming, we have a concept of functions that take inputs and give outputs. We have a syntax where we define a function with parameters and a return type. There is something similar that we can do in TypeScript with types.

The syntax is also pretty similar, except that instead of using the 'function' keyword, we use the 'type' keyword to define a type alias. We can then use generics to define a type that takes a type parameter.


So, in our case, we can write -

    type ReturnWhatIsPassed<T> = T;

Here, we create a new type alias called 'ReturnWhatIsPassed' that takes a generic type parameter 'T' and simply resolves to 'T'.

This 'T' means any type. So, we can pass any type to this Type Helper, and it will return the same type.

This pattern of creating Type Helpers using generics is actually the basis of many built-in utility types in TypeScript.