Let's try something interesting now.

Suppose, we have two types -

    type BreadType = "rye" | "brown" | "white";
    type Filling = "cheese" | "ham" | "salami";

And we want a type which is a union of different combinations of these two types in a specific format. Something like -

    type Sandwich = 
      | "rye sandwich with cheese"
      | "rye sandwich with ham"
      | "rye sandwich with salami"
      | "brown sandwich with cheese"
      | "brown sandwich with ham"
      | "brown sandwich with salami"
      | "white sandwich with cheese"
      | "white sandwich with ham"
      | "white sandwich with salami";

So here, we can see that we have all possible permutations of the two types in the format of '<BreadType> sandwich with <Filling>'.

Can we achieve this using Template Literal Types?

Well, we can. We can define the 'Sandwich' type as -

    type Sandwich = `${BreadType} sandwich with ${Filling}`;

And if you now hover over the 'Sandwich' type, you will see that it has all the possible permutations of the two types in the specified format!

Isn't this amazing? This shows how powerful Template Literal Types can be in TypeScript!

Now, there is a limit on how many combinations TypeScript can handle. If the number of permutations exceeds that limit, TypeScript will throw an error. But for a reasonable number of combinations, this approach works perfectly fine.