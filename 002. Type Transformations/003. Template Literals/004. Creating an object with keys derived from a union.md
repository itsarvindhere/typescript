Let's say we have a type -

    type TemplateLiteralKey = `${"user" | "post" | "comment"}${"Id" | "name"}`

At first glance it seems kind of tricky but what is going on here is pretty simple. We have a template literal type that is made up of two unions. The first union is made up of three string literals - "user", "post" and "comment". The second union is made up of two string literals - "Id" and "name".

When TypeScript sees this template literal type, it will create a new union type by combining each member of the first union with each member of the second union. So the resulting type will be -

    type TemplateLiteralKey = "userId" | "userName" | "postId" | "postName" | "commentId" | "commentName"

Now, what if we want to generate an object like this from these keys -

    {
      userId: string;
      userName: string;
      postId: string;
      postName: string;
      commentId: string;
      commentName: string;
    }

One way is to use a Mapped type like this -

    type x = {
        [K in TemplateLiteralKey]: string
    }

Here, we are using the 'in' keyword to iterate over each member of the 'TemplateLiteralKey' union type and create a new property in the resulting object type with the same name as the member and a value of type 'string.'

There is also a second way and since we know that the type of each property is 'string', we can use the 'Record' utility type like this -

    type x = Record<TemplateLiteralKey, string>

Remember that in TypeScript, a 'Record' utility type is a shorthand way of creating an object type with a specified set of property keys and a uniform value type. So, here, we are creating a new object type where the keys are taken from the 'TemplateLiteralKey' union type and the values are of type 'string.'