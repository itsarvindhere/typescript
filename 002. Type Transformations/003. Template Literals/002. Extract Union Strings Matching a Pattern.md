Now that we know what Template Literal Types are, let's go one step further.

Let's say we have a type as -

    type Routes = "/users" | "users/:id" | "/posts" | "/posts/:id";

Here, we have a union of string literal types representing different routes in an application.

Now, we want to get all the dynamic routes from this type. That is, all the routes that contain a parameter (denoted by ':id' in this case).

So, we want something like -

    type DynamicRoutes = "users/:id" | "posts/:id";

But, we want to achieve it such that if any new dynamic routes are added to the 'Routes' type, they are automatically included in the 'DynamicRoutes' type.

We want to "Extract" all the strings from the 'Routes' type that match the pattern of having a parameter. As you might have guessed already, we will use the 'Extract' utility type.

As we know, the 'Extract' utility type has a syntax like -

    Extract<UnionType, PatternType>

So, in this case, what should be the pattern? Well, remember that the Pattern has to be some sort of type. It can be a Template Literal Type as well.

So, we can see that the pattern is something like -

    `${string}/:id`

That is, any string that ends with '/:id'. So, let's try this.

    type DynamicRoutes = Extract<Routes, `${string}:id`>;

And well, that is it! The 'DynamicRoutes' type will now automatically include all the dynamic routes from the 'Routes' type.

And if we want to be even more specific such that not only it ends with ':id', but it captures any string that has a parameter (not just ':id'), we can do something like -

    type DynamicRoutes = Extract<Routes, `${string}:${string}`>;

And now, the 'DynamicRoutes' type will include all routes that have any parameter in them (if they have a colon followed by any string at the end).

So, this shows how powerful the Template Literal Types can be when combined with utility types like 'Extract'.