Let's come back to our previous example of a discriminated union:

    type MyEvent = 
        | {
            type: 'click';
            event: 'MouseEvent';
        }
        | {
            type: 'keydown';
            event: 'KeyboardEvent';
        }
        | {
            type: 'focus';
            event: 'FocusEvent';
        };

What if we want to extract all possible values of the 'type' property from the 'MyEvent'` 'union?

That is we want something like -

    type EventType = 'click' | 'keydown' | 'focus';

Well, we can use the Indexing technique we learned earlier to achieve this.

What if we do -

    type EventType = MyEvent['type'];

What do you think will be the result of this?

Well, the result will be -

    type EventType = 'click' | 'keydown' | 'focus';

And this is what we want!

But, how does this work?

When we use the indexing technique on a union type, TypeScript evaluates the index for each member of the union separately and then combines the results into a new union type.

And to prove this, let's see what happens if we remove the 'type' property from one of the members of the union:

    type MyEventWithoutFocus = 
        | {
            type: 'click';
            event: 'MouseEvent';
        }
        | {
            type: 'keydown';
            event: 'KeyboardEvent';
        }
        | {
            event: 'FocusEvent';
        };

    type EventType = MyEvent['type']; // ERROR

Instantly, we get an error:

    Property 'type' does not exist on type 'MyEvent'.

This is because one of the members of the union does not have the 'type' property, so TypeScript cannot extract a common type for the 'type' property across all members of the union.

And that's how you can extract the discriminator from a discriminated union using TypeScript's indexing technique!