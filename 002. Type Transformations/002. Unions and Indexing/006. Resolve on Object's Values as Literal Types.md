Let's say we have an object with specific string valeus -

    const programModeEnumMap = {
        GROUP: 'group',
        ANNOUNCEMENT: 'announcement',
        ONE_ON_ONE: '1on1',
        SELF_DIRECTED: 'selfDirected',
        PLANNED_ONE_ON_ONE: 'planned1on1',
        PLANNED_SELF_DIRECTED: 'plannedSelfDirected',
    };

We want to create types for each of the values in the object above. Since we already know about indexed access types, we can do -

    export type GroupProgram = typeof programModeEnumMap['GROUP'];
    export type AnnouncementProgram = typeof programModeEnumMap['ANNOUNCEMENT'];
    export type OneOnOneProgram = typeof programModeEnumMap['ONE_ON_ONE'];
    export type SelfDirectedProgram = typeof programModeEnumMap['SELF_DIRECTED'];
    export type PlannedOneOnOneProgram = typeof programModeEnumMap['PLANNED_ONE_ON_ONE'];
    export type PlannedSelfDirectedProgram = typeof programModeEnumMap['PLANNED_SELF_DIRECTED'];

While this won't show any error, there is one problem here. 

If you hover over any of the types above in your IDE, you'll see that they are all resolved to 'string' type instead of their literal values like "group" or "announcement".

This is because TypeScript assumes that this object's values can change in the future, so it generalizes them to 'string' type.

What if we know that these values will never change? How can we tell TypeScript to treat them as literal types?

That's where we can use the 'as const' assertion.

We can simply add 'as const' at the end of our object declaration like this -

    const programModeEnumMap = {
        GROUP: 'group',
        ANNOUNCEMENT: 'announcement',
        ONE_ON_ONE: '1on1',
        SELF_DIRECTED: 'selfDirected',
        PLANNED_ONE_ON_ONE: 'planned1on1',
        PLANNED_SELF_DIRECTED: 'plannedSelfDirected',
    } as const;

And now, if you hover over the 'programModeEnumMap' object, you'll see that the type becomes -

    const programModeEnumMap: {
        readonly GROUP: "group";
        readonly ANNOUNCEMENT: "announcement";
        readonly ONE_ON_ONE: "1on1";
        readonly SELF_DIRECTED: "selfDirected";
        readonly PLANNED_ONE_ON_ONE: "planned1on1";
        readonly PLANNED_SELF_DIRECTED: "plannedSelfDirected";
    }

So now, TypeScript knows that this is a readonly object with literal string values.

And just by adding 'as const' to our object, all our indexed access types will now resolve to their correct literal types -

    export type GroupProgram = typeof programModeEnumMap['GROUP']; // "group"
    export type AnnouncementProgram = typeof programModeEnumMap['ANNOUNCEMENT']; // "announcement"
    export type OneOnOneProgram = typeof programModeEnumMap['ONE_ON_ONE']; // "1on1"
    export type SelfDirectedProgram = typeof programModeEnumMap['SELF_DIRECTED']; // "selfDirected"
    export type PlannedOneOnOneProgram = typeof programModeEnumMap['PLANNED_ONE_ON_ONE']; // "planned1on1"
    export type PlannedSelfDirectedProgram = typeof programModeEnumMap['PLANNED_SELF_DIRECTED']; // "plannedSelfDirected"

Now, remember that 'as const' is just a type assertion. It doesn't change the runtime behavior of the object. It only affects how TypeScript interprets the types.

If you want that the object remains immutable on runtime as well, you can use 'Object.freeze'. But even that only works on first level properties.

    