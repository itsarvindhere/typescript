Alright, let's now talk about indexing in TypeScript types.

Let's say we have an object -

    const fakeDataDefaults = {
        String: "Default String",
        Int: 1,
        Float: 1.14,
        Boolean: true,
        ID: "id"
    };

This is a simple object with different properties of various types. Now, what if we want to create individual types for each property in this object?

That is we want -

    type StringType = string;
    type IntType = number;
    type FloatType = number;
    type BooleanType = boolean;
    type IDType = string;

And we ant these types to be based on the values in the 'fakeDataDefaults' object.

This means, if in future we update the 'ID' to a number instead of a string, we want the 'IDType' to automatically reflect that change.

Well, it is time to use the 'Indexed Access Types' in TypeScript.

The 'Indexed Access Types' allow us to extract types from an object based on its keys. We can use this feature to create individual types for each property in our 'fakeDataDefaults' object.

Now, we cannot do something like -

    type StringType = fakeDataDefaults["String"];

Or 

    type IntType = fakeDataDefaults.String;

You will see an error -

    'fakeDataDefaults' refers to a value, but is being used as a type here. Did you mean 'typeof fakeDataDefaults'?

As it says, we need to use 'typeof' to get the type of the object first.

And once we have the type of the object, we can use the 'Indexed Access Types' to extract the types for each property.

The syntax is similar to how we would access properties in an object. That is -

    export type StringType = FakeDataDefaults['String']
    export type IntType = FakeDataDefaults['Int']
    export type FloatType = FakeDataDefaults['Float']
    export type BooleanType = FakeDataDefaults['Boolean']
    export type IDType = FakeDataDefaults['ID'];

Isn't this so simple?

This now means if in future we change the type of any property in the 'fakeDataDefaults' object, the corresponding type will automatically update to reflect that change.

Do remember that you cannot use the dot notation for indexed access types. You have to use the square bracket notation.

And we can use Indexing for the nested objects as well. For example -

    const nestedObject = {
        level1: {
            level2: {
                value: 42
            }
        }
    };

In this case, if we want the type of 'value', we can do -

    type ValueType = typeof nestedObject['level1']['level2']['value']; // number