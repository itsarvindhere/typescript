Alright, let's now try to see how we can get the union of an object's values using TypeScript's type system.

Let's take the same example as before -

    const programModeEnumMap = {
        GROUP: 'group',
        ANNOUNCEMENT: 'announcement',
        ONE_ON_ONE: '1on1',
        SELF_DIRECTED: 'selfDirected',
        PLANNED_ONE_ON_ONE: 'planned1on1',
        PLANNED_SELF_DIRECTED: 'plannedSelfDirected',
    } as const;

Basically, we want something like -

    type IndividualProgram = 'group' | 'announcement' | '1on1' | 'selfDirected' | 'planned1on1' | 'plannedSelfDirected';

So, how do we achieve this?

Well, we already know that we can use indexed access types to get the type of a specific property in an object. For example -

    type GroupProgram = typeof programModeEnumMap['GROUP'];
    type AnnouncementProgram = typeof programModeEnumMap['ANNOUNCEMENT'];

So, how do we get a union of all the values?

One way is to manually get a union like this -

    type IndividualProgram =
        typeof programModeEnumMap['GROUP'] |
        typeof programModeEnumMap['ANNOUNCEMENT'] |
        typeof programModeEnumMap['ONE_ON_ONE'] |
        typeof programModeEnumMap['SELF_DIRECTED'] |
        typeof programModeEnumMap['PLANNED_ONE_ON_ONE'] |
        typeof programModeEnumMap['PLANNED_SELF_DIRECTED'];

While this works, it is way too repetitive and not scalable. What if we had an object with 100 properties? Do we write 100 lines to get the union of all values?

There must be a better way!

Well, there is.

Remember that what we pass inside the square brackets of an indexed access type is not limited to just one specific key. We can also pass a union of keys. And in that case, TypeScript will give us a union of the corresponding value types.

This means, if we want a union of 'GROUP' and 'ANNOUNCEMENT', we can do -

    type ProgramSubset = typeof programModeEnumMap['GROUP' | 'ANNOUNCEMENT'];

This will give us the type as -

    type ProgramSubset = 'group' | 'announcement';

So, if we want a union of all the values, we can simply pass a union of all the keys of the object -

    type IndividualProgram = typeof programModeEnumMap['group' | 'announcement' | '1on1' | 'selfDirected' | 'planned1on1' | 'plannedSelfDirected'];

But even this seems like a lot of work.

What if our object has a lot of properties? We would have to manually create a union of all the keys.

Well, if we remember, there is a nice way to get a all the keys of an object type as a union using the 'keyof' operator.

And that's something we can use here.

So, we can do -

    type IndividualProgram = typeof programModeEnumMap[keyof typeof programModeEnumMap];

To make it simpler to read -

    type ProgramModeEnumMapType = typeof programModeEnumMap;
    type IndividualProgram = ProgramModeEnumMapType[keyof ProgramModeEnumMapType];

And boom! Now, the type becomes -

    type IndividualProgram = "group" | "announcement" | "1on1" | "selfDirected" | "planned1on1" | "plannedSelfDirected"

And this is what we wanted!

# ANOTHER EXAMPLE

Let's take it one step further. What if we want to create a union like this -

    type IndividualProgram = '1on1' | 'selfDirected' | 'planned1on1' | 'plannedSelfDirected';

Notice that here, we do not want the values 'group' and 'announcement'.

So, how to 'Exclude' those two values from the union we created earlier?

Well, as we saw in one of the previous sections, TypeScript provides us with a utility type called 'Exclude' that helps us do just that.

    type IndividualProgram = ProgramModeEnumMapType[Exclude<keyof ProgramModeEnumMapType, 'GROUP' | 'ANNOUNCEMENT'>];

Here, we are using the 'Exclude' utility type to exclude the keys 'GROUP' and 'ANNOUNCEMENT' from the union of all keys of the object. This gives us a union of only the keys we want, and then we use that to get the corresponding values.

If this is hard to read, we can simplify it like this -

    type AllowedProgramKeys = Exclude<keyof ProgramModeEnumMapType, 'GROUP' | 'ANNOUNCEMENT'>;
    type IndividualProgram = ProgramModeEnumMapType[AllowedProgramKeys];